/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var o = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var i = Object.create(null);\n      if (n.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(i, o, function (t) {\n        return e[t];\n      }.bind(null, o));\n      return i;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 0);\n  }([function (e, t, n) {\n    (function (t) {\n      e.exports = t.Phoenix = n(2);\n    }).call(this, n(1));\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    function i(e) {\n      return function (e) {\n        if (Array.isArray(e)) return a(e);\n      }(e) || function (e) {\n        if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n      }(e) || s(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function o(e) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function r(e, t) {\n      return function (e) {\n        if (Array.isArray(e)) return e;\n      }(e) || function (e, t) {\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n        var n = [],\n            i = !0,\n            o = !1,\n            r = void 0;\n\n        try {\n          for (var s, a = e[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          o = !0, r = e;\n        } finally {\n          try {\n            i || null == a.return || a.return();\n          } finally {\n            if (o) throw r;\n          }\n        }\n\n        return n;\n      }(e, t) || s(e, t) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function s(e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return a(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(n) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;\n      }\n    }\n\n    function a(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n\n      return i;\n    }\n\n    function c(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function u(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }\n\n    function h(e, t, n) {\n      return t && u(e.prototype, t), n && u(e, n), e;\n    }\n\n    n.r(t), n.d(t, \"Channel\", function () {\n      return A;\n    }), n.d(t, \"Serializer\", function () {\n      return M;\n    }), n.d(t, \"Socket\", function () {\n      return J;\n    }), n.d(t, \"LongPoll\", function () {\n      return H;\n    }), n.d(t, \"Ajax\", function () {\n      return D;\n    }), n.d(t, \"Presence\", function () {\n      return B;\n    });\n\n    var l = \"undefined\" != typeof self ? self : null,\n        f = \"undefined\" != typeof window ? window : null,\n        d = l || f || void 0,\n        p = 0,\n        v = 1,\n        y = 2,\n        m = 3,\n        g = \"closed\",\n        k = \"errored\",\n        b = \"joined\",\n        j = \"joining\",\n        C = \"leaving\",\n        R = \"phx_close\",\n        S = \"phx_error\",\n        T = \"phx_join\",\n        w = \"phx_reply\",\n        E = \"phx_leave\",\n        x = [R, S, T, w, E],\n        O = \"longpoll\",\n        P = \"websocket\",\n        L = function (e) {\n      if (\"function\" == typeof e) return e;\n      return function () {\n        return e;\n      };\n    },\n        _ = function () {\n      function e(t, n, i, o) {\n        c(this, e), this.channel = t, this.event = n, this.payload = i || function () {\n          return {};\n        }, this.receivedResp = null, this.timeout = o, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;\n      }\n\n      return h(e, [{\n        key: \"resend\",\n        value: function (e) {\n          this.timeout = e, this.reset(), this.send();\n        }\n      }, {\n        key: \"send\",\n        value: function () {\n          this.hasReceived(\"timeout\") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload(),\n            ref: this.ref,\n            join_ref: this.channel.joinRef()\n          }));\n        }\n      }, {\n        key: \"receive\",\n        value: function (e, t) {\n          return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({\n            status: e,\n            callback: t\n          }), this;\n        }\n      }, {\n        key: \"reset\",\n        value: function () {\n          this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;\n        }\n      }, {\n        key: \"matchReceive\",\n        value: function (e) {\n          var t = e.status,\n              n = e.response;\n          e.ref;\n          this.recHooks.filter(function (e) {\n            return e.status === t;\n          }).forEach(function (e) {\n            return e.callback(n);\n          });\n        }\n      }, {\n        key: \"cancelRefEvent\",\n        value: function () {\n          this.refEvent && this.channel.off(this.refEvent);\n        }\n      }, {\n        key: \"cancelTimeout\",\n        value: function () {\n          clearTimeout(this.timeoutTimer), this.timeoutTimer = null;\n        }\n      }, {\n        key: \"startTimeout\",\n        value: function () {\n          var e = this;\n          this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, function (t) {\n            e.cancelRefEvent(), e.cancelTimeout(), e.receivedResp = t, e.matchReceive(t);\n          }), this.timeoutTimer = setTimeout(function () {\n            e.trigger(\"timeout\", {});\n          }, this.timeout);\n        }\n      }, {\n        key: \"hasReceived\",\n        value: function (e) {\n          return this.receivedResp && this.receivedResp.status === e;\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t) {\n          this.channel.trigger(this.refEvent, {\n            status: e,\n            response: t\n          });\n        }\n      }]), e;\n    }(),\n        A = function () {\n      function e(t, n, i) {\n        var o = this;\n        c(this, e), this.state = g, this.topic = t, this.params = L(n || {}), this.socket = i, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new _(this, T, this.params, this.timeout), this.pushBuffer = [], this.stateChangeRefs = [], this.rejoinTimer = new I(function () {\n          o.socket.isConnected() && o.rejoin();\n        }, this.socket.rejoinAfterMs), this.stateChangeRefs.push(this.socket.onError(function () {\n          return o.rejoinTimer.reset();\n        })), this.stateChangeRefs.push(this.socket.onOpen(function () {\n          o.rejoinTimer.reset(), o.isErrored() && o.rejoin();\n        })), this.joinPush.receive(\"ok\", function () {\n          o.state = b, o.rejoinTimer.reset(), o.pushBuffer.forEach(function (e) {\n            return e.send();\n          }), o.pushBuffer = [];\n        }), this.joinPush.receive(\"error\", function () {\n          o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.onClose(function () {\n          o.rejoinTimer.reset(), o.socket.hasLogger() && o.socket.log(\"channel\", \"close \".concat(o.topic, \" \").concat(o.joinRef())), o.state = g, o.socket.remove(o);\n        }), this.onError(function (e) {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"error \".concat(o.topic), e), o.isJoining() && o.joinPush.reset(), o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.joinPush.receive(\"timeout\", function () {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"timeout \".concat(o.topic, \" (\").concat(o.joinRef(), \")\"), o.joinPush.timeout), new _(o, E, L({}), o.timeout).send(), o.state = k, o.joinPush.reset(), o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.on(w, function (e, t) {\n          o.trigger(o.replyEventName(t), e);\n        });\n      }\n\n      return h(e, [{\n        key: \"join\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          if (this.joinedOnce) throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n          return this.timeout = e, this.joinedOnce = !0, this.rejoin(), this.joinPush;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          this.on(R, e);\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          return this.on(S, function (t) {\n            return e(t);\n          });\n        }\n      }, {\n        key: \"on\",\n        value: function (e, t) {\n          var n = this.bindingRef++;\n          return this.bindings.push({\n            event: e,\n            ref: n,\n            callback: t\n          }), n;\n        }\n      }, {\n        key: \"off\",\n        value: function (e, t) {\n          this.bindings = this.bindings.filter(function (n) {\n            return !(n.event === e && (void 0 === t || t === n.ref));\n          });\n        }\n      }, {\n        key: \"canPush\",\n        value: function () {\n          return this.socket.isConnected() && this.isJoined();\n        }\n      }, {\n        key: \"push\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;\n          if (!this.joinedOnce) throw new Error(\"tried to push '\".concat(e, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n          var i = new _(this, e, function () {\n            return t;\n          }, n);\n          return this.canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i;\n        }\n      }, {\n        key: \"leave\",\n        value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.rejoinTimer.reset(), this.joinPush.cancelTimeout(), this.state = C;\n\n          var n = function () {\n            e.socket.hasLogger() && e.socket.log(\"channel\", \"leave \".concat(e.topic)), e.trigger(R, \"leave\");\n          },\n              i = new _(this, E, L({}), t);\n\n          return i.receive(\"ok\", function () {\n            return n();\n          }).receive(\"timeout\", function () {\n            return n();\n          }), i.send(), this.canPush() || i.trigger(\"ok\", {}), i;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e, t, n) {\n          return t;\n        }\n      }, {\n        key: \"isLifecycleEvent\",\n        value: function (e) {\n          return x.indexOf(e) >= 0;\n        }\n      }, {\n        key: \"isMember\",\n        value: function (e, t, n, i) {\n          return this.topic === e && (!i || i === this.joinRef() || !this.isLifecycleEvent(t) || (this.socket.hasLogger() && this.socket.log(\"channel\", \"dropping outdated message\", {\n            topic: e,\n            event: t,\n            payload: n,\n            joinRef: i\n          }), !1));\n        }\n      }, {\n        key: \"joinRef\",\n        value: function () {\n          return this.joinPush.ref;\n        }\n      }, {\n        key: \"rejoin\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.isLeaving() || (this.socket.leaveOpenTopic(this.topic), this.state = j, this.joinPush.resend(e));\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t, n, i) {\n          var o = this.onMessage(e, t, n, i);\n          if (t && !o) throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n\n          for (var r = this.bindings.filter(function (t) {\n            return t.event === e;\n          }), s = 0; s < r.length; s++) {\n            r[s].callback(o, n, i || this.joinRef());\n          }\n        }\n      }, {\n        key: \"replyEventName\",\n        value: function (e) {\n          return \"chan_reply_\".concat(e);\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this.state === g;\n        }\n      }, {\n        key: \"isErrored\",\n        value: function () {\n          return this.state === k;\n        }\n      }, {\n        key: \"isJoined\",\n        value: function () {\n          return this.state === b;\n        }\n      }, {\n        key: \"isJoining\",\n        value: function () {\n          return this.state === j;\n        }\n      }, {\n        key: \"isLeaving\",\n        value: function () {\n          return this.state === C;\n        }\n      }]), e;\n    }(),\n        M = {\n      encode: function (e, t) {\n        var n = [e.join_ref, e.ref, e.topic, e.event, e.payload];\n        return t(JSON.stringify(n));\n      },\n      decode: function (e, t) {\n        var n = r(JSON.parse(e), 5);\n        return t({\n          join_ref: n[0],\n          ref: n[1],\n          topic: n[2],\n          event: n[3],\n          payload: n[4]\n        });\n      }\n    },\n        J = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e), this.stateChangeCallbacks = {\n          open: [],\n          close: [],\n          error: [],\n          message: []\n        }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = i.timeout || 1e4, this.transport = i.transport || d.WebSocket || H, this.defaultEncoder = M.encode, this.defaultDecoder = M.decode, this.closeWasClean = !1, this.unloaded = !1, this.binaryType = i.binaryType || \"arraybuffer\", this.transport !== H ? (this.encode = i.encode || this.defaultEncoder, this.decode = i.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder), f && f.addEventListener && f.addEventListener(\"unload\", function (e) {\n          n.conn && (n.unloaded = !0, n.abnormalClose(\"unloaded\"));\n        }), this.heartbeatIntervalMs = i.heartbeatIntervalMs || 3e4, this.rejoinAfterMs = function (e) {\n          return i.rejoinAfterMs ? i.rejoinAfterMs(e) : [1e3, 2e3, 5e3][e - 1] || 1e4;\n        }, this.reconnectAfterMs = function (e) {\n          return n.unloaded ? 100 : i.reconnectAfterMs ? i.reconnectAfterMs(e) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][e - 1] || 5e3;\n        }, this.logger = i.logger || null, this.longpollerTimeout = i.longpollerTimeout || 2e4, this.params = L(i.params || {}), this.endPoint = \"\".concat(t, \"/\").concat(P), this.vsn = i.vsn || \"2.0.0\", this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new I(function () {\n          n.teardown(function () {\n            return n.connect();\n          });\n        }, this.reconnectAfterMs);\n      }\n\n      return h(e, [{\n        key: \"protocol\",\n        value: function () {\n          return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n        }\n      }, {\n        key: \"endPointURL\",\n        value: function () {\n          var e = D.appendParams(D.appendParams(this.endPoint, this.params()), {\n            vsn: this.vsn\n          });\n          return \"/\" !== e.charAt(0) ? e : \"/\" === e.charAt(1) ? \"\".concat(this.protocol(), \":\").concat(e) : \"\".concat(this.protocol(), \"://\").concat(location.host).concat(e);\n        }\n      }, {\n        key: \"disconnect\",\n        value: function (e, t, n) {\n          this.closeWasClean = !0, this.reconnectTimer.reset(), this.teardown(e, t, n);\n        }\n      }, {\n        key: \"connect\",\n        value: function (e) {\n          var t = this;\n          e && (console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\"), this.params = L(e)), this.conn || (this.closeWasClean = !1, this.conn = new this.transport(this.endPointURL()), this.conn.binaryType = this.binaryType, this.conn.timeout = this.longpollerTimeout, this.conn.onopen = function () {\n            return t.onConnOpen();\n          }, this.conn.onerror = function (e) {\n            return t.onConnError(e);\n          }, this.conn.onmessage = function (e) {\n            return t.onConnMessage(e);\n          }, this.conn.onclose = function (e) {\n            return t.onConnClose(e);\n          });\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t, n) {\n          this.logger(e, t, n);\n        }\n      }, {\n        key: \"hasLogger\",\n        value: function () {\n          return null !== this.logger;\n        }\n      }, {\n        key: \"onOpen\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.open.push([t, e]), t;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.close.push([t, e]), t;\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.error.push([t, e]), t;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.message.push([t, e]), t;\n        }\n      }, {\n        key: \"onConnOpen\",\n        value: function () {\n          this.hasLogger() && this.log(\"transport\", \"connected to \".concat(this.endPointURL())), this.unloaded = !1, this.closeWasClean = !1, this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(function (e) {\n            return (0, r(e, 2)[1])();\n          });\n        }\n      }, {\n        key: \"resetHeartbeat\",\n        value: function () {\n          var e = this;\n          this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(function () {\n            return e.sendHeartbeat();\n          }, this.heartbeatIntervalMs));\n        }\n      }, {\n        key: \"teardown\",\n        value: function (e, t, n) {\n          var i = this;\n          if (!this.conn) return e && e();\n          this.waitForBufferDone(function () {\n            i.conn && (t ? i.conn.close(t, n || \"\") : i.conn.close()), i.waitForSocketClosed(function () {\n              i.conn && (i.conn.onclose = function () {}, i.conn = null), e && e();\n            });\n          });\n        }\n      }, {\n        key: \"waitForBufferDone\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.bufferedAmount ? setTimeout(function () {\n            t.waitForBufferDone(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"waitForSocketClosed\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.readyState !== m ? setTimeout(function () {\n            t.waitForSocketClosed(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"onConnClose\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", \"close\", e), this.triggerChanError(), clearInterval(this.heartbeatTimer), this.closeWasClean || this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"onConnError\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", e), this.triggerChanError(), this.stateChangeCallbacks.error.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"triggerChanError\",\n        value: function () {\n          this.channels.forEach(function (e) {\n            e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(S);\n          });\n        }\n      }, {\n        key: \"connectionState\",\n        value: function () {\n          switch (this.conn && this.conn.readyState) {\n            case p:\n              return \"connecting\";\n\n            case v:\n              return \"open\";\n\n            case y:\n              return \"closing\";\n\n            default:\n              return \"closed\";\n          }\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return \"open\" === this.connectionState();\n        }\n      }, {\n        key: \"remove\",\n        value: function (e) {\n          this.off(e.stateChangeRefs), this.channels = this.channels.filter(function (t) {\n            return t.joinRef() !== e.joinRef();\n          });\n        }\n      }, {\n        key: \"off\",\n        value: function (e) {\n          for (var t in this.stateChangeCallbacks) this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter(function (t) {\n            var n = r(t, 1)[0];\n            return -1 === e.indexOf(n);\n          });\n        }\n      }, {\n        key: \"channel\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = new A(e, t, this);\n          return this.channels.push(n), n;\n        }\n      }, {\n        key: \"push\",\n        value: function (e) {\n          var t = this;\n\n          if (this.hasLogger()) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                r = e.ref,\n                s = e.join_ref;\n            this.log(\"push\", \"\".concat(n, \" \").concat(i, \" (\").concat(s, \", \").concat(r, \")\"), o);\n          }\n\n          this.isConnected() ? this.encode(e, function (e) {\n            return t.conn.send(e);\n          }) : this.sendBuffer.push(function () {\n            return t.encode(e, function (e) {\n              return t.conn.send(e);\n            });\n          });\n        }\n      }, {\n        key: \"makeRef\",\n        value: function () {\n          var e = this.ref + 1;\n          return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();\n        }\n      }, {\n        key: \"sendHeartbeat\",\n        value: function () {\n          if (this.isConnected()) {\n            if (this.pendingHeartbeatRef) return this.pendingHeartbeatRef = null, this.hasLogger() && this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\"), void this.abnormalClose(\"heartbeat timeout\");\n            this.pendingHeartbeatRef = this.makeRef(), this.push({\n              topic: \"phoenix\",\n              event: \"heartbeat\",\n              payload: {},\n              ref: this.pendingHeartbeatRef\n            });\n          }\n        }\n      }, {\n        key: \"abnormalClose\",\n        value: function (e) {\n          this.closeWasClean = !1, this.conn.close(1e3, e);\n        }\n      }, {\n        key: \"flushSendBuffer\",\n        value: function () {\n          this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(function (e) {\n            return e();\n          }), this.sendBuffer = []);\n        }\n      }, {\n        key: \"onConnMessage\",\n        value: function (e) {\n          var t = this;\n          this.decode(e.data, function (e) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                s = e.ref,\n                a = e.join_ref;\n            s && s === t.pendingHeartbeatRef && (t.pendingHeartbeatRef = null), t.hasLogger() && t.log(\"receive\", \"\".concat(o.status || \"\", \" \").concat(n, \" \").concat(i, \" \").concat(s && \"(\" + s + \")\" || \"\"), o);\n\n            for (var c = 0; c < t.channels.length; c++) {\n              var u = t.channels[c];\n              u.isMember(n, i, o, a) && u.trigger(i, o, s, a);\n            }\n\n            for (var h = 0; h < t.stateChangeCallbacks.message.length; h++) {\n              (0, r(t.stateChangeCallbacks.message[h], 2)[1])(e);\n            }\n          });\n        }\n      }, {\n        key: \"leaveOpenTopic\",\n        value: function (e) {\n          var t = this.channels.find(function (t) {\n            return t.topic === e && (t.isJoined() || t.isJoining());\n          });\n          t && (this.hasLogger() && this.log(\"transport\", 'leaving duplicate topic \"'.concat(e, '\"')), t.leave());\n        }\n      }]), e;\n    }(),\n        H = function () {\n      function e(t) {\n        c(this, e), this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.onopen = function () {}, this.onerror = function () {}, this.onmessage = function () {}, this.onclose = function () {}, this.pollEndpoint = this.normalizeEndpoint(t), this.readyState = p, this.poll();\n      }\n\n      return h(e, [{\n        key: \"normalizeEndpoint\",\n        value: function (e) {\n          return e.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + P), \"$1/\" + O);\n        }\n      }, {\n        key: \"endpointURL\",\n        value: function () {\n          return D.appendParams(this.pollEndpoint, {\n            token: this.token\n          });\n        }\n      }, {\n        key: \"closeAndRetry\",\n        value: function () {\n          this.close(), this.readyState = p;\n        }\n      }, {\n        key: \"ontimeout\",\n        value: function () {\n          this.onerror(\"timeout\"), this.closeAndRetry();\n        }\n      }, {\n        key: \"poll\",\n        value: function () {\n          var e = this;\n          this.readyState !== v && this.readyState !== p || D.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (t) {\n            if (t) {\n              var n = t.status,\n                  i = t.token,\n                  o = t.messages;\n              e.token = i;\n            } else n = 0;\n\n            switch (n) {\n              case 200:\n                o.forEach(function (t) {\n                  return e.onmessage({\n                    data: t\n                  });\n                }), e.poll();\n                break;\n\n              case 204:\n                e.poll();\n                break;\n\n              case 410:\n                e.readyState = v, e.onopen(), e.poll();\n                break;\n\n              case 403:\n                e.onerror(), e.close();\n                break;\n\n              case 0:\n              case 500:\n                e.onerror(), e.closeAndRetry();\n                break;\n\n              default:\n                throw new Error(\"unhandled poll status \".concat(n));\n            }\n          });\n        }\n      }, {\n        key: \"send\",\n        value: function (e) {\n          var t = this;\n          D.request(\"POST\", this.endpointURL(), \"application/json\", e, this.timeout, this.onerror.bind(this, \"timeout\"), function (e) {\n            e && 200 === e.status || (t.onerror(e && e.status), t.closeAndRetry());\n          });\n        }\n      }, {\n        key: \"close\",\n        value: function (e, t) {\n          this.readyState = m, this.onclose();\n        }\n      }]), e;\n    }(),\n        D = function () {\n      function e() {\n        c(this, e);\n      }\n\n      return h(e, null, [{\n        key: \"request\",\n        value: function (e, t, n, i, o, r, s) {\n          if (d.XDomainRequest) {\n            var a = new XDomainRequest();\n            this.xdomainRequest(a, e, t, i, o, r, s);\n          } else {\n            var c = new d.XMLHttpRequest();\n            this.xhrRequest(c, e, t, n, i, o, r, s);\n          }\n        }\n      }, {\n        key: \"xdomainRequest\",\n        value: function (e, t, n, i, o, r, s) {\n          var a = this;\n          e.timeout = o, e.open(t, n), e.onload = function () {\n            var t = a.parseJSON(e.responseText);\n            s && s(t);\n          }, r && (e.ontimeout = r), e.onprogress = function () {}, e.send(i);\n        }\n      }, {\n        key: \"xhrRequest\",\n        value: function (e, t, n, i, o, r, s, a) {\n          var c = this;\n          e.open(t, n, !0), e.timeout = r, e.setRequestHeader(\"Content-Type\", i), e.onerror = function () {\n            a && a(null);\n          }, e.onreadystatechange = function () {\n            if (e.readyState === c.states.complete && a) {\n              var t = c.parseJSON(e.responseText);\n              a(t);\n            }\n          }, s && (e.ontimeout = s), e.send(o);\n        }\n      }, {\n        key: \"parseJSON\",\n        value: function (e) {\n          if (!e || \"\" === e) return null;\n\n          try {\n            return JSON.parse(e);\n          } catch (t) {\n            return console && console.log(\"failed to parse JSON response\", e), null;\n          }\n        }\n      }, {\n        key: \"serialize\",\n        value: function (e, t) {\n          var n = [];\n\n          for (var i in e) if (e.hasOwnProperty(i)) {\n            var r = t ? \"\".concat(t, \"[\").concat(i, \"]\") : i,\n                s = e[i];\n            \"object\" === o(s) ? n.push(this.serialize(s, r)) : n.push(encodeURIComponent(r) + \"=\" + encodeURIComponent(s));\n          }\n\n          return n.join(\"&\");\n        }\n      }, {\n        key: \"appendParams\",\n        value: function (e, t) {\n          if (0 === Object.keys(t).length) return e;\n          var n = e.match(/\\?/) ? \"&\" : \"?\";\n          return \"\".concat(e).concat(n).concat(this.serialize(t));\n        }\n      }]), e;\n    }();\n\n    D.states = {\n      complete: 4\n    };\n\n    var B = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e);\n        var o = i.events || {\n          state: \"presence_state\",\n          diff: \"presence_diff\"\n        };\n        this.state = {}, this.pendingDiffs = [], this.channel = t, this.joinRef = null, this.caller = {\n          onJoin: function () {},\n          onLeave: function () {},\n          onSync: function () {}\n        }, this.channel.on(o.state, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.joinRef = n.channel.joinRef(), n.state = e.syncState(n.state, t, o, r), n.pendingDiffs.forEach(function (t) {\n            n.state = e.syncDiff(n.state, t, o, r);\n          }), n.pendingDiffs = [], s();\n        }), this.channel.on(o.diff, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.inPendingSyncState() ? n.pendingDiffs.push(t) : (n.state = e.syncDiff(n.state, t, o, r), s());\n        });\n      }\n\n      return h(e, [{\n        key: \"onJoin\",\n        value: function (e) {\n          this.caller.onJoin = e;\n        }\n      }, {\n        key: \"onLeave\",\n        value: function (e) {\n          this.caller.onLeave = e;\n        }\n      }, {\n        key: \"onSync\",\n        value: function (e) {\n          this.caller.onSync = e;\n        }\n      }, {\n        key: \"list\",\n        value: function (t) {\n          return e.list(this.state, t);\n        }\n      }, {\n        key: \"inPendingSyncState\",\n        value: function () {\n          return !this.joinRef || this.joinRef !== this.channel.joinRef();\n        }\n      }], [{\n        key: \"syncState\",\n        value: function (e, t, n, i) {\n          var o = this,\n              r = this.clone(e),\n              s = {},\n              a = {};\n          return this.map(r, function (e, n) {\n            t[e] || (a[e] = n);\n          }), this.map(t, function (e, t) {\n            var n = r[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = n.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  u = t.metas.filter(function (e) {\n                return c.indexOf(e.phx_ref) < 0;\n              }),\n                  h = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              });\n              u.length > 0 && (s[e] = t, s[e].metas = u), h.length > 0 && (a[e] = o.clone(n), a[e].metas = h);\n            } else s[e] = t;\n          }), this.syncDiff(r, {\n            joins: s,\n            leaves: a\n          }, n, i);\n        }\n      }, {\n        key: \"syncDiff\",\n        value: function (e, t, n, o) {\n          var r = t.joins,\n              s = t.leaves,\n              a = this.clone(e);\n          return n || (n = function () {}), o || (o = function () {}), this.map(r, function (e, t) {\n            var o = a[e];\n\n            if (a[e] = t, o) {\n              var r,\n                  s = a[e].metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = o.metas.filter(function (e) {\n                return s.indexOf(e.phx_ref) < 0;\n              });\n              (r = a[e].metas).unshift.apply(r, i(c));\n            }\n\n            n(e, o, t);\n          }), this.map(s, function (e, t) {\n            var n = a[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              });\n              n.metas = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              }), o(e, n, t), 0 === n.metas.length && delete a[e];\n            }\n          }), a;\n        }\n      }, {\n        key: \"list\",\n        value: function (e, t) {\n          return t || (t = function (e, t) {\n            return t;\n          }), this.map(e, function (e, n) {\n            return t(e, n);\n          });\n        }\n      }, {\n        key: \"map\",\n        value: function (e, t) {\n          return Object.getOwnPropertyNames(e).map(function (n) {\n            return t(n, e[n]);\n          });\n        }\n      }, {\n        key: \"clone\",\n        value: function (e) {\n          return JSON.parse(JSON.stringify(e));\n        }\n      }]), e;\n    }(),\n        I = function () {\n      function e(t, n) {\n        c(this, e), this.callback = t, this.timerCalc = n, this.timer = null, this.tries = 0;\n      }\n\n      return h(e, [{\n        key: \"reset\",\n        value: function () {\n          this.tries = 0, clearTimeout(this.timer);\n        }\n      }, {\n        key: \"scheduleTimeout\",\n        value: function () {\n          var e = this;\n          clearTimeout(this.timer), this.timer = setTimeout(function () {\n            e.tries = e.tries + 1, e.callback();\n          }, this.timerCalc(this.tries + 1));\n        }\n      }]), e;\n    }();\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanM/MzFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlBob2VuaXg9dCgpOmUuUGhvZW5peD10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIG4oaSl7aWYodFtpXSlyZXR1cm4gdFtpXS5leHBvcnRzO3ZhciBvPXRbaV09e2k6aSxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW2ldLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLG4pLG8ubD0hMCxvLmV4cG9ydHN9cmV0dXJuIG4ubT1lLG4uYz10LG4uZD1mdW5jdGlvbihlLHQsaSl7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0Oml9KX0sbi5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9bihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKG4ucihpKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSluLmQoaSxvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiBpfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LFwiYVwiLHQpLHR9LG4ubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sbi5wPVwiXCIsbihuLnM9MCl9KFtmdW5jdGlvbihlLHQsbil7KGZ1bmN0aW9uKHQpe2UuZXhwb3J0cz10LlBob2VuaXg9bigyKX0pLmNhbGwodGhpcyxuKDEpKX0sZnVuY3Rpb24oZSx0KXt2YXIgbjtuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e249bnx8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaChlKXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYobj13aW5kb3cpfWUuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gYShlKX0oZSl8fGZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIEFycmF5LmZyb20oZSl9KGUpfHxzKGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuKG89XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHIoZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFN5bWJvbHx8IShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKSlyZXR1cm47dmFyIG49W10saT0hMCxvPSExLHI9dm9pZCAwO3RyeXtmb3IodmFyIHMsYT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKGk9KHM9YS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKHMudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO2k9ITApO31jYXRjaChlKXtvPSEwLHI9ZX1maW5hbGx5e3RyeXtpfHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgcn19cmV0dXJuIG59KGUsdCl8fHMoZSx0KXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfSgpfWZ1bmN0aW9uIHMoZSx0KXtpZihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gYShlLHQpO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4/QXJyYXkuZnJvbShuKTpcIkFyZ3VtZW50c1wiPT09bnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qobik/YShlLHQpOnZvaWQgMH19ZnVuY3Rpb24gYShlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgbj0wLGk9bmV3IEFycmF5KHQpO248dDtuKyspaVtuXT1lW25dO3JldHVybiBpfWZ1bmN0aW9uIGMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIHUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaS5rZXksaSl9fWZ1bmN0aW9uIGgoZSx0LG4pe3JldHVybiB0JiZ1KGUucHJvdG90eXBlLHQpLG4mJnUoZSxuKSxlfW4ucih0KSxuLmQodCxcIkNoYW5uZWxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQX0pKSxuLmQodCxcIlNlcmlhbGl6ZXJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTX0pKSxuLmQodCxcIlNvY2tldFwiLChmdW5jdGlvbigpe3JldHVybiBKfSkpLG4uZCh0LFwiTG9uZ1BvbGxcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSH0pKSxuLmQodCxcIkFqYXhcIiwoZnVuY3Rpb24oKXtyZXR1cm4gRH0pKSxuLmQodCxcIlByZXNlbmNlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEJ9KSk7dmFyIGw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpudWxsLGY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6bnVsbCxkPWx8fGZ8fHZvaWQgMCxwPTAsdj0xLHk9MixtPTMsZz1cImNsb3NlZFwiLGs9XCJlcnJvcmVkXCIsYj1cImpvaW5lZFwiLGo9XCJqb2luaW5nXCIsQz1cImxlYXZpbmdcIixSPVwicGh4X2Nsb3NlXCIsUz1cInBoeF9lcnJvclwiLFQ9XCJwaHhfam9pblwiLHc9XCJwaHhfcmVwbHlcIixFPVwicGh4X2xlYXZlXCIseD1bUixTLFQsdyxFXSxPPVwibG9uZ3BvbGxcIixQPVwid2Vic29ja2V0XCIsTD1mdW5jdGlvbihlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlKXJldHVybiBlO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlfX0sXz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGksbyl7Yyh0aGlzLGUpLHRoaXMuY2hhbm5lbD10LHRoaXMuZXZlbnQ9bix0aGlzLnBheWxvYWQ9aXx8ZnVuY3Rpb24oKXtyZXR1cm57fX0sdGhpcy5yZWNlaXZlZFJlc3A9bnVsbCx0aGlzLnRpbWVvdXQ9byx0aGlzLnRpbWVvdXRUaW1lcj1udWxsLHRoaXMucmVjSG9va3M9W10sdGhpcy5zZW50PSExfXJldHVybiBoKGUsW3trZXk6XCJyZXNlbmRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnRpbWVvdXQ9ZSx0aGlzLnJlc2V0KCksdGhpcy5zZW5kKCl9fSx7a2V5Olwic2VuZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oYXNSZWNlaXZlZChcInRpbWVvdXRcIil8fCh0aGlzLnN0YXJ0VGltZW91dCgpLHRoaXMuc2VudD0hMCx0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe3RvcGljOnRoaXMuY2hhbm5lbC50b3BpYyxldmVudDp0aGlzLmV2ZW50LHBheWxvYWQ6dGhpcy5wYXlsb2FkKCkscmVmOnRoaXMucmVmLGpvaW5fcmVmOnRoaXMuY2hhbm5lbC5qb2luUmVmKCl9KSl9fSx7a2V5OlwicmVjZWl2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuaGFzUmVjZWl2ZWQoZSkmJnQodGhpcy5yZWNlaXZlZFJlc3AucmVzcG9uc2UpLHRoaXMucmVjSG9va3MucHVzaCh7c3RhdHVzOmUsY2FsbGJhY2s6dH0pLHRoaXN9fSx7a2V5OlwicmVzZXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2FuY2VsUmVmRXZlbnQoKSx0aGlzLnJlZj1udWxsLHRoaXMucmVmRXZlbnQ9bnVsbCx0aGlzLnJlY2VpdmVkUmVzcD1udWxsLHRoaXMuc2VudD0hMX19LHtrZXk6XCJtYXRjaFJlY2VpdmVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXR1cyxuPWUucmVzcG9uc2U7ZS5yZWY7dGhpcy5yZWNIb29rcy5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXR1cz09PXR9KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2FsbGJhY2sobil9KSl9fSx7a2V5OlwiY2FuY2VsUmVmRXZlbnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucmVmRXZlbnQmJnRoaXMuY2hhbm5lbC5vZmYodGhpcy5yZWZFdmVudCl9fSx7a2V5OlwiY2FuY2VsVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKSx0aGlzLnRpbWVvdXRUaW1lcj1udWxsfX0se2tleTpcInN0YXJ0VGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnRpbWVvdXRUaW1lciYmdGhpcy5jYW5jZWxUaW1lb3V0KCksdGhpcy5yZWY9dGhpcy5jaGFubmVsLnNvY2tldC5tYWtlUmVmKCksdGhpcy5yZWZFdmVudD10aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpLHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LChmdW5jdGlvbih0KXtlLmNhbmNlbFJlZkV2ZW50KCksZS5jYW5jZWxUaW1lb3V0KCksZS5yZWNlaXZlZFJlc3A9dCxlLm1hdGNoUmVjZWl2ZSh0KX0pKSx0aGlzLnRpbWVvdXRUaW1lcj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UudHJpZ2dlcihcInRpbWVvdXRcIix7fSl9KSx0aGlzLnRpbWVvdXQpfX0se2tleTpcImhhc1JlY2VpdmVkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwJiZ0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXM9PT1lfX0se2tleTpcInRyaWdnZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuY2hhbm5lbC50cmlnZ2VyKHRoaXMucmVmRXZlbnQse3N0YXR1czplLHJlc3BvbnNlOnR9KX19XSksZX0oKSxBPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSl7dmFyIG89dGhpcztjKHRoaXMsZSksdGhpcy5zdGF0ZT1nLHRoaXMudG9waWM9dCx0aGlzLnBhcmFtcz1MKG58fHt9KSx0aGlzLnNvY2tldD1pLHRoaXMuYmluZGluZ3M9W10sdGhpcy5iaW5kaW5nUmVmPTAsdGhpcy50aW1lb3V0PXRoaXMuc29ja2V0LnRpbWVvdXQsdGhpcy5qb2luZWRPbmNlPSExLHRoaXMuam9pblB1c2g9bmV3IF8odGhpcyxULHRoaXMucGFyYW1zLHRoaXMudGltZW91dCksdGhpcy5wdXNoQnVmZmVyPVtdLHRoaXMuc3RhdGVDaGFuZ2VSZWZzPVtdLHRoaXMucmVqb2luVGltZXI9bmV3IEkoKGZ1bmN0aW9uKCl7by5zb2NrZXQuaXNDb25uZWN0ZWQoKSYmby5yZWpvaW4oKX0pLHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpLHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoZnVuY3Rpb24oKXtyZXR1cm4gby5yZWpvaW5UaW1lci5yZXNldCgpfSkpKSx0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uT3BlbigoZnVuY3Rpb24oKXtvLnJlam9pblRpbWVyLnJlc2V0KCksby5pc0Vycm9yZWQoKSYmby5yZWpvaW4oKX0pKSksdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwib2tcIiwoZnVuY3Rpb24oKXtvLnN0YXRlPWIsby5yZWpvaW5UaW1lci5yZXNldCgpLG8ucHVzaEJ1ZmZlci5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zZW5kKCl9KSksby5wdXNoQnVmZmVyPVtdfSkpLHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsKGZ1bmN0aW9uKCl7by5zdGF0ZT1rLG8uc29ja2V0LmlzQ29ubmVjdGVkKCkmJm8ucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCl9KSksdGhpcy5vbkNsb3NlKChmdW5jdGlvbigpe28ucmVqb2luVGltZXIucmVzZXQoKSxvLnNvY2tldC5oYXNMb2dnZXIoKSYmby5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLFwiY2xvc2UgXCIuY29uY2F0KG8udG9waWMsXCIgXCIpLmNvbmNhdChvLmpvaW5SZWYoKSkpLG8uc3RhdGU9ZyxvLnNvY2tldC5yZW1vdmUobyl9KSksdGhpcy5vbkVycm9yKChmdW5jdGlvbihlKXtvLnNvY2tldC5oYXNMb2dnZXIoKSYmby5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLFwiZXJyb3IgXCIuY29uY2F0KG8udG9waWMpLGUpLG8uaXNKb2luaW5nKCkmJm8uam9pblB1c2gucmVzZXQoKSxvLnN0YXRlPWssby5zb2NrZXQuaXNDb25uZWN0ZWQoKSYmby5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKX0pKSx0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJ0aW1lb3V0XCIsKGZ1bmN0aW9uKCl7by5zb2NrZXQuaGFzTG9nZ2VyKCkmJm8uc29ja2V0LmxvZyhcImNoYW5uZWxcIixcInRpbWVvdXQgXCIuY29uY2F0KG8udG9waWMsXCIgKFwiKS5jb25jYXQoby5qb2luUmVmKCksXCIpXCIpLG8uam9pblB1c2gudGltZW91dCksbmV3IF8obyxFLEwoe30pLG8udGltZW91dCkuc2VuZCgpLG8uc3RhdGU9ayxvLmpvaW5QdXNoLnJlc2V0KCksby5zb2NrZXQuaXNDb25uZWN0ZWQoKSYmby5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKX0pKSx0aGlzLm9uKHcsKGZ1bmN0aW9uKGUsdCl7by50cmlnZ2VyKG8ucmVwbHlFdmVudE5hbWUodCksZSl9KSl9cmV0dXJuIGgoZSxbe2tleTpcImpvaW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLnRpbWVvdXQ7aWYodGhpcy5qb2luZWRPbmNlKXRocm93IG5ldyBFcnJvcihcInRyaWVkIHRvIGpvaW4gbXVsdGlwbGUgdGltZXMuICdqb2luJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZVwiKTtyZXR1cm4gdGhpcy50aW1lb3V0PWUsdGhpcy5qb2luZWRPbmNlPSEwLHRoaXMucmVqb2luKCksdGhpcy5qb2luUHVzaH19LHtrZXk6XCJvbkNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5vbihSLGUpfX0se2tleTpcIm9uRXJyb3JcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5vbihTLChmdW5jdGlvbih0KXtyZXR1cm4gZSh0KX0pKX19LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5iaW5kaW5nUmVmKys7cmV0dXJuIHRoaXMuYmluZGluZ3MucHVzaCh7ZXZlbnQ6ZSxyZWY6bixjYWxsYmFjazp0fSksbn19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuYmluZGluZ3M9dGhpcy5iaW5kaW5ncy5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVybiEobi5ldmVudD09PWUmJih2b2lkIDA9PT10fHx0PT09bi5yZWYpKX0pKX19LHtrZXk6XCJjYW5QdXNoXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSYmdGhpcy5pc0pvaW5lZCgpfX0se2tleTpcInB1c2hcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp0aGlzLnRpbWVvdXQ7aWYoIXRoaXMuam9pbmVkT25jZSl0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBwdXNoICdcIi5jb25jYXQoZSxcIicgdG8gJ1wiKS5jb25jYXQodGhpcy50b3BpYyxcIicgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNcIikpO3ZhciBpPW5ldyBfKHRoaXMsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdH0pLG4pO3JldHVybiB0aGlzLmNhblB1c2goKT9pLnNlbmQoKTooaS5zdGFydFRpbWVvdXQoKSx0aGlzLnB1c2hCdWZmZXIucHVzaChpKSksaX19LHtrZXk6XCJsZWF2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLnRpbWVvdXQ7dGhpcy5yZWpvaW5UaW1lci5yZXNldCgpLHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpLHRoaXMuc3RhdGU9Qzt2YXIgbj1mdW5jdGlvbigpe2Uuc29ja2V0Lmhhc0xvZ2dlcigpJiZlLnNvY2tldC5sb2coXCJjaGFubmVsXCIsXCJsZWF2ZSBcIi5jb25jYXQoZS50b3BpYykpLGUudHJpZ2dlcihSLFwibGVhdmVcIil9LGk9bmV3IF8odGhpcyxFLEwoe30pLHQpO3JldHVybiBpLnJlY2VpdmUoXCJva1wiLChmdW5jdGlvbigpe3JldHVybiBuKCl9KSkucmVjZWl2ZShcInRpbWVvdXRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpLGkuc2VuZCgpLHRoaXMuY2FuUHVzaCgpfHxpLnRyaWdnZXIoXCJva1wiLHt9KSxpfX0se2tleTpcIm9uTWVzc2FnZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdH19LHtrZXk6XCJpc0xpZmVjeWNsZUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHguaW5kZXhPZihlKT49MH19LHtrZXk6XCJpc01lbWJlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3JldHVybiB0aGlzLnRvcGljPT09ZSYmKCFpfHxpPT09dGhpcy5qb2luUmVmKCl8fCF0aGlzLmlzTGlmZWN5Y2xlRXZlbnQodCl8fCh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSYmdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLFwiZHJvcHBpbmcgb3V0ZGF0ZWQgbWVzc2FnZVwiLHt0b3BpYzplLGV2ZW50OnQscGF5bG9hZDpuLGpvaW5SZWY6aX0pLCExKSl9fSx7a2V5Olwiam9pblJlZlwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblB1c2gucmVmfX0se2tleTpcInJlam9pblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMudGltZW91dDt0aGlzLmlzTGVhdmluZygpfHwodGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYyksdGhpcy5zdGF0ZT1qLHRoaXMuam9pblB1c2gucmVzZW5kKGUpKX19LHtrZXk6XCJ0cmlnZ2VyXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIG89dGhpcy5vbk1lc3NhZ2UoZSx0LG4saSk7aWYodCYmIW8pdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpO2Zvcih2YXIgcj10aGlzLmJpbmRpbmdzLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXZlbnQ9PT1lfSkpLHM9MDtzPHIubGVuZ3RoO3MrKyl7cltzXS5jYWxsYmFjayhvLG4saXx8dGhpcy5qb2luUmVmKCkpfX19LHtrZXk6XCJyZXBseUV2ZW50TmFtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiY2hhbl9yZXBseV9cIi5jb25jYXQoZSl9fSx7a2V5OlwiaXNDbG9zZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09Z319LHtrZXk6XCJpc0Vycm9yZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09a319LHtrZXk6XCJpc0pvaW5lZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1ifX0se2tleTpcImlzSm9pbmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1qfX0se2tleTpcImlzTGVhdmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1DfX1dKSxlfSgpLE09e2VuY29kZTpmdW5jdGlvbihlLHQpe3ZhciBuPVtlLmpvaW5fcmVmLGUucmVmLGUudG9waWMsZS5ldmVudCxlLnBheWxvYWRdO3JldHVybiB0KEpTT04uc3RyaW5naWZ5KG4pKX0sZGVjb2RlOmZ1bmN0aW9uKGUsdCl7dmFyIG49cihKU09OLnBhcnNlKGUpLDUpO3JldHVybiB0KHtqb2luX3JlZjpuWzBdLHJlZjpuWzFdLHRvcGljOm5bMl0sZXZlbnQ6blszXSxwYXlsb2FkOm5bNF19KX19LEo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXRoaXMsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307Yyh0aGlzLGUpLHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3M9e29wZW46W10sY2xvc2U6W10sZXJyb3I6W10sbWVzc2FnZTpbXX0sdGhpcy5jaGFubmVscz1bXSx0aGlzLnNlbmRCdWZmZXI9W10sdGhpcy5yZWY9MCx0aGlzLnRpbWVvdXQ9aS50aW1lb3V0fHwxZTQsdGhpcy50cmFuc3BvcnQ9aS50cmFuc3BvcnR8fGQuV2ViU29ja2V0fHxILHRoaXMuZGVmYXVsdEVuY29kZXI9TS5lbmNvZGUsdGhpcy5kZWZhdWx0RGVjb2Rlcj1NLmRlY29kZSx0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy51bmxvYWRlZD0hMSx0aGlzLmJpbmFyeVR5cGU9aS5iaW5hcnlUeXBlfHxcImFycmF5YnVmZmVyXCIsdGhpcy50cmFuc3BvcnQhPT1IPyh0aGlzLmVuY29kZT1pLmVuY29kZXx8dGhpcy5kZWZhdWx0RW5jb2Rlcix0aGlzLmRlY29kZT1pLmRlY29kZXx8dGhpcy5kZWZhdWx0RGVjb2Rlcik6KHRoaXMuZW5jb2RlPXRoaXMuZGVmYXVsdEVuY29kZXIsdGhpcy5kZWNvZGU9dGhpcy5kZWZhdWx0RGVjb2RlciksZiYmZi5hZGRFdmVudExpc3RlbmVyJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwoZnVuY3Rpb24oZSl7bi5jb25uJiYobi51bmxvYWRlZD0hMCxuLmFibm9ybWFsQ2xvc2UoXCJ1bmxvYWRlZFwiKSl9KSksdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zPWkuaGVhcnRiZWF0SW50ZXJ2YWxNc3x8M2U0LHRoaXMucmVqb2luQWZ0ZXJNcz1mdW5jdGlvbihlKXtyZXR1cm4gaS5yZWpvaW5BZnRlck1zP2kucmVqb2luQWZ0ZXJNcyhlKTpbMWUzLDJlMyw1ZTNdW2UtMV18fDFlNH0sdGhpcy5yZWNvbm5lY3RBZnRlck1zPWZ1bmN0aW9uKGUpe3JldHVybiBuLnVubG9hZGVkPzEwMDppLnJlY29ubmVjdEFmdGVyTXM/aS5yZWNvbm5lY3RBZnRlck1zKGUpOlsxMCw1MCwxMDAsMTUwLDIwMCwyNTAsNTAwLDFlMywyZTNdW2UtMV18fDVlM30sdGhpcy5sb2dnZXI9aS5sb2dnZXJ8fG51bGwsdGhpcy5sb25ncG9sbGVyVGltZW91dD1pLmxvbmdwb2xsZXJUaW1lb3V0fHwyZTQsdGhpcy5wYXJhbXM9TChpLnBhcmFtc3x8e30pLHRoaXMuZW5kUG9pbnQ9XCJcIi5jb25jYXQodCxcIi9cIikuY29uY2F0KFApLHRoaXMudnNuPWkudnNufHxcIjIuMC4wXCIsdGhpcy5oZWFydGJlYXRUaW1lcj1udWxsLHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj1udWxsLHRoaXMucmVjb25uZWN0VGltZXI9bmV3IEkoKGZ1bmN0aW9uKCl7bi50ZWFyZG93bigoZnVuY3Rpb24oKXtyZXR1cm4gbi5jb25uZWN0KCl9KSl9KSx0aGlzLnJlY29ubmVjdEFmdGVyTXMpfXJldHVybiBoKGUsW3trZXk6XCJwcm90b2NvbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9eaHR0cHMvKT9cIndzc1wiOlwid3NcIn19LHtrZXk6XCJlbmRQb2ludFVSTFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9RC5hcHBlbmRQYXJhbXMoRC5hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCx0aGlzLnBhcmFtcygpKSx7dnNuOnRoaXMudnNufSk7cmV0dXJuXCIvXCIhPT1lLmNoYXJBdCgwKT9lOlwiL1wiPT09ZS5jaGFyQXQoMSk/XCJcIi5jb25jYXQodGhpcy5wcm90b2NvbCgpLFwiOlwiKS5jb25jYXQoZSk6XCJcIi5jb25jYXQodGhpcy5wcm90b2NvbCgpLFwiOi8vXCIpLmNvbmNhdChsb2NhdGlvbi5ob3N0KS5jb25jYXQoZSl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt0aGlzLmNsb3NlV2FzQ2xlYW49ITAsdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpLHRoaXMudGVhcmRvd24oZSx0LG4pfX0se2tleTpcImNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2UmJihjb25zb2xlJiZjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKSx0aGlzLnBhcmFtcz1MKGUpKSx0aGlzLmNvbm58fCh0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy5jb25uPW5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCkpLHRoaXMuY29ubi5iaW5hcnlUeXBlPXRoaXMuYmluYXJ5VHlwZSx0aGlzLmNvbm4udGltZW91dD10aGlzLmxvbmdwb2xsZXJUaW1lb3V0LHRoaXMuY29ubi5vbm9wZW49ZnVuY3Rpb24oKXtyZXR1cm4gdC5vbkNvbm5PcGVuKCl9LHRoaXMuY29ubi5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uQ29ubkVycm9yKGUpfSx0aGlzLmNvbm4ub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uQ29ubk1lc3NhZ2UoZSl9LHRoaXMuY29ubi5vbmNsb3NlPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uQ29ubkNsb3NlKGUpfSl9fSx7a2V5OlwibG9nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3RoaXMubG9nZ2VyKGUsdCxuKX19LHtrZXk6XCJoYXNMb2dnZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5sb2dnZXJ9fSx7a2V5Olwib25PcGVuXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5tYWtlUmVmKCk7cmV0dXJuIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFt0LGVdKSx0fX0se2tleTpcIm9uQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLm1ha2VSZWYoKTtyZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFt0LGVdKSx0fX0se2tleTpcIm9uRXJyb3JcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLm1ha2VSZWYoKTtyZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFt0LGVdKSx0fX0se2tleTpcIm9uTWVzc2FnZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMubWFrZVJlZigpO3JldHVybiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbdCxlXSksdH19LHtrZXk6XCJvbkNvbm5PcGVuXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhhc0xvZ2dlcigpJiZ0aGlzLmxvZyhcInRyYW5zcG9ydFwiLFwiY29ubmVjdGVkIHRvIFwiLmNvbmNhdCh0aGlzLmVuZFBvaW50VVJMKCkpKSx0aGlzLnVubG9hZGVkPSExLHRoaXMuY2xvc2VXYXNDbGVhbj0hMSx0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpLHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKSx0aGlzLnJlc2V0SGVhcnRiZWF0KCksdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybigwLHIoZSwyKVsxXSkoKX0pKX19LHtrZXk6XCJyZXNldEhlYXJ0YmVhdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmNvbm4mJnRoaXMuY29ubi5za2lwSGVhcnRiZWF0fHwodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmPW51bGwsY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKSx0aGlzLmhlYXJ0YmVhdFRpbWVyPXNldEludGVydmFsKChmdW5jdGlvbigpe3JldHVybiBlLnNlbmRIZWFydGJlYXQoKX0pLHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcykpfX0se2tleTpcInRlYXJkb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7aWYoIXRoaXMuY29ubilyZXR1cm4gZSYmZSgpO3RoaXMud2FpdEZvckJ1ZmZlckRvbmUoKGZ1bmN0aW9uKCl7aS5jb25uJiYodD9pLmNvbm4uY2xvc2UodCxufHxcIlwiKTppLmNvbm4uY2xvc2UoKSksaS53YWl0Rm9yU29ja2V0Q2xvc2VkKChmdW5jdGlvbigpe2kuY29ubiYmKGkuY29ubi5vbmNsb3NlPWZ1bmN0aW9uKCl7fSxpLmNvbm49bnVsbCksZSYmZSgpfSkpfSkpfX0se2tleTpcIndhaXRGb3JCdWZmZXJEb25lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxOzUhPT1uJiZ0aGlzLmNvbm4mJnRoaXMuY29ubi5idWZmZXJlZEFtb3VudD9zZXRUaW1lb3V0KChmdW5jdGlvbigpe3Qud2FpdEZvckJ1ZmZlckRvbmUoZSxuKzEpfSksMTUwKm4pOmUoKX19LHtrZXk6XCJ3YWl0Rm9yU29ja2V0Q2xvc2VkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxOzUhPT1uJiZ0aGlzLmNvbm4mJnRoaXMuY29ubi5yZWFkeVN0YXRlIT09bT9zZXRUaW1lb3V0KChmdW5jdGlvbigpe3Qud2FpdEZvclNvY2tldENsb3NlZChlLG4rMSl9KSwxNTAqbik6ZSgpfX0se2tleTpcIm9uQ29ubkNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5oYXNMb2dnZXIoKSYmdGhpcy5sb2coXCJ0cmFuc3BvcnRcIixcImNsb3NlXCIsZSksdGhpcy50cmlnZ2VyQ2hhbkVycm9yKCksY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKSx0aGlzLmNsb3NlV2FzQ2xlYW58fHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCksdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4oMCxyKHQsMilbMV0pKGUpfSkpfX0se2tleTpcIm9uQ29ubkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5oYXNMb2dnZXIoKSYmdGhpcy5sb2coXCJ0cmFuc3BvcnRcIixlKSx0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKSx0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybigwLHIodCwyKVsxXSkoZSl9KSl9fSx7a2V5OlwidHJpZ2dlckNoYW5FcnJvclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jaGFubmVscy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmlzRXJyb3JlZCgpfHxlLmlzTGVhdmluZygpfHxlLmlzQ2xvc2VkKCl8fGUudHJpZ2dlcihTKX0pKX19LHtrZXk6XCJjb25uZWN0aW9uU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbm4mJnRoaXMuY29ubi5yZWFkeVN0YXRlKXtjYXNlIHA6cmV0dXJuXCJjb25uZWN0aW5nXCI7Y2FzZSB2OnJldHVyblwib3BlblwiO2Nhc2UgeTpyZXR1cm5cImNsb3NpbmdcIjtkZWZhdWx0OnJldHVyblwiY2xvc2VkXCJ9fX0se2tleTpcImlzQ29ubmVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cIm9wZW5cIj09PXRoaXMuY29ubmVjdGlvblN0YXRlKCl9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5vZmYoZS5zdGF0ZUNoYW5nZVJlZnMpLHRoaXMuY2hhbm5lbHM9dGhpcy5jaGFubmVscy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmpvaW5SZWYoKSE9PWUuam9pblJlZigpfSkpfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKXRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3NbdF09dGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1t0XS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBuPXIodCwxKVswXTtyZXR1cm4tMT09PWUuaW5kZXhPZihuKX0pKX19LHtrZXk6XCJjaGFubmVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49bmV3IEEoZSx0LHRoaXMpO3JldHVybiB0aGlzLmNoYW5uZWxzLnB1c2gobiksbn19LHtrZXk6XCJwdXNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih0aGlzLmhhc0xvZ2dlcigpKXt2YXIgbj1lLnRvcGljLGk9ZS5ldmVudCxvPWUucGF5bG9hZCxyPWUucmVmLHM9ZS5qb2luX3JlZjt0aGlzLmxvZyhcInB1c2hcIixcIlwiLmNvbmNhdChuLFwiIFwiKS5jb25jYXQoaSxcIiAoXCIpLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KHIsXCIpXCIpLG8pfXRoaXMuaXNDb25uZWN0ZWQoKT90aGlzLmVuY29kZShlLChmdW5jdGlvbihlKXtyZXR1cm4gdC5jb25uLnNlbmQoZSl9KSk6dGhpcy5zZW5kQnVmZmVyLnB1c2goKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZW5jb2RlKGUsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmNvbm4uc2VuZChlKX0pKX0pKX19LHtrZXk6XCJtYWtlUmVmXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlZisxO3JldHVybiBlPT09dGhpcy5yZWY/dGhpcy5yZWY9MDp0aGlzLnJlZj1lLHRoaXMucmVmLnRvU3RyaW5nKCl9fSx7a2V5Olwic2VuZEhlYXJ0YmVhdFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0Nvbm5lY3RlZCgpKXtpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpcmV0dXJuIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj1udWxsLHRoaXMuaGFzTG9nZ2VyKCkmJnRoaXMubG9nKFwidHJhbnNwb3J0XCIsXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSx2b2lkIHRoaXMuYWJub3JtYWxDbG9zZShcImhlYXJ0YmVhdCB0aW1lb3V0XCIpO3RoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj10aGlzLm1ha2VSZWYoKSx0aGlzLnB1c2goe3RvcGljOlwicGhvZW5peFwiLGV2ZW50OlwiaGVhcnRiZWF0XCIscGF5bG9hZDp7fSxyZWY6dGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmfSl9fX0se2tleTpcImFibm9ybWFsQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy5jb25uLmNsb3NlKDFlMyxlKX19LHtrZXk6XCJmbHVzaFNlbmRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaXNDb25uZWN0ZWQoKSYmdGhpcy5zZW5kQnVmZmVyLmxlbmd0aD4wJiYodGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSksdGhpcy5zZW5kQnVmZmVyPVtdKX19LHtrZXk6XCJvbkNvbm5NZXNzYWdlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmRlY29kZShlLmRhdGEsKGZ1bmN0aW9uKGUpe3ZhciBuPWUudG9waWMsaT1lLmV2ZW50LG89ZS5wYXlsb2FkLHM9ZS5yZWYsYT1lLmpvaW5fcmVmO3MmJnM9PT10LnBlbmRpbmdIZWFydGJlYXRSZWYmJih0LnBlbmRpbmdIZWFydGJlYXRSZWY9bnVsbCksdC5oYXNMb2dnZXIoKSYmdC5sb2coXCJyZWNlaXZlXCIsXCJcIi5jb25jYXQoby5zdGF0dXN8fFwiXCIsXCIgXCIpLmNvbmNhdChuLFwiIFwiKS5jb25jYXQoaSxcIiBcIikuY29uY2F0KHMmJlwiKFwiK3MrXCIpXCJ8fFwiXCIpLG8pO2Zvcih2YXIgYz0wO2M8dC5jaGFubmVscy5sZW5ndGg7YysrKXt2YXIgdT10LmNoYW5uZWxzW2NdO3UuaXNNZW1iZXIobixpLG8sYSkmJnUudHJpZ2dlcihpLG8scyxhKX1mb3IodmFyIGg9MDtoPHQuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7aCsrKXsoMCxyKHQuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtoXSwyKVsxXSkoZSl9fSkpfX0se2tleTpcImxlYXZlT3BlblRvcGljXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5jaGFubmVscy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3BpYz09PWUmJih0LmlzSm9pbmVkKCl8fHQuaXNKb2luaW5nKCkpfSkpO3QmJih0aGlzLmhhc0xvZ2dlcigpJiZ0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCdsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIicuY29uY2F0KGUsJ1wiJykpLHQubGVhdmUoKSl9fV0pLGV9KCksSD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7Yyh0aGlzLGUpLHRoaXMuZW5kUG9pbnQ9bnVsbCx0aGlzLnRva2VuPW51bGwsdGhpcy5za2lwSGVhcnRiZWF0PSEwLHRoaXMub25vcGVuPWZ1bmN0aW9uKCl7fSx0aGlzLm9uZXJyb3I9ZnVuY3Rpb24oKXt9LHRoaXMub25tZXNzYWdlPWZ1bmN0aW9uKCl7fSx0aGlzLm9uY2xvc2U9ZnVuY3Rpb24oKXt9LHRoaXMucG9sbEVuZHBvaW50PXRoaXMubm9ybWFsaXplRW5kcG9pbnQodCksdGhpcy5yZWFkeVN0YXRlPXAsdGhpcy5wb2xsKCl9cmV0dXJuIGgoZSxbe2tleTpcIm5vcm1hbGl6ZUVuZHBvaW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZShcIndzOi8vXCIsXCJodHRwOi8vXCIpLnJlcGxhY2UoXCJ3c3M6Ly9cIixcImh0dHBzOi8vXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKikvXCIrUCksXCIkMS9cIitPKX19LHtrZXk6XCJlbmRwb2ludFVSTFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIEQuYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LHt0b2tlbjp0aGlzLnRva2VufSl9fSx7a2V5OlwiY2xvc2VBbmRSZXRyeVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jbG9zZSgpLHRoaXMucmVhZHlTdGF0ZT1wfX0se2tleTpcIm9udGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vbmVycm9yKFwidGltZW91dFwiKSx0aGlzLmNsb3NlQW5kUmV0cnkoKX19LHtrZXk6XCJwb2xsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucmVhZHlTdGF0ZSE9PXYmJnRoaXMucmVhZHlTdGF0ZSE9PXB8fEQucmVxdWVzdChcIkdFVFwiLHRoaXMuZW5kcG9pbnRVUkwoKSxcImFwcGxpY2F0aW9uL2pzb25cIixudWxsLHRoaXMudGltZW91dCx0aGlzLm9udGltZW91dC5iaW5kKHRoaXMpLChmdW5jdGlvbih0KXtpZih0KXt2YXIgbj10LnN0YXR1cyxpPXQudG9rZW4sbz10Lm1lc3NhZ2VzO2UudG9rZW49aX1lbHNlIG49MDtzd2l0Y2gobil7Y2FzZSAyMDA6by5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5vbm1lc3NhZ2Uoe2RhdGE6dH0pfSkpLGUucG9sbCgpO2JyZWFrO2Nhc2UgMjA0OmUucG9sbCgpO2JyZWFrO2Nhc2UgNDEwOmUucmVhZHlTdGF0ZT12LGUub25vcGVuKCksZS5wb2xsKCk7YnJlYWs7Y2FzZSA0MDM6ZS5vbmVycm9yKCksZS5jbG9zZSgpO2JyZWFrO2Nhc2UgMDpjYXNlIDUwMDplLm9uZXJyb3IoKSxlLmNsb3NlQW5kUmV0cnkoKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCBwb2xsIHN0YXR1cyBcIi5jb25jYXQobikpfX0pKX19LHtrZXk6XCJzZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztELnJlcXVlc3QoXCJQT1NUXCIsdGhpcy5lbmRwb2ludFVSTCgpLFwiYXBwbGljYXRpb24vanNvblwiLGUsdGhpcy50aW1lb3V0LHRoaXMub25lcnJvci5iaW5kKHRoaXMsXCJ0aW1lb3V0XCIpLChmdW5jdGlvbihlKXtlJiYyMDA9PT1lLnN0YXR1c3x8KHQub25lcnJvcihlJiZlLnN0YXR1cyksdC5jbG9zZUFuZFJldHJ5KCkpfSkpfX0se2tleTpcImNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLnJlYWR5U3RhdGU9bSx0aGlzLm9uY2xvc2UoKX19XSksZX0oKSxEPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2ModGhpcyxlKX1yZXR1cm4gaChlLG51bGwsW3trZXk6XCJyZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxvLHIscyl7aWYoZC5YRG9tYWluUmVxdWVzdCl7dmFyIGE9bmV3IFhEb21haW5SZXF1ZXN0O3RoaXMueGRvbWFpblJlcXVlc3QoYSxlLHQsaSxvLHIscyl9ZWxzZXt2YXIgYz1uZXcgZC5YTUxIdHRwUmVxdWVzdDt0aGlzLnhoclJlcXVlc3QoYyxlLHQsbixpLG8scixzKX19fSx7a2V5OlwieGRvbWFpblJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLG8scixzKXt2YXIgYT10aGlzO2UudGltZW91dD1vLGUub3Blbih0LG4pLGUub25sb2FkPWZ1bmN0aW9uKCl7dmFyIHQ9YS5wYXJzZUpTT04oZS5yZXNwb25zZVRleHQpO3MmJnModCl9LHImJihlLm9udGltZW91dD1yKSxlLm9ucHJvZ3Jlc3M9ZnVuY3Rpb24oKXt9LGUuc2VuZChpKX19LHtrZXk6XCJ4aHJSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxvLHIscyxhKXt2YXIgYz10aGlzO2Uub3Blbih0LG4sITApLGUudGltZW91dD1yLGUuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLGkpLGUub25lcnJvcj1mdW5jdGlvbigpe2EmJmEobnVsbCl9LGUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZS5yZWFkeVN0YXRlPT09Yy5zdGF0ZXMuY29tcGxldGUmJmEpe3ZhciB0PWMucGFyc2VKU09OKGUucmVzcG9uc2VUZXh0KTthKHQpfX0scyYmKGUub250aW1lb3V0PXMpLGUuc2VuZChvKX19LHtrZXk6XCJwYXJzZUpTT05cIix2YWx1ZTpmdW5jdGlvbihlKXtpZighZXx8XCJcIj09PWUpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBKU09OLnBhcnNlKGUpfWNhdGNoKHQpe3JldHVybiBjb25zb2xlJiZjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsZSksbnVsbH19fSx7a2V5Olwic2VyaWFsaXplXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1bXTtmb3IodmFyIGkgaW4gZSlpZihlLmhhc093blByb3BlcnR5KGkpKXt2YXIgcj10P1wiXCIuY29uY2F0KHQsXCJbXCIpLmNvbmNhdChpLFwiXVwiKTppLHM9ZVtpXTtcIm9iamVjdFwiPT09byhzKT9uLnB1c2godGhpcy5zZXJpYWxpemUocyxyKSk6bi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChyKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQocykpfXJldHVybiBuLmpvaW4oXCImXCIpfX0se2tleTpcImFwcGVuZFBhcmFtc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PU9iamVjdC5rZXlzKHQpLmxlbmd0aClyZXR1cm4gZTt2YXIgbj1lLm1hdGNoKC9cXD8vKT9cIiZcIjpcIj9cIjtyZXR1cm5cIlwiLmNvbmNhdChlKS5jb25jYXQobikuY29uY2F0KHRoaXMuc2VyaWFsaXplKHQpKX19XSksZX0oKTtELnN0YXRlcz17Y29tcGxldGU6NH07dmFyIEI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXRoaXMsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307Yyh0aGlzLGUpO3ZhciBvPWkuZXZlbnRzfHx7c3RhdGU6XCJwcmVzZW5jZV9zdGF0ZVwiLGRpZmY6XCJwcmVzZW5jZV9kaWZmXCJ9O3RoaXMuc3RhdGU9e30sdGhpcy5wZW5kaW5nRGlmZnM9W10sdGhpcy5jaGFubmVsPXQsdGhpcy5qb2luUmVmPW51bGwsdGhpcy5jYWxsZXI9e29uSm9pbjpmdW5jdGlvbigpe30sb25MZWF2ZTpmdW5jdGlvbigpe30sb25TeW5jOmZ1bmN0aW9uKCl7fX0sdGhpcy5jaGFubmVsLm9uKG8uc3RhdGUsKGZ1bmN0aW9uKHQpe3ZhciBpPW4uY2FsbGVyLG89aS5vbkpvaW4scj1pLm9uTGVhdmUscz1pLm9uU3luYztuLmpvaW5SZWY9bi5jaGFubmVsLmpvaW5SZWYoKSxuLnN0YXRlPWUuc3luY1N0YXRlKG4uc3RhdGUsdCxvLHIpLG4ucGVuZGluZ0RpZmZzLmZvckVhY2goKGZ1bmN0aW9uKHQpe24uc3RhdGU9ZS5zeW5jRGlmZihuLnN0YXRlLHQsbyxyKX0pKSxuLnBlbmRpbmdEaWZmcz1bXSxzKCl9KSksdGhpcy5jaGFubmVsLm9uKG8uZGlmZiwoZnVuY3Rpb24odCl7dmFyIGk9bi5jYWxsZXIsbz1pLm9uSm9pbixyPWkub25MZWF2ZSxzPWkub25TeW5jO24uaW5QZW5kaW5nU3luY1N0YXRlKCk/bi5wZW5kaW5nRGlmZnMucHVzaCh0KToobi5zdGF0ZT1lLnN5bmNEaWZmKG4uc3RhdGUsdCxvLHIpLHMoKSl9KSl9cmV0dXJuIGgoZSxbe2tleTpcIm9uSm9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2FsbGVyLm9uSm9pbj1lfX0se2tleTpcIm9uTGVhdmVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNhbGxlci5vbkxlYXZlPWV9fSx7a2V5Olwib25TeW5jXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5jYWxsZXIub25TeW5jPWV9fSx7a2V5OlwibGlzdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmxpc3QodGhpcy5zdGF0ZSx0KX19LHtrZXk6XCJpblBlbmRpbmdTeW5jU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLmpvaW5SZWZ8fHRoaXMuam9pblJlZiE9PXRoaXMuY2hhbm5lbC5qb2luUmVmKCl9fV0sW3trZXk6XCJzeW5jU3RhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXt2YXIgbz10aGlzLHI9dGhpcy5jbG9uZShlKSxzPXt9LGE9e307cmV0dXJuIHRoaXMubWFwKHIsKGZ1bmN0aW9uKGUsbil7dFtlXXx8KGFbZV09bil9KSksdGhpcy5tYXAodCwoZnVuY3Rpb24oZSx0KXt2YXIgbj1yW2VdO2lmKG4pe3ZhciBpPXQubWV0YXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5waHhfcmVmfSkpLGM9bi5tZXRhcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoeF9yZWZ9KSksdT10Lm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGMuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSksaD1uLm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGkuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSk7dS5sZW5ndGg+MCYmKHNbZV09dCxzW2VdLm1ldGFzPXUpLGgubGVuZ3RoPjAmJihhW2VdPW8uY2xvbmUobiksYVtlXS5tZXRhcz1oKX1lbHNlIHNbZV09dH0pKSx0aGlzLnN5bmNEaWZmKHIse2pvaW5zOnMsbGVhdmVzOmF9LG4saSl9fSx7a2V5Olwic3luY0RpZmZcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixvKXt2YXIgcj10LmpvaW5zLHM9dC5sZWF2ZXMsYT10aGlzLmNsb25lKGUpO3JldHVybiBufHwobj1mdW5jdGlvbigpe30pLG98fChvPWZ1bmN0aW9uKCl7fSksdGhpcy5tYXAociwoZnVuY3Rpb24oZSx0KXt2YXIgbz1hW2VdO2lmKGFbZV09dCxvKXt2YXIgcixzPWFbZV0ubWV0YXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5waHhfcmVmfSkpLGM9by5tZXRhcy5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBzLmluZGV4T2YoZS5waHhfcmVmKTwwfSkpOyhyPWFbZV0ubWV0YXMpLnVuc2hpZnQuYXBwbHkocixpKGMpKX1uKGUsbyx0KX0pKSx0aGlzLm1hcChzLChmdW5jdGlvbihlLHQpe3ZhciBuPWFbZV07aWYobil7dmFyIGk9dC5tZXRhcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoeF9yZWZ9KSk7bi5tZXRhcz1uLm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGkuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSksbyhlLG4sdCksMD09PW4ubWV0YXMubGVuZ3RoJiZkZWxldGUgYVtlXX19KSksYX19LHtrZXk6XCJsaXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH0pLHRoaXMubWFwKGUsKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHQoZSxuKX0pKX19LHtrZXk6XCJtYXBcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiB0KG4sZVtuXSl9KSl9fSx7a2V5OlwiY2xvbmVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlKSl9fV0pLGV9KCksST1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXtjKHRoaXMsZSksdGhpcy5jYWxsYmFjaz10LHRoaXMudGltZXJDYWxjPW4sdGhpcy50aW1lcj1udWxsLHRoaXMudHJpZXM9MH1yZXR1cm4gaChlLFt7a2V5OlwicmVzZXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudHJpZXM9MCxjbGVhclRpbWVvdXQodGhpcy50aW1lcil9fSx7a2V5Olwic2NoZWR1bGVUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2NsZWFyVGltZW91dCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS50cmllcz1lLnRyaWVzKzEsZS5jYWxsYmFjaygpfSksdGhpcy50aW1lckNhbGModGhpcy50cmllcysxKSl9fV0pLGV9KCl9XSl9KSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../deps/phoenix/priv/static/phoenix.js\n");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcz80N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgdGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG5cbiAgICBmb3JtLm1ldGhvZCA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpID09PSBcImdldFwiKSA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBmb3JtLmFjdGlvbiA9IHRvO1xuICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG5cbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBob2VuaXhMaW5rRXZlbnQgPSBuZXcgUG9seWZpbGxFdmVudCgncGhvZW5peC5saW5rLmNsaWNrJywge1xuICAgICAgICBcImJ1YmJsZXNcIjogdHJ1ZSwgXCJjYW5jZWxhYmxlXCI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChwaG9lbml4TGlua0V2ZW50KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGZhbHNlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29uZmlybVwiKTtcbiAgICBpZihtZXNzYWdlICYmICF3aW5kb3cuY29uZmlybShtZXNzYWdlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufSkoKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../deps/phoenix_html/priv/static/phoenix_html.js\n");

/***/ }),

/***/ "../deps/phoenix_live_view/priv/static/phoenix_live_view.js":
/*!******************************************************************!*\
  !*** ../deps/phoenix_live_view/priv/static/phoenix_live_view.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var r = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        configurable: !1,\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 2);\n  }([function (e, t, n) {\n    \"use strict\";\n\n    n.r(t);\n    var i,\n        r = 11;\n    var o = \"http://www.w3.org/1999/xhtml\",\n        a = \"undefined\" == typeof document ? void 0 : document,\n        u = !!a && \"content\" in a.createElement(\"template\"),\n        c = !!a && a.createRange && \"createContextualFragment\" in a.createRange();\n\n    function s(e) {\n      return e = e.trim(), u ? function (e) {\n        var t = a.createElement(\"template\");\n        return t.innerHTML = e, t.content.childNodes[0];\n      }(e) : c ? function (e) {\n        return i || (i = a.createRange()).selectNode(a.body), i.createContextualFragment(e).childNodes[0];\n      }(e) : function (e) {\n        var t = a.createElement(\"body\");\n        return t.innerHTML = e, t.childNodes[0];\n      }(e);\n    }\n\n    function l(e, t) {\n      var n,\n          i,\n          r = e.nodeName,\n          o = t.nodeName;\n      return r === o || (n = r.charCodeAt(0), i = o.charCodeAt(0), n <= 90 && i >= 97 ? r === o.toUpperCase() : i <= 90 && n >= 97 && o === r.toUpperCase());\n    }\n\n    function d(e, t, n) {\n      e[n] !== t[n] && (e[n] = t[n], e[n] ? e.setAttribute(n, \"\") : e.removeAttribute(n));\n    }\n\n    var h = {\n      OPTION: function (e, t) {\n        var n = e.parentNode;\n\n        if (n) {\n          var i = n.nodeName.toUpperCase();\n          \"OPTGROUP\" === i && (i = (n = n.parentNode) && n.nodeName.toUpperCase()), \"SELECT\" !== i || n.hasAttribute(\"multiple\") || (e.hasAttribute(\"selected\") && !t.selected && (e.setAttribute(\"selected\", \"selected\"), e.removeAttribute(\"selected\")), n.selectedIndex = -1);\n        }\n\n        d(e, t, \"selected\");\n      },\n      INPUT: function (e, t) {\n        d(e, t, \"checked\"), d(e, t, \"disabled\"), e.value !== t.value && (e.value = t.value), t.hasAttribute(\"value\") || e.removeAttribute(\"value\");\n      },\n      TEXTAREA: function (e, t) {\n        var n = t.value;\n        e.value !== n && (e.value = n);\n        var i = e.firstChild;\n\n        if (i) {\n          var r = i.nodeValue;\n          if (r == n || !n && r == e.placeholder) return;\n          i.nodeValue = n;\n        }\n      },\n      SELECT: function (e, t) {\n        if (!t.hasAttribute(\"multiple\")) {\n          for (var n, i, r = -1, o = 0, a = e.firstChild; a;) if (\"OPTGROUP\" === (i = a.nodeName && a.nodeName.toUpperCase())) a = (n = a).firstChild;else {\n            if (\"OPTION\" === i) {\n              if (a.hasAttribute(\"selected\")) {\n                r = o;\n                break;\n              }\n\n              o++;\n            }\n\n            !(a = a.nextSibling) && n && (a = n.nextSibling, n = null);\n          }\n\n          e.selectedIndex = r;\n        }\n      }\n    },\n        f = 1,\n        v = 11,\n        p = 3,\n        g = 8;\n\n    function m() {}\n\n    function y(e) {\n      if (e) return e.getAttribute && e.getAttribute(\"id\") || e.id;\n    }\n\n    var b = function (e) {\n      return function (t, n, i) {\n        if (i || (i = {}), \"string\" == typeof n) if (\"#document\" === t.nodeName || \"HTML\" === t.nodeName || \"BODY\" === t.nodeName) {\n          var r = n;\n          (n = a.createElement(\"html\")).innerHTML = r;\n        } else n = s(n);\n        var u = i.getNodeKey || y,\n            c = i.onBeforeNodeAdded || m,\n            d = i.onNodeAdded || m,\n            b = i.onBeforeElUpdated || m,\n            k = i.onElUpdated || m,\n            w = i.onBeforeNodeDiscarded || m,\n            E = i.onNodeDiscarded || m,\n            x = i.onBeforeElChildrenUpdated || m,\n            A = !0 === i.childrenOnly,\n            S = Object.create(null),\n            C = [];\n\n        function P(e) {\n          C.push(e);\n        }\n\n        function L(e, t, n) {\n          !1 !== w(e) && (t && t.removeChild(e), E(e), function e(t, n) {\n            if (t.nodeType === f) for (var i = t.firstChild; i;) {\n              var r = void 0;\n              n && (r = u(i)) ? P(r) : (E(i), i.firstChild && e(i, n)), i = i.nextSibling;\n            }\n          }(e, n));\n        }\n\n        function T(e) {\n          d(e);\n\n          for (var t = e.firstChild; t;) {\n            var n = t.nextSibling,\n                i = u(t);\n\n            if (i) {\n              var r = S[i];\n              r && l(t, r) ? (t.parentNode.replaceChild(r, t), I(r, t)) : T(t);\n            } else T(t);\n\n            t = n;\n          }\n        }\n\n        function I(t, n, i) {\n          var r = u(n);\n\n          if (r && delete S[r], !i) {\n            if (!1 === b(t, n)) return;\n            if (e(t, n), k(t), !1 === x(t, n)) return;\n          }\n\n          \"TEXTAREA\" !== t.nodeName ? function (e, t) {\n            var n,\n                i,\n                r,\n                o,\n                s,\n                d = t.firstChild,\n                v = e.firstChild;\n\n            e: for (; d;) {\n              for (o = d.nextSibling, n = u(d); v;) {\n                if (r = v.nextSibling, d.isSameNode && d.isSameNode(v)) {\n                  d = o, v = r;\n                  continue e;\n                }\n\n                i = u(v);\n                var m = v.nodeType,\n                    y = void 0;\n\n                if (m === d.nodeType && (m === f ? (n ? n !== i && ((s = S[n]) ? r === s ? y = !1 : (e.insertBefore(s, v), i ? P(i) : L(v, e, !0), v = s) : y = !1) : i && (y = !1), (y = !1 !== y && l(v, d)) && I(v, d)) : m !== p && m != g || (y = !0, v.nodeValue !== d.nodeValue && (v.nodeValue = d.nodeValue))), y) {\n                  d = o, v = r;\n                  continue e;\n                }\n\n                i ? P(i) : L(v, e, !0), v = r;\n              }\n\n              if (n && (s = S[n]) && l(s, d)) e.appendChild(s), I(s, d);else {\n                var b = c(d);\n                !1 !== b && (b && (d = b), d.actualize && (d = d.actualize(e.ownerDocument || a)), e.appendChild(d), T(d));\n              }\n              d = o, v = r;\n            }\n\n            !function (e, t, n) {\n              for (; t;) {\n                var i = t.nextSibling;\n                (n = u(t)) ? P(n) : L(t, e, !0), t = i;\n              }\n            }(e, v, i);\n            var k = h[e.nodeName];\n            k && k(e, t);\n          }(t, n) : h.TEXTAREA(t, n);\n        }\n\n        !function e(t) {\n          if (t.nodeType === f || t.nodeType === v) for (var n = t.firstChild; n;) {\n            var i = u(n);\n            i && (S[i] = n), e(n), n = n.nextSibling;\n          }\n        }(t);\n        var D = t,\n            N = D.nodeType,\n            _ = n.nodeType;\n        if (!A) if (N === f) _ === f ? l(t, n) || (E(t), D = function (e, t) {\n          for (var n = e.firstChild; n;) {\n            var i = n.nextSibling;\n            t.appendChild(n), n = i;\n          }\n\n          return t;\n        }(t, function (e, t) {\n          return t && t !== o ? a.createElementNS(t, e) : a.createElement(e);\n        }(n.nodeName, n.namespaceURI))) : D = n;else if (N === p || N === g) {\n          if (_ === N) return D.nodeValue !== n.nodeValue && (D.nodeValue = n.nodeValue), D;\n          D = n;\n        }\n        if (D === n) E(t);else {\n          if (n.isSameNode && n.isSameNode(D)) return;\n          if (I(D, n, A), C) for (var O = 0, R = C.length; O < R; O++) {\n            var H = S[C[O]];\n            H && L(H, H.parentNode, !1);\n          }\n        }\n        return !A && D !== t && t.parentNode && (D.actualize && (D = D.actualize(t.ownerDocument || a)), t.parentNode.replaceChild(D, t)), D;\n      };\n    }(function (e, t) {\n      var n,\n          i,\n          o,\n          a,\n          u = t.attributes;\n\n      if (t.nodeType !== r && e.nodeType !== r) {\n        for (var c = u.length - 1; c >= 0; c--) i = (n = u[c]).name, o = n.namespaceURI, a = n.value, o ? (i = n.localName || i, e.getAttributeNS(o, i) !== a && (\"xmlns\" === n.prefix && (i = n.name), e.setAttributeNS(o, i, a))) : e.getAttribute(i) !== a && e.setAttribute(i, a);\n\n        for (var s = e.attributes, l = s.length - 1; l >= 0; l--) i = (n = s[l]).name, (o = n.namespaceURI) ? (i = n.localName || i, t.hasAttributeNS(o, i) || e.removeAttributeNS(o, i)) : t.hasAttribute(i) || e.removeAttribute(i);\n      }\n    });\n\n    function k(e) {\n      return I(e) || A(e) || D(e) || T();\n    }\n\n    function w(e, t) {\n      var n = Object.keys(e);\n\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(e);\n        t && (i = i.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), n.push.apply(n, i);\n      }\n\n      return n;\n    }\n\n    function E(e, t, n) {\n      return t in e ? Object.defineProperty(e, t, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = n, e;\n    }\n\n    function x(e) {\n      return function (e) {\n        if (Array.isArray(e)) return N(e);\n      }(e) || A(e) || D(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function A(e) {\n      if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n    }\n\n    function S(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function C(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }\n\n    function P(e, t, n) {\n      return t && C(e.prototype, t), n && C(e, n), e;\n    }\n\n    function L(e, t) {\n      return I(e) || function (e, t) {\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n        var n = [],\n            i = !0,\n            r = !1,\n            o = void 0;\n\n        try {\n          for (var a, u = e[Symbol.iterator](); !(i = (a = u.next()).done) && (n.push(a.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          r = !0, o = e;\n        } finally {\n          try {\n            i || null == u.return || u.return();\n          } finally {\n            if (r) throw o;\n          }\n        }\n\n        return n;\n      }(e, t) || D(e, t) || T();\n    }\n\n    function T() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    function I(e) {\n      if (Array.isArray(e)) return e;\n    }\n\n    function D(e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return N(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? N(e, t) : void 0;\n      }\n    }\n\n    function N(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n\n      return i;\n    }\n\n    function _(e) {\n      \"@babel/helpers - typeof\";\n\n      return (_ = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    n.d(t, \"debug\", function () {\n      return $;\n    }), n.d(t, \"Rendered\", function () {\n      return te;\n    }), n.d(t, \"LiveSocket\", function () {\n      return ne;\n    }), n.d(t, \"Browser\", function () {\n      return ie;\n    }), n.d(t, \"DOM\", function () {\n      return re;\n    }), n.d(t, \"View\", function () {\n      return ue;\n    });\n\n    var O = [1e3, 3e3],\n        R = \"data-phx-view\",\n        H = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"],\n        j = \"data-phx-component\",\n        M = \"data-phx-ref\",\n        B = \"[\".concat(R, \"]\"),\n        U = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"],\n        J = [\"checkbox\", \"radio\"],\n        F = \"data-phx-static\",\n        V = 1,\n        q = \"phx-\",\n        W = {\n      debounce: 300,\n      throttle: 300\n    },\n        K = function (e, t) {\n      return console.error && console.error(e, t);\n    };\n\n    var $ = function (e, t, n, i) {\n      e.liveSocket.isDebugEnabled() && console.log(\"\".concat(e.id, \" \").concat(t, \": \").concat(n, \" - \"), i);\n    },\n        X = function (e) {\n      return \"function\" == typeof e ? e : function () {\n        return e;\n      };\n    },\n        z = function (e) {\n      return JSON.parse(JSON.stringify(e));\n    },\n        G = function (e, t, n) {\n      do {\n        if (e.matches(\"[\".concat(t, \"]\"))) return e;\n        e = e.parentElement || e.parentNode;\n      } while (null !== e && 1 === e.nodeType && !(n && n.isSameNode(e) || e.matches(B)));\n\n      return null;\n    },\n        Y = function (e) {\n      return null !== e && \"object\" === _(e) && !(e instanceof Array);\n    },\n        Q = function (e) {\n      for (var t in e) return !1;\n\n      return !0;\n    },\n        Z = function (e, t) {\n      return e && t(e);\n    },\n        ee = function (e) {\n      var t,\n          n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          i = new FormData(e),\n          r = new URLSearchParams(),\n          o = function (e) {\n        if (\"undefined\" == typeof Symbol || null == e[Symbol.iterator]) {\n          if (Array.isArray(e) || (e = D(e))) {\n            var t = 0,\n                n = function () {};\n\n            return {\n              s: n,\n              n: function () {\n                return t >= e.length ? {\n                  done: !0\n                } : {\n                  done: !1,\n                  value: e[t++]\n                };\n              },\n              e: function (e) {\n                throw e;\n              },\n              f: n\n            };\n          }\n\n          throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }\n\n        var i,\n            r,\n            o = !0,\n            a = !1;\n        return {\n          s: function () {\n            i = e[Symbol.iterator]();\n          },\n          n: function () {\n            var e = i.next();\n            return o = e.done, e;\n          },\n          e: function (e) {\n            a = !0, r = e;\n          },\n          f: function () {\n            try {\n              o || null == i.return || i.return();\n            } finally {\n              if (a) throw r;\n            }\n          }\n        };\n      }(i.entries());\n\n      try {\n        for (o.s(); !(t = o.n()).done;) {\n          var a = L(t.value, 2),\n              u = a[0],\n              c = a[1];\n          r.append(u, c);\n        }\n      } catch (e) {\n        o.e(e);\n      } finally {\n        o.f();\n      }\n\n      for (var s in n) r.append(s, n[s]);\n\n      return r.toString();\n    },\n        te = function () {\n      function e(t, n) {\n        S(this, e), this.viewId = t, this.rendered = {}, this.mergeDiff(n);\n      }\n\n      return P(e, null, [{\n        key: \"extract\",\n        value: function (e) {\n          var t = e.r,\n              n = e.e,\n              i = e.t;\n          return delete e.r, delete e.e, delete e.t, {\n            diff: e,\n            title: i,\n            reply: t || null,\n            events: n || []\n          };\n        }\n      }]), P(e, [{\n        key: \"parentViewId\",\n        value: function () {\n          return this.viewId;\n        }\n      }, {\n        key: \"toString\",\n        value: function (e) {\n          return this.recursiveToString(this.rendered, this.rendered.c, e);\n        }\n      }, {\n        key: \"recursiveToString\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.c,\n              n = arguments.length > 2 ? arguments[2] : void 0,\n              i = {\n            buffer: \"\",\n            components: t,\n            onlyCids: n = n ? new Set(n) : null\n          };\n          return this.toOutputBuffer(e, i), i.buffer;\n        }\n      }, {\n        key: \"componentCIDs\",\n        value: function (e) {\n          return Object.keys(e.c || {}).map(function (e) {\n            return parseInt(e);\n          });\n        }\n      }, {\n        key: \"isComponentOnlyDiff\",\n        value: function (e) {\n          return !!e.c && 1 === Object.keys(e).length;\n        }\n      }, {\n        key: \"getComponent\",\n        value: function (e, t) {\n          return e.c[t];\n        }\n      }, {\n        key: \"mergeDiff\",\n        value: function (e) {\n          var t = e.c;\n\n          if (delete e.c, this.rendered = this.recursiveMerge(this.rendered, e), this.rendered.c = this.rendered.c || {}, t) {\n            var n = this.rendered.c;\n\n            for (var i in t) {\n              var r = t[i],\n                  o = r,\n                  a = o.s;\n\n              if (\"number\" == typeof a) {\n                for (; \"number\" == typeof a;) a = (o = a > 0 ? t[a] : n[-a]).s;\n\n                o = z(o), this.doRecursiveMerge(o, r), o.s = a;\n              } else o = n[i] || {}, o = this.recursiveMerge(o, r);\n\n              t[i] = o;\n            }\n\n            for (var u in t) n[u] = t[u];\n\n            e.c = t;\n          }\n        }\n      }, {\n        key: \"recursiveMerge\",\n        value: function (e, t) {\n          return void 0 !== t.s ? t : (this.doRecursiveMerge(e, t), e);\n        }\n      }, {\n        key: \"doRecursiveMerge\",\n        value: function (e, t) {\n          for (var n in t) {\n            var i = t[n],\n                r = e[n];\n            Y(i) && void 0 === i.s && Y(r) ? this.doRecursiveMerge(r, i) : e[n] = i;\n          }\n        }\n      }, {\n        key: \"componentToString\",\n        value: function (e) {\n          return this.recursiveCIDToString(this.rendered.c, e);\n        }\n      }, {\n        key: \"pruneCIDs\",\n        value: function (e) {\n          var t = this;\n          e.forEach(function (e) {\n            return delete t.rendered.c[e];\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function () {\n          return this.rendered;\n        }\n      }, {\n        key: \"isNewFingerprint\",\n        value: function () {\n          return !!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).s;\n        }\n      }, {\n        key: \"toOutputBuffer\",\n        value: function (e, t) {\n          if (e.d) return this.comprehensionToBuffer(e, t);\n          var n = e.s;\n          t.buffer += n[0];\n\n          for (var i = 1; i < n.length; i++) this.dynamicToBuffer(e[i - 1], t), t.buffer += n[i];\n        }\n      }, {\n        key: \"comprehensionToBuffer\",\n        value: function (e, t) {\n          for (var n = e.d, i = e.s, r = 0; r < n.length; r++) {\n            var o = n[r];\n            t.buffer += i[0];\n\n            for (var a = 1; a < i.length; a++) this.dynamicToBuffer(o[a - 1], t), t.buffer += i[a];\n          }\n        }\n      }, {\n        key: \"dynamicToBuffer\",\n        value: function (e, t) {\n          \"number\" == typeof e ? t.buffer += this.recursiveCIDToString(t.components, e, t.onlyCids) : Y(e) ? this.toOutputBuffer(e, t) : t.buffer += e;\n        }\n      }, {\n        key: \"recursiveCIDToString\",\n        value: function (e, t, n) {\n          var i = this,\n              r = e[t] || K(\"no component for CID \".concat(t), e),\n              o = document.createElement(\"template\");\n          o.innerHTML = this.recursiveToString(r, e, n);\n          var a = o.content,\n              u = n && !n.has(t),\n              c = L(Array.from(a.childNodes).reduce(function (e, n, r) {\n            var a = L(e, 2),\n                c = a[0],\n                s = a[1];\n            return n.nodeType === Node.ELEMENT_NODE ? n.getAttribute(j) ? [c, !0] : (n.setAttribute(j, t), n.id || (n.id = \"\".concat(i.parentViewId(), \"-\").concat(t, \"-\").concat(r)), u && (n.setAttribute(\"data-phx-skip\", \"\"), n.innerHTML = \"\"), [!0, s]) : \"\" !== n.nodeValue.trim() ? (K(\"only HTML element tags are allowed at the root of components.\\n\\n\" + 'got: \"'.concat(n.nodeValue.trim(), '\"\\n\\n') + \"within:\\n\", o.innerHTML.trim()), n.replaceWith(i.createSpan(n.nodeValue, t)), [!0, s]) : (n.remove(), [c, s]);\n          }, [!1, !1]), 2),\n              s = c[0],\n              l = c[1];\n          return s || l ? !s && l ? (K(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", o.innerHTML.trim()), o.innerHTML) : o.innerHTML : (K(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", o.innerHTML.trim()), this.createSpan(\"\", t).outerHTML);\n        }\n      }, {\n        key: \"createSpan\",\n        value: function (e, t) {\n          var n = document.createElement(\"span\");\n          return n.innerText = e, n.setAttribute(j, t), n;\n        }\n      }]), e;\n    }(),\n        ne = function () {\n      function e(t, n) {\n        var i = this,\n            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        if (S(this, e), this.unloaded = !1, !n || \"Object\" === n.constructor.name) throw new Error('\\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\\n\\n          import {Socket} from \"phoenix\"\\n          import {LiveSocket} from \"phoenix_live_view\"\\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\\n      ');\n        this.socket = new n(t, r), this.bindingPrefix = r.bindingPrefix || q, this.opts = r, this.params = X(r.params || {}), this.viewLogger = r.viewLogger, this.metadataCallbacks = r.metadata || {}, this.defaults = Object.assign(z(W), r.defaults || {}), this.activeElement = null, this.prevActive = null, this.silenced = !1, this.main = null, this.linkRef = 0, this.roots = {}, this.href = window.location.href, this.pendingLink = null, this.currentLocation = z(window.location), this.hooks = r.hooks || {}, this.loaderTimeout = r.loaderTimeout || V, this.boundTopLevelEvents = !1, this.domCallbacks = r.dom || {\n          onBeforeElUpdated: X()\n        }, window.addEventListener(\"unload\", function (e) {\n          i.unloaded = !0;\n        }), this.socket.onOpen(function () {\n          i.isUnloaded() && window.location.reload();\n        });\n      }\n\n      return P(e, [{\n        key: \"isProfileEnabled\",\n        value: function () {\n          return \"true\" === sessionStorage.getItem(\"phx:live-socket:profiling\");\n        }\n      }, {\n        key: \"isDebugEnabled\",\n        value: function () {\n          return \"true\" === sessionStorage.getItem(\"phx:live-socket:debug\");\n        }\n      }, {\n        key: \"enableDebug\",\n        value: function () {\n          sessionStorage.setItem(\"phx:live-socket:debug\", \"true\");\n        }\n      }, {\n        key: \"enableProfiling\",\n        value: function () {\n          sessionStorage.setItem(\"phx:live-socket:profiling\", \"true\");\n        }\n      }, {\n        key: \"disableDebug\",\n        value: function () {\n          sessionStorage.removeItem(\"phx:live-socket:debug\");\n        }\n      }, {\n        key: \"disableProfiling\",\n        value: function () {\n          sessionStorage.removeItem(\"phx:live-socket:profiling\");\n        }\n      }, {\n        key: \"enableLatencySim\",\n        value: function (e) {\n          this.enableDebug(), console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\"), sessionStorage.setItem(\"phx:live-socket:latency-sim\", e);\n        }\n      }, {\n        key: \"disableLatencySim\",\n        value: function () {\n          sessionStorage.removeItem(\"phx:live-socket:latency-sim\");\n        }\n      }, {\n        key: \"getLatencySim\",\n        value: function () {\n          var e = sessionStorage.getItem(\"phx:live-socket:latency-sim\");\n          return e ? parseInt(e) : null;\n        }\n      }, {\n        key: \"getSocket\",\n        value: function () {\n          return this.socket;\n        }\n      }, {\n        key: \"connect\",\n        value: function () {\n          var e = this,\n              t = function () {\n            e.joinRootViews() && (e.bindTopLevelEvents(), e.socket.connect());\n          };\n\n          [\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0 ? t() : document.addEventListener(\"DOMContentLoaded\", function () {\n            return t();\n          });\n        }\n      }, {\n        key: \"disconnect\",\n        value: function (e) {\n          this.socket.disconnect(e);\n        }\n      }, {\n        key: \"triggerDOM\",\n        value: function (e, t) {\n          var n;\n          (n = this.domCallbacks)[e].apply(n, x(t));\n        }\n      }, {\n        key: \"time\",\n        value: function (e, t) {\n          if (!this.isProfileEnabled() || !console.time) return t();\n          console.time(e);\n          var n = t();\n          return console.timeEnd(e), n;\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t, n) {\n          if (this.viewLogger) {\n            var i = L(n(), 2),\n                r = i[0],\n                o = i[1];\n            this.viewLogger(e, t, r, o);\n          } else if (this.isDebugEnabled()) {\n            var a = L(n(), 2),\n                u = a[0],\n                c = a[1];\n            $(e, t, u, c);\n          }\n        }\n      }, {\n        key: \"onChannel\",\n        value: function (e, t, n) {\n          var i = this;\n          e.on(t, function (e) {\n            var t = i.getLatencySim();\n            t ? (console.log(\"simulating \".concat(t, \"ms of latency from server to client\")), setTimeout(function () {\n              return n(e);\n            }, t)) : n(e);\n          });\n        }\n      }, {\n        key: \"wrapPush\",\n        value: function (e) {\n          var t = this.getLatencySim();\n          if (!t) return e();\n          console.log(\"simulating \".concat(t, \"ms of latency from client to server\"));\n          var n = {\n            receives: [],\n            receive: function (e, t) {\n              this.receives.push([e, t]);\n            }\n          };\n          return setTimeout(function () {\n            n.receives.reduce(function (e, t) {\n              var n = L(t, 2),\n                  i = n[0],\n                  r = n[1];\n              return e.receive(i, r);\n            }, e());\n          }, t), n;\n        }\n      }, {\n        key: \"reloadWithJitter\",\n        value: function (e) {\n          var t = this;\n          e.destroy(), this.disconnect();\n          var n = O[0],\n              i = O[1],\n              r = Math.floor(Math.random() * (i - n + 1)) + n,\n              o = ie.updateLocal(e.name(), \"consecutive-reloads\", 0, function (e) {\n            return e + 1;\n          });\n          this.log(e, \"join\", function () {\n            return [\"encountered \".concat(o, \" consecutive reloads\")];\n          }), o > 10 && (this.log(e, \"join\", function () {\n            return [\"exceeded \".concat(10, \" consecutive reloads. Entering failsafe mode\")];\n          }), r = 3e4), setTimeout(function () {\n            t.hasPendingLink() ? window.location = t.pendingLink : window.location.reload();\n          }, r);\n        }\n      }, {\n        key: \"getHookCallbacks\",\n        value: function (e) {\n          return this.hooks[e];\n        }\n      }, {\n        key: \"isUnloaded\",\n        value: function () {\n          return this.unloaded;\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return this.socket.isConnected();\n        }\n      }, {\n        key: \"getBindingPrefix\",\n        value: function () {\n          return this.bindingPrefix;\n        }\n      }, {\n        key: \"binding\",\n        value: function (e) {\n          return \"\".concat(this.getBindingPrefix()).concat(e);\n        }\n      }, {\n        key: \"channel\",\n        value: function (e, t) {\n          return this.socket.channel(e, t);\n        }\n      }, {\n        key: \"joinRootViews\",\n        value: function () {\n          var e = this,\n              t = !1;\n          return re.all(document, \"\".concat(B, \":not([\").concat(\"data-phx-parent-id\", \"])\"), function (n) {\n            if (!e.getRootById(n.id)) {\n              var i = e.joinRootView(n, e.getHref());\n              e.root = e.root || i, n.getAttribute(\"data-phx-main\") && (e.main = i);\n            }\n\n            t = !0;\n          }), t;\n        }\n      }, {\n        key: \"redirect\",\n        value: function (e, t) {\n          this.disconnect(), ie.redirect(e, t);\n        }\n      }, {\n        key: \"replaceMain\",\n        value: function (e, t) {\n          var n = this,\n              i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.setPendingLink(e),\n              o = this.main.el;\n          this.main.showLoader(this.loaderTimeout), this.main.destroy(), ie.fetchPage(e, function (a, u) {\n            if (200 !== a) return n.redirect(e);\n            var c = document.createElement(\"template\");\n            c.innerHTML = u;\n            var s = c.content.childNodes[0];\n            if (!s || !n.isPhxView(s)) return n.redirect(e);\n            n.joinRootView(s, e, t, function (e, t) {\n              1 === t && (n.commitPendingLink(r) ? (o.replaceWith(e.el), n.main = e, i && i()) : e.destroy());\n            });\n          });\n        }\n      }, {\n        key: \"isPhxView\",\n        value: function (e) {\n          return e.getAttribute && null !== e.getAttribute(R);\n        }\n      }, {\n        key: \"joinRootView\",\n        value: function (e, t, n, i) {\n          var r = new ue(e, this, null, t, n);\n          return this.roots[r.id] = r, r.join(i), r;\n        }\n      }, {\n        key: \"owner\",\n        value: function (e, t) {\n          var n = this,\n              i = Z(e.closest(B), function (e) {\n            return n.getViewByEl(e);\n          });\n          i && t(i);\n        }\n      }, {\n        key: \"withinOwners\",\n        value: function (e, t) {\n          var n = this;\n          this.owner(e, function (i) {\n            var r = e.getAttribute(n.binding(\"target\"));\n            null === r ? t(i, e) : i.withinTargets(r, t);\n          });\n        }\n      }, {\n        key: \"getViewByEl\",\n        value: function (e) {\n          var t = e.getAttribute(\"data-phx-root-id\");\n          return Z(this.getRootById(t), function (t) {\n            return t.getDescendentByEl(e);\n          });\n        }\n      }, {\n        key: \"getRootById\",\n        value: function (e) {\n          return this.roots[e];\n        }\n      }, {\n        key: \"destroyAllViews\",\n        value: function () {\n          for (var e in this.roots) this.roots[e].destroy(), delete this.roots[e];\n        }\n      }, {\n        key: \"destroyViewByEl\",\n        value: function (e) {\n          var t = this.getRootById(e.getAttribute(\"data-phx-root-id\"));\n          t && t.destroyDescendent(e.id);\n        }\n      }, {\n        key: \"setActiveElement\",\n        value: function (e) {\n          var t = this;\n\n          if (this.activeElement !== e) {\n            this.activeElement = e;\n\n            var n = function () {\n              e === t.activeElement && (t.activeElement = null), e.removeEventListener(\"mouseup\", t), e.removeEventListener(\"touchend\", t);\n            };\n\n            e.addEventListener(\"mouseup\", n), e.addEventListener(\"touchend\", n);\n          }\n        }\n      }, {\n        key: \"getActiveElement\",\n        value: function () {\n          return document.activeElement === document.body ? this.activeElement || document.activeElement : document.activeElement || document.body;\n        }\n      }, {\n        key: \"dropActiveElement\",\n        value: function (e) {\n          this.prevActive && e.ownsElement(this.prevActive) && (this.prevActive = null);\n        }\n      }, {\n        key: \"restorePreviouslyActiveFocus\",\n        value: function () {\n          this.prevActive && this.prevActive !== document.body && this.prevActive.focus();\n        }\n      }, {\n        key: \"blurActiveElement\",\n        value: function () {\n          this.prevActive = this.getActiveElement(), this.prevActive !== document.body && this.prevActive.blur();\n        }\n      }, {\n        key: \"bindTopLevelEvents\",\n        value: function () {\n          var e = this;\n          this.boundTopLevelEvents || (this.boundTopLevelEvents = !0, window.addEventListener(\"pageshow\", function (t) {\n            t.persisted && (e.withPageLoading({\n              to: window.location.href,\n              kind: \"redirect\"\n            }), window.location.reload());\n          }), this.bindClicks(), this.bindNav(), this.bindForms(), this.bind({\n            keyup: \"keyup\",\n            keydown: \"keydown\"\n          }, function (t, n, i, r, o, a, u) {\n            var c = r.getAttribute(e.binding(\"key\")),\n                s = t.key && t.key.toLowerCase();\n            c && c.toLowerCase() !== s || i.pushKey(r, o, n, a, function (e) {\n              for (var t = 1; t < arguments.length; t++) {\n                var n = null != arguments[t] ? arguments[t] : {};\n                t % 2 ? w(Object(n), !0).forEach(function (t) {\n                  E(e, t, n[t]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w(Object(n)).forEach(function (t) {\n                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n                });\n              }\n\n              return e;\n            }({\n              key: t.key\n            }, e.eventMeta(n, t, r)));\n          }), this.bind({\n            blur: \"focusout\",\n            focus: \"focusin\"\n          }, function (t, n, i, r, o, a, u) {\n            u || i.pushEvent(n, r, o, a, e.eventMeta(n, t, r));\n          }), this.bind({\n            blur: \"blur\",\n            focus: \"focus\"\n          }, function (t, n, i, r, o, a, u) {\n            u && \"window\" !== !u && i.pushEvent(n, r, o, a, e.eventMeta(n, t, r));\n          }));\n        }\n      }, {\n        key: \"eventMeta\",\n        value: function (e, t, n) {\n          var i = this.metadataCallbacks[e];\n          return i ? i(t, n) : {};\n        }\n      }, {\n        key: \"setPendingLink\",\n        value: function (e) {\n          return this.linkRef++, this.pendingLink = e, this.linkRef;\n        }\n      }, {\n        key: \"commitPendingLink\",\n        value: function (e) {\n          return this.linkRef === e && (this.href = this.pendingLink, this.pendingLink = null, !0);\n        }\n      }, {\n        key: \"getHref\",\n        value: function () {\n          return this.href;\n        }\n      }, {\n        key: \"hasPendingLink\",\n        value: function () {\n          return !!this.pendingLink;\n        }\n      }, {\n        key: \"bind\",\n        value: function (e, t) {\n          var n = this,\n              i = function (i) {\n            var r = e[i];\n            n.on(r, function (e) {\n              var r = n.binding(i),\n                  o = n.binding(\"window-\".concat(i)),\n                  a = e.target.getAttribute && e.target.getAttribute(r);\n              a ? n.debounce(e.target, e, function () {\n                n.withinOwners(e.target, function (n, r) {\n                  t(e, i, n, e.target, r, a, null);\n                });\n              }) : re.all(document, \"[\".concat(o, \"]\"), function (r) {\n                var a = r.getAttribute(o);\n                n.debounce(r, e, function () {\n                  n.withinOwners(r, function (n, o) {\n                    t(e, i, n, r, o, a, \"window\");\n                  });\n                });\n              });\n            });\n          };\n\n          for (var r in e) i(r);\n        }\n      }, {\n        key: \"bindClicks\",\n        value: function () {\n          var e = this;\n          [!0, !1].forEach(function (t) {\n            var n = t ? e.binding(\"capture-click\") : e.binding(\"click\");\n            window.addEventListener(\"click\", function (i) {\n              var r = null,\n                  o = (r = t ? i.target.matches(\"[\".concat(n, \"]\")) ? i.target : i.target.querySelector(\"[\".concat(n, \"]\")) : G(i.target, n)) && r.getAttribute(n);\n              o && (\"#\" === r.getAttribute(\"href\") && i.preventDefault(), e.debounce(r, i, function () {\n                e.withinOwners(r, function (t, n) {\n                  t.pushEvent(\"click\", r, n, o, e.eventMeta(\"click\", i, r));\n                });\n              }));\n            }, t);\n          });\n        }\n      }, {\n        key: \"bindNav\",\n        value: function () {\n          var e = this;\n          ie.canPushState() && (window.addEventListener(\"popstate\", function (t) {\n            if (e.registerNewLocation(window.location)) {\n              var n = t.state || {},\n                  i = n.type,\n                  r = n.id,\n                  o = n.root,\n                  a = window.location.href;\n              e.main.isConnected() && \"patch\" === i && r === e.main.id ? e.main.pushLinkPatch(a, null) : e.replaceMain(a, null, function () {\n                o && e.replaceRootHistory();\n              });\n            }\n          }, !1), window.addEventListener(\"click\", function (t) {\n            var n = G(t.target, \"data-phx-link\"),\n                i = n && n.getAttribute(\"data-phx-link\"),\n                r = t.metaKey || t.ctrlKey || 1 === t.button;\n\n            if (i && e.isConnected() && e.main && !r) {\n              var o = n.href,\n                  a = n.getAttribute(\"data-phx-link-state\");\n              if (t.preventDefault(), e.pendingLink !== o) if (\"patch\" === i) e.pushHistoryPatch(o, a, n);else {\n                if (\"redirect\" !== i) throw new Error(\"expected \".concat(\"data-phx-link\", ' to be \"patch\" or \"redirect\", got: ').concat(i));\n                e.historyRedirect(o, a);\n              }\n            }\n          }, !1));\n        }\n      }, {\n        key: \"withPageLoading\",\n        value: function (e, t) {\n          re.dispatchEvent(window, \"phx:page-loading-start\", e);\n\n          var n = function () {\n            return re.dispatchEvent(window, \"phx:page-loading-stop\", e);\n          };\n\n          return t ? t(n) : n;\n        }\n      }, {\n        key: \"pushHistoryPatch\",\n        value: function (e, t, n) {\n          var i = this;\n          this.withPageLoading({\n            to: e,\n            kind: \"patch\"\n          }, function (r) {\n            i.main.pushLinkPatch(e, n, function () {\n              i.historyPatch(e, t), r();\n            });\n          });\n        }\n      }, {\n        key: \"historyPatch\",\n        value: function (e, t) {\n          ie.pushState(t, {\n            type: \"patch\",\n            id: this.main.id\n          }, e), this.registerNewLocation(window.location);\n        }\n      }, {\n        key: \"historyRedirect\",\n        value: function (e, t, n) {\n          var i = this;\n          this.withPageLoading({\n            to: e,\n            kind: \"redirect\"\n          }, function (r) {\n            i.replaceMain(e, n, function () {\n              ie.pushState(t, {\n                type: \"redirect\",\n                id: i.main.id\n              }, e), i.registerNewLocation(window.location), r();\n            });\n          });\n        }\n      }, {\n        key: \"replaceRootHistory\",\n        value: function () {\n          ie.pushState(\"replace\", {\n            root: !0,\n            type: \"patch\",\n            id: this.main.id\n          });\n        }\n      }, {\n        key: \"registerNewLocation\",\n        value: function (e) {\n          var t = this.currentLocation;\n          return t.pathname + t.search !== e.pathname + e.search && (this.currentLocation = z(e), !0);\n        }\n      }, {\n        key: \"bindForms\",\n        value: function () {\n          var e = this,\n              t = 0;\n          this.on(\"submit\", function (t) {\n            var n = t.target.getAttribute(e.binding(\"submit\"));\n            n && (t.preventDefault(), t.target.disabled = !0, e.withinOwners(t.target, function (e, i) {\n              return e.submitForm(t.target, i, n);\n            }));\n          }, !1);\n\n          for (var n = function () {\n            var n = r[i];\n            e.on(n, function (i) {\n              var r = i.target,\n                  o = r.form && r.form.getAttribute(e.binding(\"change\"));\n\n              if (o && (\"number\" !== r.type || !r.validity || !r.validity.badInput)) {\n                var a = t;\n                t++;\n                var u = re.private(r, \"prev-iteration\") || {},\n                    c = u.at,\n                    s = u.type;\n                c === a - 1 && n !== s || (re.putPrivate(r, \"prev-iteration\", {\n                  at: a,\n                  type: n\n                }), e.debounce(r, i, function () {\n                  e.withinOwners(r.form, function (t, n) {\n                    re.putPrivate(r, \"phx-has-focused\", !0), re.isTextualInput(r) || e.setActiveElement(r), t.pushInput(r, n, o, i.target);\n                  });\n                }));\n              }\n            }, !1);\n          }, i = 0, r = [\"change\", \"input\"]; i < r.length; i++) n();\n        }\n      }, {\n        key: \"debounce\",\n        value: function (e, t, n) {\n          var i = this.binding(\"debounce\"),\n              r = this.binding(\"throttle\"),\n              o = this.defaults.debounce.toString(),\n              a = this.defaults.throttle.toString();\n          re.debounce(e, t, i, o, r, a, n);\n        }\n      }, {\n        key: \"silenceEvents\",\n        value: function (e) {\n          this.silenced = !0, e(), this.silenced = !1;\n        }\n      }, {\n        key: \"on\",\n        value: function (e, t) {\n          var n = this;\n          window.addEventListener(e, function (e) {\n            n.silenced || t(e);\n          });\n        }\n      }]), e;\n    }(),\n        ie = {\n      canPushState: function () {\n        return void 0 !== history.pushState;\n      },\n      dropLocal: function (e, t) {\n        return window.localStorage.removeItem(this.localKey(e, t));\n      },\n      updateLocal: function (e, t, n, i) {\n        var r = this.getLocal(e, t),\n            o = this.localKey(e, t),\n            a = null === r ? n : i(r);\n        return window.localStorage.setItem(o, JSON.stringify(a)), a;\n      },\n      getLocal: function (e, t) {\n        return JSON.parse(window.localStorage.getItem(this.localKey(e, t)));\n      },\n      fetchPage: function (e, t) {\n        var n = new XMLHttpRequest();\n        n.open(\"GET\", e, !0), n.timeout = 3e4, n.setRequestHeader(\"content-type\", \"text/html\"), n.setRequestHeader(\"cache-control\", \"max-age=0, no-cache, no-store, must-revalidate, post-check=0, pre-check=0\"), n.setRequestHeader(\"x-requested-with\", \"live-link\"), n.onerror = function () {\n          return t(400);\n        }, n.ontimeout = function () {\n          return t(504);\n        }, n.onreadystatechange = function () {\n          if (4 === n.readyState) {\n            var i = new URL(e),\n                r = i.pathname + i.search,\n                o = Z(n.getResponseHeader(\"x-response-url\") || n.responseURL, function (e) {\n              return new URL(e);\n            }),\n                a = o ? o.pathname + o.search : null;\n            return \"live-link\" !== n.getResponseHeader(\"x-requested-with\") ? t(400) : null === o || a != r ? t(302) : 200 !== n.status ? t(n.status) : void t(200, n.responseText);\n          }\n        }, n.send();\n      },\n      pushState: function (e, t, n) {\n        if (this.canPushState()) {\n          if (n !== window.location.href) {\n            history[e + \"State\"](t, \"\", n || null);\n            var i = this.getHashTargetEl(window.location.hash);\n            i ? i.scrollIntoView() : \"redirect\" === t.type && window.scroll(0, 0);\n          }\n        } else this.redirect(n);\n      },\n      setCookie: function (e, t) {\n        document.cookie = \"\".concat(e, \"=\").concat(t);\n      },\n      getCookie: function (e) {\n        return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\".concat(e, \"s*=s*([^;]*).*$)|^.*$\")), \"$1\");\n      },\n      redirect: function (e, t) {\n        t && ie.setCookie(\"__phoenix_flash__\", t + \"; max-age=60000; path=/\"), window.location = e;\n      },\n      localKey: function (e, t) {\n        return \"\".concat(e, \"-\").concat(t);\n      },\n      getHashTargetEl: function (e) {\n        if (\"\" !== e.toString()) return document.getElementById(e) || document.querySelector('a[name=\"'.concat(e.substring(1), '\"]'));\n      }\n    },\n        re = {\n      byId: function (e) {\n        return document.getElementById(e) || K(\"no id found for \".concat(e));\n      },\n      removeClass: function (e, t) {\n        e.classList.remove(t), 0 === e.classList.length && e.removeAttribute(\"class\");\n      },\n      all: function (e, t, n) {\n        var i = Array.from(e.querySelectorAll(t));\n        return n ? i.forEach(n) : i;\n      },\n      findComponentNodeList: function (e, t) {\n        var n = this.all(e, B),\n            i = this.all(e, \"[\".concat(j, '=\"').concat(t, '\"]'));\n        return 0 === n.length ? i : i.filter(function (e) {\n          return !n.some(function (t) {\n            return t.contains(e);\n          });\n        });\n      },\n      findPhxChildrenInFragment: function (e, t) {\n        var n = document.createElement(\"template\");\n        return n.innerHTML = e, this.findPhxChildren(n.content, t);\n      },\n      isPhxUpdate: function (e, t, n) {\n        return e.getAttribute && n.indexOf(e.getAttribute(t)) >= 0;\n      },\n      findPhxChildren: function (e, t) {\n        return this.all(e, \"\".concat(B, \"[\").concat(\"data-phx-parent-id\", '=\"').concat(t, '\"]'));\n      },\n      findParentCIDs: function (e, t) {\n        var n = this,\n            i = new Set(t);\n        return t.reduce(function (t, i) {\n          var r = \"[\".concat(j, '=\"').concat(i, '\"] [').concat(j, \"]\");\n          return n.all(e, r).map(function (e) {\n            return parseInt(e.getAttribute(j));\n          }).forEach(function (e) {\n            return t.delete(e);\n          }), t;\n        }, i);\n      },\n      private: function (e, t) {\n        return e.phxPrivate && e.phxPrivate[t];\n      },\n      deletePrivate: function (e, t) {\n        e.phxPrivate && delete e.phxPrivate[t];\n      },\n      putPrivate: function (e, t, n) {\n        e.phxPrivate || (e.phxPrivate = {}), e.phxPrivate[t] = n;\n      },\n      copyPrivates: function (e, t) {\n        t.phxPrivate && (e.phxPrivate = z(t.phxPrivate));\n      },\n      putTitle: function (e) {\n        var t = document.querySelector(\"title\").dataset,\n            n = t.prefix,\n            i = t.suffix;\n        document.title = \"\".concat(n || \"\").concat(e).concat(i || \"\");\n      },\n      debounce: function (e, t, n, i, r, o, a) {\n        var u = this,\n            c = e.getAttribute(n),\n            s = e.getAttribute(r);\n        \"\" === c && (c = i), \"\" === s && (s = o);\n        var l = c || s;\n\n        switch (l) {\n          case null:\n            return a();\n\n          case \"blur\":\n            return void (this.once(e, \"debounce-blur\") && e.addEventListener(\"blur\", function () {\n              return a();\n            }));\n\n          default:\n            var d = parseInt(l),\n                h = this.incCycle(e, \"debounce-trigger\", function () {\n              return s ? u.deletePrivate(e, \"throttled\") : a();\n            });\n            if (isNaN(d)) return K(\"invalid throttle/debounce value: \".concat(l));\n\n            if (s) {\n              var f = !1;\n\n              if (\"keydown\" === t.type) {\n                var v = this.private(e, \"debounce-prev-key\");\n                this.putPrivate(e, \"debounce-prev-key\", t.key), f = v !== t.key;\n              }\n\n              if (!f && this.private(e, \"throttled\")) return !1;\n              a(), this.putPrivate(e, \"throttled\", !0), setTimeout(function () {\n                return u.triggerCycle(e, \"debounce-trigger\");\n              }, d);\n            } else setTimeout(function () {\n              return u.triggerCycle(e, \"debounce-trigger\", h);\n            }, d);\n\n            e.form && this.once(e.form, \"bind-debounce\") && e.form.addEventListener(\"submit\", function (t) {\n              Array.from(new FormData(e.form).entries(), function (t) {\n                var n = L(t, 2),\n                    i = n[0],\n                    r = (n[1], e.form.querySelector('[name=\"'.concat(i, '\"]')));\n                u.incCycle(r, \"debounce-trigger\"), u.deletePrivate(r, \"throttled\");\n              });\n            }), this.once(e, \"bind-debounce\") && e.addEventListener(\"blur\", function (t) {\n              return u.triggerCycle(e, \"debounce-trigger\");\n            });\n        }\n      },\n      triggerCycle: function (e, t, n) {\n        var i = L(this.private(e, t), 2),\n            r = i[0],\n            o = i[1];\n        n || (n = r), n === r && (this.incCycle(e, t), o());\n      },\n      once: function (e, t) {\n        return !0 !== this.private(e, t) && (this.putPrivate(e, t, !0), !0);\n      },\n      incCycle: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {},\n            i = L(this.private(e, t) || [0, n], 2),\n            r = i[0];\n        i[1];\n        return r++, this.putPrivate(e, t, [r, n]), r;\n      },\n      discardError: function (e, t, n) {\n        var i = t.getAttribute && t.getAttribute(n),\n            r = i && e.querySelector(\"#\".concat(i));\n        r && (this.private(r, \"phx-has-focused\") || this.private(r.form, \"phx-has-submitted\") || t.classList.add(\"phx-no-feedback\"));\n      },\n      isPhxChild: function (e) {\n        return e.getAttribute && e.getAttribute(\"data-phx-parent-id\");\n      },\n      dispatchEvent: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n            i = new CustomEvent(t, {\n          bubbles: !0,\n          cancelable: !0,\n          detail: n\n        });\n        e.dispatchEvent(i);\n      },\n      cloneNode: function (e, t) {\n        if (void 0 === t) return e.cloneNode(!0);\n        var n = e.cloneNode(!1);\n        return n.innerHTML = t, n;\n      },\n      mergeAttrs: function (e, t) {\n        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], i = t.attributes, r = i.length - 1; r >= 0; r--) {\n          var o = i[r].name;\n          n.indexOf(o) < 0 && e.setAttribute(o, t.getAttribute(o));\n        }\n\n        for (var a = e.attributes, u = a.length - 1; u >= 0; u--) {\n          var c = a[u].name;\n          t.hasAttribute(c) || e.removeAttribute(c);\n        }\n      },\n      mergeFocusedInput: function (e, t) {\n        e instanceof HTMLSelectElement || re.mergeAttrs(e, t, [\"value\"]), t.readOnly ? e.setAttribute(\"readonly\", !0) : e.removeAttribute(\"readonly\");\n      },\n      hasSelectionRange: function (e) {\n        return e.setSelectionRange && (\"text\" === e.type || \"textarea\" === e.type);\n      },\n      restoreFocus: function (e, t, n) {\n        if (re.isTextualInput(e)) {\n          var i = e.matches(\":focus\");\n          e.readOnly && e.blur(), i || e.focus(), this.hasSelectionRange(e) && e.setSelectionRange(t, n);\n        }\n      },\n      isFormInput: function (e) {\n        return /^(?:input|select|textarea)$/i.test(e.tagName) && \"button\" !== e.type;\n      },\n      syncAttrsToProps: function (e) {\n        e instanceof HTMLInputElement && J.indexOf(e.type.toLocaleLowerCase()) >= 0 && (e.checked = null !== e.getAttribute(\"checked\"));\n      },\n      isTextualInput: function (e) {\n        return U.indexOf(e.type) >= 0;\n      },\n      isNowTriggerFormExternal: function (e, t) {\n        return e.getAttribute && null !== e.getAttribute(t);\n      },\n      syncPendingRef: function (e, t, n) {\n        var i = e.getAttribute(M);\n        return null === i || (re.isFormInput(e) || null !== e.getAttribute(n) ? (re.putPrivate(e, M, t), !1) : (H.forEach(function (n) {\n          e.classList.contains(n) && t.classList.add(n);\n        }), t.setAttribute(M, i), !0));\n      },\n      cleanChildNodes: function (e, t) {\n        if (re.isPhxUpdate(e, t, [\"append\", \"prepend\"])) {\n          var n = [];\n          e.childNodes.forEach(function (e) {\n            e.id || (e.nodeType === Node.TEXT_NODE && \"\" === e.nodeValue.trim() || K(\"only HTML element tags with an id are allowed inside containers with phx-update.\\n\\n\" + 'removing illegal node: \"'.concat((e.outerHTML || e.nodeValue).trim(), '\"\\n\\n')), n.push(e));\n          }), n.forEach(function (e) {\n            return e.remove();\n          });\n        }\n      }\n    },\n        oe = function () {\n      function e(t, n, i) {\n        S(this, e);\n        var r = Array.from(n.children).map(function (e) {\n          return e.id;\n        }),\n            o = [],\n            a = [];\n        t.childNodes.forEach(function (e) {\n          e.id && (o.push(e.id), r.indexOf(e.id) >= 0 && a.push([e.id, e.previousElementSibling && e.previousElementSibling.id]));\n        }), this.containerID = n.id, this.updateType = i, this.modifiedIds = a, this.newIds = r.filter(function (e) {\n          return o.indexOf(e) < 0;\n        });\n      }\n\n      return P(e, [{\n        key: \"perform\",\n        value: function () {\n          var e = re.byId(this.containerID);\n          this.modifiedIds.forEach(function (t) {\n            var n = L(t, 2),\n                i = n[0],\n                r = n[1];\n            r ? Z(document.getElementById(r), function (e) {\n              Z(document.getElementById(i), function (t) {\n                t.previousElementSibling && t.previousElementSibling.id == e.id || e.insertAdjacentElement(\"afterend\", t);\n              });\n            }) : Z(document.getElementById(i), function (t) {\n              null == t.previousElementSibling || e.insertAdjacentElement(\"afterbegin\", t);\n            });\n          }), \"prepend\" == this.updateType && this.newIds.reverse().forEach(function (t) {\n            Z(document.getElementById(t), function (t) {\n              return e.insertAdjacentElement(\"afterbegin\", t);\n            });\n          });\n        }\n      }]), e;\n    }(),\n        ae = function () {\n      function e(t, n, i, r, o) {\n        S(this, e), this.view = t, this.liveSocket = t.liveSocket, this.container = n, this.id = i, this.rootID = t.root.id, this.html = r, this.targetCID = o, this.cidPatch = \"number\" == typeof this.targetCID, this.callbacks = {\n          beforeadded: [],\n          beforeupdated: [],\n          beforediscarded: [],\n          beforephxChildAdded: [],\n          afteradded: [],\n          afterupdated: [],\n          afterdiscarded: [],\n          afterphxChildAdded: []\n        };\n      }\n\n      return P(e, null, [{\n        key: \"patchEl\",\n        value: function (e, t, n) {\n          b(e, t, {\n            childrenOnly: !1,\n            onBeforeElUpdated: function (e, t) {\n              if (n && n.isSameNode(e) && re.isFormInput(e)) return re.mergeFocusedInput(e, t), !1;\n            }\n          });\n        }\n      }]), P(e, [{\n        key: \"before\",\n        value: function (e, t) {\n          this.callbacks[\"before\".concat(e)].push(t);\n        }\n      }, {\n        key: \"after\",\n        value: function (e, t) {\n          this.callbacks[\"after\".concat(e)].push(t);\n        }\n      }, {\n        key: \"trackBefore\",\n        value: function (e) {\n          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];\n\n          this.callbacks[\"before\".concat(e)].forEach(function (e) {\n            return e.apply(void 0, n);\n          });\n        }\n      }, {\n        key: \"trackAfter\",\n        value: function (e) {\n          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];\n\n          this.callbacks[\"after\".concat(e)].forEach(function (e) {\n            return e.apply(void 0, n);\n          });\n        }\n      }, {\n        key: \"markPrunableContentForRemoval\",\n        value: function () {\n          re.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", function (e) {\n            e.setAttribute(\"data-phx-remove\", \"\");\n          });\n        }\n      }, {\n        key: \"perform\",\n        value: function () {\n          var e = this,\n              t = this.view,\n              n = this.liveSocket,\n              i = this.container,\n              r = this.html,\n              o = this.isCIDPatch() ? this.targetCIDContainer() : i;\n\n          if (!this.isCIDPatch() || o) {\n            var a = n.getActiveElement(),\n                u = a && re.hasSelectionRange(a) ? a : {},\n                c = u.selectionStart,\n                s = u.selectionEnd,\n                l = n.binding(\"update\"),\n                d = n.binding(\"feedback-for\"),\n                h = n.binding(\"disable-with\"),\n                f = n.binding(\"trigger-action\"),\n                v = [],\n                p = [],\n                g = [],\n                m = n.time(\"premorph container prep\", function () {\n              return e.buildDiffHTML(i, r, l, o);\n            });\n            return this.trackBefore(\"added\", i), this.trackBefore(\"updated\", i, i), n.time(\"morphdom\", function () {\n              b(o, m, {\n                childrenOnly: null === o.getAttribute(j),\n                onBeforeNodeAdded: function (t) {\n                  return re.discardError(o, t, d), e.trackBefore(\"added\", t), t;\n                },\n                onNodeAdded: function (n) {\n                  re.isNowTriggerFormExternal(n, f) && n.submit(), re.isPhxChild(n) && t.ownsElement(n) && e.trackAfter(\"phxChildAdded\", n), v.push(n);\n                },\n                onNodeDiscarded: function (t) {\n                  re.isPhxChild(t) && n.destroyViewByEl(t), e.trackAfter(\"discarded\", t);\n                },\n                onBeforeNodeDiscarded: function (t) {\n                  return !(!t.getAttribute || null === t.getAttribute(\"data-phx-remove\")) || (null === t.parentNode || !re.isPhxUpdate(t.parentNode, l, [\"append\", \"prepend\"]) || !t.id) && !e.skipCIDSibling(t) && (e.trackBefore(\"discarded\", t), !0);\n                },\n                onElUpdated: function (e) {\n                  re.isNowTriggerFormExternal(e, f) && e.submit(), p.push(e);\n                },\n                onBeforeElUpdated: function (t, n) {\n                  if (re.cleanChildNodes(n, l), e.skipCIDSibling(n)) return !1;\n                  if (\"ignore\" === t.getAttribute(l)) return e.trackBefore(\"updated\", t, n), re.mergeAttrs(t, n), p.push(t), !1;\n                  if (\"number\" === t.type && t.validity && t.validity.badInput) return !1;\n                  if (!re.syncPendingRef(t, n, h)) return !1;\n\n                  if (re.isPhxChild(n)) {\n                    var i = t.getAttribute(F);\n                    return re.mergeAttrs(t, n), t.setAttribute(F, i), t.setAttribute(\"data-phx-root-id\", e.rootID), !1;\n                  }\n\n                  return re.copyPrivates(n, t), re.discardError(o, n, d), a && t.isSameNode(a) && re.isFormInput(t) && !e.forceFocusedSelectUpdate(t, n) ? (e.trackBefore(\"updated\", t, n), re.mergeFocusedInput(t, n), re.syncAttrsToProps(t), p.push(t), !1) : (re.isPhxUpdate(n, l, [\"append\", \"prepend\"]) && g.push(new oe(t, n, n.getAttribute(l))), re.syncAttrsToProps(n), e.trackBefore(\"updated\", t, n), !0);\n                }\n              });\n            }), n.isDebugEnabled() && function () {\n              for (var e = new Set(), t = document.querySelectorAll(\"*[id]\"), n = 0, i = t.length; n < i; n++) e.has(t[n].id) ? console.error(\"Multiple IDs detected: \".concat(t[n].id, \". Ensure unique element ids.\")) : e.add(t[n].id);\n            }(), g.length > 0 && n.time(\"post-morph append/prepend restoration\", function () {\n              g.forEach(function (e) {\n                return e.perform();\n              });\n            }), n.silenceEvents(function () {\n              return re.restoreFocus(a, c, s);\n            }), re.dispatchEvent(document, \"phx:update\"), v.forEach(function (t) {\n              return e.trackAfter(\"added\", t);\n            }), p.forEach(function (t) {\n              return e.trackAfter(\"updated\", t);\n            }), !0;\n          }\n        }\n      }, {\n        key: \"forceFocusedSelectUpdate\",\n        value: function (e, t) {\n          return !0 === e.multiple || e.innerHTML != t.innerHTML;\n        }\n      }, {\n        key: \"isCIDPatch\",\n        value: function () {\n          return this.cidPatch;\n        }\n      }, {\n        key: \"skipCIDSibling\",\n        value: function (e) {\n          return e.nodeType === Node.ELEMENT_NODE && null !== e.getAttribute(\"data-phx-skip\");\n        }\n      }, {\n        key: \"targetCIDContainer\",\n        value: function () {\n          if (this.isCIDPatch()) {\n            var e = k(re.findComponentNodeList(this.container, this.targetCID)),\n                t = e[0];\n            return 0 === e.slice(1).length ? t : t && t.parentNode;\n          }\n        }\n      }, {\n        key: \"buildDiffHTML\",\n        value: function (e, t, n, i) {\n          var r = this,\n              o = this.isCIDPatch(),\n              a = o && i.getAttribute(j) === this.targetCID.toString();\n          if (!o || a) return t;\n          var u = null,\n              c = document.createElement(\"template\");\n          u = re.cloneNode(i);\n          var s = k(re.findComponentNodeList(u, this.targetCID)),\n              l = s[0],\n              d = s.slice(1);\n          return c.innerHTML = t, d.forEach(function (e) {\n            return e.remove();\n          }), Array.from(u.childNodes).forEach(function (e) {\n            e.id && e.nodeType === Node.ELEMENT_NODE && e.getAttribute(j) !== r.targetCID.toString() && (e.setAttribute(\"data-phx-skip\", \"\"), e.innerHTML = \"\");\n          }), Array.from(c.content.childNodes).forEach(function (e) {\n            return u.insertBefore(e, l);\n          }), l.remove(), u.outerHTML;\n        }\n      }]), e;\n    }(),\n        ue = function () {\n      function e(t, n, i, r, o) {\n        var a = this;\n        S(this, e), this.liveSocket = n, this.flash = o, this.parent = i, this.root = i ? i.root : this, this.el = t, this.id = this.el.id, this.view = this.el.getAttribute(R), this.ref = 0, this.childJoins = 0, this.loaderTimer = null, this.pendingDiffs = [], this.href = r, this.joinCount = this.parent ? this.parent.joinCount - 1 : 0, this.joinPending = !0, this.destroyed = !1, this.joinCallback = function () {}, this.stopCallback = function () {}, this.pendingJoinOps = this.parent ? null : [], this.viewHooks = {}, this.children = this.parent ? null : {}, this.root.children[this.id] = {}, this.channel = this.liveSocket.channel(\"lv:\".concat(this.id), function () {\n          return {\n            url: a.href,\n            params: a.connectParams(),\n            session: a.getSession(),\n            static: a.getStatic(),\n            flash: a.flash\n          };\n        }), this.showLoader(this.liveSocket.loaderTimeout), this.bindChannel();\n      }\n\n      return P(e, [{\n        key: \"isMain\",\n        value: function () {\n          return this.liveSocket.main === this;\n        }\n      }, {\n        key: \"connectParams\",\n        value: function () {\n          var e = this.liveSocket.params(this.view),\n              t = re.all(document, \"[\".concat(this.binding(\"track-static\"), \"]\")).map(function (e) {\n            return e.src || e.href;\n          }).filter(function (e) {\n            return \"string\" == typeof e;\n          });\n          return t.length > 0 && (e._track_static = t), e._mounts = this.joinCount, e;\n        }\n      }, {\n        key: \"name\",\n        value: function () {\n          return this.view;\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return this.channel.canPush();\n        }\n      }, {\n        key: \"getSession\",\n        value: function () {\n          return this.el.getAttribute(\"data-phx-session\");\n        }\n      }, {\n        key: \"getStatic\",\n        value: function () {\n          var e = this.el.getAttribute(F);\n          return \"\" === e ? null : e;\n        }\n      }, {\n        key: \"destroy\",\n        value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {};\n          this.destroyAllChildren(), this.destroyed = !0, delete this.root.children[this.id], this.parent && delete this.root.children[this.parent.id][this.id], clearTimeout(this.loaderTimer);\n\n          var n = function () {\n            for (var n in t(), e.viewHooks) e.viewHooks[n].__trigger__(\"beforeDestroy\"), e.destroyHook(e.viewHooks[n]);\n          };\n\n          this.log(\"destroyed\", function () {\n            return [\"the child has been removed from the parent\"];\n          }), this.channel.leave().receive(\"ok\", n).receive(\"error\", n).receive(\"timeout\", n);\n        }\n      }, {\n        key: \"setContainerClasses\",\n        value: function () {\n          var e;\n          this.el.classList.remove(\"phx-connected\", \"phx-disconnected\", \"phx-error\"), (e = this.el.classList).add.apply(e, arguments);\n        }\n      }, {\n        key: \"isLoading\",\n        value: function () {\n          return this.el.classList.contains(\"phx-disconnected\");\n        }\n      }, {\n        key: \"showLoader\",\n        value: function (e) {\n          var t = this;\n          if (clearTimeout(this.loaderTimer), e) this.loaderTimer = setTimeout(function () {\n            return t.showLoader();\n          }, e);else {\n            for (var n in this.viewHooks) this.viewHooks[n].__trigger__(\"disconnected\");\n\n            this.setContainerClasses(\"phx-disconnected\");\n          }\n        }\n      }, {\n        key: \"hideLoader\",\n        value: function () {\n          clearTimeout(this.loaderTimer), this.setContainerClasses(\"phx-connected\");\n        }\n      }, {\n        key: \"triggerReconnected\",\n        value: function () {\n          for (var e in this.viewHooks) this.viewHooks[e].__trigger__(\"reconnected\");\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t) {\n          this.liveSocket.log(this, e, t);\n        }\n      }, {\n        key: \"withinTargets\",\n        value: function (e, t) {\n          var n = this;\n\n          if (/^(0|[1-9]\\d*)$/.test(e)) {\n            var i = re.findComponentNodeList(this.el, e);\n            0 === i.length ? K(\"no component found matching phx-target of \".concat(e)) : t(this, i[0]);\n          } else {\n            var r = Array.from(document.querySelectorAll(e));\n            0 === r.length && K('nothing found matching the phx-target selector \"'.concat(e, '\"')), r.forEach(function (e) {\n              return n.liveSocket.owner(e, function (n) {\n                return t(n, e);\n              });\n            });\n          }\n        }\n      }, {\n        key: \"applyDiff\",\n        value: function (e, t, n) {\n          this.log(e, function () {\n            return [\"\", z(t)];\n          });\n          var i = te.extract(t),\n              r = i.diff,\n              o = i.reply,\n              a = i.events,\n              u = i.title;\n          return u && re.putTitle(u), n({\n            diff: r,\n            reply: o,\n            events: a\n          }), o;\n        }\n      }, {\n        key: \"onJoin\",\n        value: function (e) {\n          var t = this,\n              n = e.rendered;\n          this.joinCount++, this.childJoins = 0, this.joinPending = !0, this.flash = null, ie.dropLocal(this.name(), \"consecutive-reloads\"), this.applyDiff(\"mount\", n, function (n) {\n            var i = n.diff,\n                r = n.events;\n            t.rendered = new te(t.id, i);\n            var o = t.renderContainer(null, \"join\");\n            t.dropPendingRefs();\n            var a = t.formsForRecovery(o);\n            t.joinCount > 1 && a.length > 0 ? a.forEach(function (e, n) {\n              t.pushFormRecovery(e, function (e) {\n                n === a.length - 1 && t.onJoinComplete(e, o, r);\n              });\n            }) : t.onJoinComplete(e, o, r);\n          });\n        }\n      }, {\n        key: \"dropPendingRefs\",\n        value: function () {\n          re.all(this.el, \"[\".concat(M, \"]\"), function (e) {\n            return e.removeAttribute(M);\n          });\n        }\n      }, {\n        key: \"onJoinComplete\",\n        value: function (e, t, n) {\n          var i = this,\n              r = e.live_patch;\n          if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) return this.applyJoinPatch(r, t, n);\n          0 === re.findPhxChildrenInFragment(t, this.id).filter(function (e) {\n            var t = e.id && i.el.querySelector(\"#\".concat(e.id)),\n                n = t && t.getAttribute(F);\n            return n && e.setAttribute(F, n), i.joinChild(e);\n          }).length ? this.parent ? (this.root.pendingJoinOps.push([this, function () {\n            return i.applyJoinPatch(r, t, n);\n          }]), this.parent.ackJoin(this)) : (this.onAllChildJoinsComplete(), this.applyJoinPatch(r, t, n)) : this.root.pendingJoinOps.push([this, function () {\n            return i.applyJoinPatch(r, t, n);\n          }]);\n        }\n      }, {\n        key: \"attachTrueDocEl\",\n        value: function () {\n          this.el = re.byId(this.id), this.el.setAttribute(\"data-phx-root-id\", this.root.id);\n        }\n      }, {\n        key: \"dispatchEvents\",\n        value: function (e) {\n          e.forEach(function (e) {\n            var t = L(e, 2),\n                n = t[0],\n                i = t[1];\n            window.dispatchEvent(new CustomEvent(\"phx:hook:\".concat(n), {\n              detail: i\n            }));\n          });\n        }\n      }, {\n        key: \"applyJoinPatch\",\n        value: function (e, t, n) {\n          var i = this;\n          this.attachTrueDocEl();\n          var r = new ae(this, this.el, this.id, t, null);\n\n          if (r.markPrunableContentForRemoval(), this.performPatch(r, !1), this.joinNewChildren(), re.all(this.el, \"[\".concat(this.binding(\"hook\"), \"]\"), function (e) {\n            var t = i.addHook(e);\n            t && t.__trigger__(\"mounted\");\n          }), this.joinPending = !1, this.dispatchEvents(n), this.applyPendingUpdates(), e) {\n            var o = e.kind,\n                a = e.to;\n            this.liveSocket.historyPatch(a, o);\n          }\n\n          this.hideLoader(), this.joinCount > 1 && this.triggerReconnected(), this.stopCallback();\n        }\n      }, {\n        key: \"triggerBeforeUpdateHook\",\n        value: function (e, t) {\n          this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [e, t]);\n          var n = this.getHook(e),\n              i = n && \"ignore\" === e.getAttribute(this.binding(\"update\"));\n          if (n && !e.isEqualNode(t) && (!i || !function (e, t) {\n            return JSON.stringify(e) === JSON.stringify(t);\n          }(e.dataset, t.dataset))) return n.__trigger__(\"beforeUpdate\"), n;\n        }\n      }, {\n        key: \"triggerUpdatedHook\",\n        value: function (e) {\n          e.__trigger__(\"updated\");\n        }\n      }, {\n        key: \"performPatch\",\n        value: function (e, t) {\n          var n = this,\n              i = [],\n              r = !1,\n              o = new Set();\n          return e.after(\"added\", function (e) {\n            var t = n.addHook(e);\n            t && t.__trigger__(\"mounted\");\n          }), e.after(\"phxChildAdded\", function (e) {\n            return r = !0;\n          }), e.before(\"updated\", function (e, t) {\n            n.triggerBeforeUpdateHook(e, t) && o.add(e.id);\n          }), e.after(\"updated\", function (e) {\n            o.has(e.id) && n.triggerUpdatedHook(n.getHook(e));\n          }), e.before(\"discarded\", function (e) {\n            var t = n.getHook(e);\n            t && t.__trigger__(\"beforeDestroy\");\n          }), e.after(\"discarded\", function (e) {\n            var t = n.componentID(e);\n            \"number\" == typeof t && -1 === i.indexOf(t) && i.push(t);\n            var r = n.getHook(e);\n            r && n.destroyHook(r);\n          }), e.perform(), t && this.maybePushComponentsDestroyed(i), r;\n        }\n      }, {\n        key: \"joinNewChildren\",\n        value: function () {\n          var e = this;\n          re.findPhxChildren(this.el, this.id).forEach(function (t) {\n            return e.joinChild(t);\n          });\n        }\n      }, {\n        key: \"getChildById\",\n        value: function (e) {\n          return this.root.children[this.id][e];\n        }\n      }, {\n        key: \"getDescendentByEl\",\n        value: function (e) {\n          return e.id === this.id ? this : this.children[e.getAttribute(\"data-phx-parent-id\")][e.id];\n        }\n      }, {\n        key: \"destroyDescendent\",\n        value: function (e) {\n          for (var t in this.root.children) for (var n in this.root.children[t]) if (n === e) return this.root.children[t][n].destroy();\n        }\n      }, {\n        key: \"joinChild\",\n        value: function (t) {\n          if (!this.getChildById(t.id)) {\n            var n = new e(t, this.liveSocket, this);\n            return this.root.children[this.id][n.id] = n, n.join(), this.childJoins++, !0;\n          }\n        }\n      }, {\n        key: \"isJoinPending\",\n        value: function () {\n          return this.joinPending;\n        }\n      }, {\n        key: \"ackJoin\",\n        value: function (e) {\n          this.childJoins--, 0 === this.childJoins && (this.parent ? this.parent.ackJoin(this) : this.onAllChildJoinsComplete());\n        }\n      }, {\n        key: \"onAllChildJoinsComplete\",\n        value: function () {\n          this.joinCallback(), this.pendingJoinOps.forEach(function (e) {\n            var t = L(e, 2),\n                n = t[0],\n                i = t[1];\n            n.isDestroyed() || i();\n          }), this.pendingJoinOps = [];\n        }\n      }, {\n        key: \"update\",\n        value: function (e, t) {\n          var n = this;\n          if (this.isJoinPending() || this.liveSocket.hasPendingLink()) return this.pendingDiffs.push({\n            diff: e,\n            events: t\n          });\n          this.rendered.mergeDiff(e);\n          var i = !1;\n          this.rendered.isComponentOnlyDiff(e) ? this.liveSocket.time(\"component patch complete\", function () {\n            re.findParentCIDs(n.el, n.rendered.componentCIDs(e)).forEach(function (t) {\n              n.componentPatch(n.rendered.getComponent(e, t), t) && (i = !0);\n            });\n          }) : Q(e) || this.liveSocket.time(\"full patch complete\", function () {\n            var t = n.renderContainer(e, \"update\"),\n                r = new ae(n, n.el, n.id, t, null);\n            i = n.performPatch(r, !0);\n          }), this.dispatchEvents(t), i && this.joinNewChildren();\n        }\n      }, {\n        key: \"renderContainer\",\n        value: function (e, t) {\n          var n = this;\n          return this.liveSocket.time(\"toString diff (\".concat(t, \")\"), function () {\n            var t = n.el.tagName,\n                i = e ? n.rendered.componentCIDs(e) : null,\n                r = n.rendered.toString(i);\n            return \"<\".concat(t, \">\").concat(r, \"</\").concat(t, \">\");\n          });\n        }\n      }, {\n        key: \"componentPatch\",\n        value: function (e, t) {\n          if (Q(e)) return !1;\n          var n = this.rendered.componentToString(t),\n              i = new ae(this, this.el, this.id, n, t);\n          return this.performPatch(i, !0);\n        }\n      }, {\n        key: \"getHook\",\n        value: function (e) {\n          return this.viewHooks[se.elementID(e)];\n        }\n      }, {\n        key: \"addHook\",\n        value: function (e) {\n          if (!se.elementID(e) && e.getAttribute) {\n            var t = e.getAttribute(this.binding(\"hook\"));\n\n            if (!t || this.ownsElement(e)) {\n              var n = this.liveSocket.getHookCallbacks(t);\n\n              if (n) {\n                e.id || K('no DOM ID for hook \"'.concat(t, '\". Hooks require a unique ID on each element.'), e);\n                var i = new se(this, e, n);\n                return this.viewHooks[se.elementID(i.el)] = i, i;\n              }\n\n              null !== t && K('unknown hook found for \"'.concat(t, '\"'), e);\n            }\n          }\n        }\n      }, {\n        key: \"destroyHook\",\n        value: function (e) {\n          e.__trigger__(\"destroyed\"), e.__cleanup__(), delete this.viewHooks[se.elementID(e.el)];\n        }\n      }, {\n        key: \"applyPendingUpdates\",\n        value: function () {\n          var e = this;\n          this.pendingDiffs.forEach(function (t) {\n            var n = t.diff,\n                i = t.events;\n            return e.update(n, i);\n          }), this.pendingDiffs = [];\n        }\n      }, {\n        key: \"onChannel\",\n        value: function (e, t) {\n          var n = this;\n          this.liveSocket.onChannel(this.channel, e, function (e) {\n            n.isJoinPending() ? n.root.pendingJoinOps.push([n, function () {\n              return t(e);\n            }]) : t(e);\n          });\n        }\n      }, {\n        key: \"bindChannel\",\n        value: function () {\n          var e = this;\n          this.liveSocket.onChannel(this.channel, \"diff\", function (t) {\n            e.applyDiff(\"update\", t, function (t) {\n              var n = t.diff,\n                  i = t.events;\n              return e.update(n, i);\n            });\n          }), this.onChannel(\"redirect\", function (t) {\n            var n = t.to,\n                i = t.flash;\n            return e.onRedirect({\n              to: n,\n              flash: i\n            });\n          }), this.onChannel(\"live_patch\", function (t) {\n            return e.onLivePatch(t);\n          }), this.onChannel(\"live_redirect\", function (t) {\n            return e.onLiveRedirect(t);\n          }), this.channel.onError(function (t) {\n            return e.onError(t);\n          }), this.channel.onClose(function () {\n            return e.onClose();\n          });\n        }\n      }, {\n        key: \"destroyAllChildren\",\n        value: function () {\n          for (var e in this.root.children[this.id]) this.getChildById(e).destroy();\n        }\n      }, {\n        key: \"onLiveRedirect\",\n        value: function (e) {\n          var t = e.to,\n              n = e.kind,\n              i = e.flash,\n              r = this.expandURL(t);\n          this.liveSocket.historyRedirect(r, n, i);\n        }\n      }, {\n        key: \"onLivePatch\",\n        value: function (e) {\n          var t = e.to,\n              n = e.kind;\n          this.href = this.expandURL(t), this.liveSocket.historyPatch(t, n);\n        }\n      }, {\n        key: \"expandURL\",\n        value: function (e) {\n          return e.startsWith(\"/\") ? \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(e) : e;\n        }\n      }, {\n        key: \"onRedirect\",\n        value: function (e) {\n          var t = e.to,\n              n = e.flash;\n          this.liveSocket.redirect(t, n);\n        }\n      }, {\n        key: \"isDestroyed\",\n        value: function () {\n          return this.destroyed;\n        }\n      }, {\n        key: \"join\",\n        value: function (e) {\n          var t = this;\n          this.parent || (this.stopCallback = this.liveSocket.withPageLoading({\n            to: this.href,\n            kind: \"initial\"\n          })), this.joinCallback = function () {\n            return e && e(t, t.joinCount);\n          }, this.liveSocket.wrapPush(function () {\n            return t.channel.join().receive(\"ok\", function (e) {\n              return t.onJoin(e);\n            }).receive(\"error\", function (e) {\n              return t.onJoinError(e);\n            }).receive(\"timeout\", function () {\n              return t.onJoinError({\n                reason: \"timeout\"\n              });\n            });\n          });\n        }\n      }, {\n        key: \"onJoinError\",\n        value: function (e) {\n          return (e.redirect || e.live_redirect) && (this.joinPending = !1, this.channel.leave()), e.redirect ? this.onRedirect(e.redirect) : e.live_redirect ? this.onLiveRedirect(e.live_redirect) : (this.log(\"error\", function () {\n            return [\"unable to join\", e];\n          }), this.liveSocket.reloadWithJitter(this));\n        }\n      }, {\n        key: \"onClose\",\n        value: function () {\n          if (!this.isDestroyed()) {\n            if (this.isJoinPending() || this.liveSocket.hasPendingLink()) return this.liveSocket.reloadWithJitter(this);\n            this.destroyAllChildren(), this.liveSocket.dropActiveElement(this), document.activeElement && document.activeElement.blur(), this.liveSocket.isUnloaded() && this.showLoader(200);\n          }\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          this.onClose(), this.log(\"error\", function () {\n            return [\"view crashed\", e];\n          }), this.liveSocket.isUnloaded() || this.displayError();\n        }\n      }, {\n        key: \"displayError\",\n        value: function () {\n          this.isMain() && re.dispatchEvent(window, \"phx:page-loading-start\", {\n            to: this.href,\n            kind: \"error\"\n          }), this.showLoader(), this.setContainerClasses(\"phx-disconnected\", \"phx-error\");\n        }\n      }, {\n        key: \"pushWithReply\",\n        value: function (e, t, n) {\n          var i = this,\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {},\n              o = L(e ? e() : [null, []], 2),\n              a = o[0],\n              u = L(o[1], 1)[0],\n              c = function () {};\n\n          return u && null !== u.getAttribute(this.binding(\"page-loading\")) && (c = this.liveSocket.withPageLoading({\n            kind: \"element\",\n            target: u\n          })), \"number\" != typeof n.cid && delete n.cid, this.liveSocket.wrapPush(function () {\n            return i.channel.push(t, n, 3e4).receive(\"ok\", function (e) {\n              var t = null;\n              null !== a && i.undoRefs(a), e.diff && (t = i.applyDiff(\"update\", e.diff, function (e) {\n                var t = e.diff,\n                    n = e.events;\n                i.update(t, n);\n              })), e.redirect && i.onRedirect(e.redirect), e.live_patch && i.onLivePatch(e.live_patch), e.live_redirect && i.onLiveRedirect(e.live_redirect), c(), r(e, t);\n            });\n          });\n        }\n      }, {\n        key: \"undoRefs\",\n        value: function (e) {\n          var t = this;\n          re.all(this.el, \"[\".concat(M, '=\"').concat(e, '\"]'), function (e) {\n            e.removeAttribute(M), null !== e.getAttribute(\"data-phx-readonly\") && (e.readOnly = !1, e.removeAttribute(\"data-phx-readonly\")), null !== e.getAttribute(\"data-phx-disabled\") && (e.disabled = !1, e.removeAttribute(\"data-phx-disabled\")), H.forEach(function (t) {\n              return re.removeClass(e, t);\n            });\n            var n = e.getAttribute(\"data-phx-disable-with-restore\");\n            null !== n && (e.innerText = n, e.removeAttribute(\"data-phx-disable-with-restore\"));\n            var i = re.private(e, M);\n\n            if (i) {\n              var r = t.triggerBeforeUpdateHook(e, i);\n              ae.patchEl(e, i, t.liveSocket.getActiveElement()), r && t.triggerUpdatedHook(r), re.deletePrivate(e, M);\n            }\n          });\n        }\n      }, {\n        key: \"putRef\",\n        value: function (e, t) {\n          var n = this.ref++,\n              i = this.binding(\"disable-with\");\n          return e.forEach(function (e) {\n            e.classList.add(\"phx-\".concat(t, \"-loading\")), e.setAttribute(M, n);\n            var r = e.getAttribute(i);\n            null !== r && (e.getAttribute(\"data-phx-disable-with-restore\") || e.setAttribute(\"data-phx-disable-with-restore\", e.innerText), e.innerText = r);\n          }), [n, e];\n        }\n      }, {\n        key: \"componentID\",\n        value: function (e) {\n          var t = e.getAttribute && e.getAttribute(j);\n          return t ? parseInt(t) : null;\n        }\n      }, {\n        key: \"targetComponentID\",\n        value: function (e, t) {\n          return e.getAttribute(this.binding(\"target\")) ? this.closestComponentID(t) : null;\n        }\n      }, {\n        key: \"closestComponentID\",\n        value: function (e) {\n          var t = this;\n          return e ? Z(e.closest(\"[\".concat(j, \"]\")), function (e) {\n            return t.ownsElement(e) && t.componentID(e);\n          }) : null;\n        }\n      }, {\n        key: \"pushHookEvent\",\n        value: function (e, t, n, i) {\n          var r = L(this.putRef([], \"hook\"), 2),\n              o = r[0],\n              a = r[1];\n          return this.pushWithReply(function () {\n            return [o, a];\n          }, \"event\", {\n            type: \"hook\",\n            event: t,\n            value: n,\n            cid: this.closestComponentID(e)\n          }, function (e, t) {\n            return i(t, o);\n          }), o;\n        }\n      }, {\n        key: \"extractMeta\",\n        value: function (e, t) {\n          for (var n = this.binding(\"value-\"), i = 0; i < e.attributes.length; i++) {\n            var r = e.attributes[i].name;\n            r.startsWith(n) && (t[r.replace(n, \"\")] = e.getAttribute(r));\n          }\n\n          return void 0 !== e.value && (t.value = e.value, \"INPUT\" === e.tagName && J.indexOf(e.type) >= 0 && !e.checked && delete t.value), t;\n        }\n      }, {\n        key: \"pushEvent\",\n        value: function (e, t, n, i, r) {\n          var o = this;\n          this.pushWithReply(function () {\n            return o.putRef([t], e);\n          }, \"event\", {\n            type: e,\n            event: i,\n            value: this.extractMeta(t, r),\n            cid: this.targetComponentID(t, n)\n          });\n        }\n      }, {\n        key: \"pushKey\",\n        value: function (e, t, n, i, r) {\n          var o = this;\n          this.pushWithReply(function () {\n            return o.putRef([e], n);\n          }, \"event\", {\n            type: n,\n            event: i,\n            value: this.extractMeta(e, r),\n            cid: this.targetComponentID(e, t)\n          });\n        }\n      }, {\n        key: \"pushInput\",\n        value: function (e, t, n, i, r) {\n          var o = this;\n          this.pushWithReply(function () {\n            return o.putRef([e, e.form], \"change\");\n          }, \"event\", {\n            type: \"form\",\n            event: n,\n            value: ee(e.form, {\n              _target: i.name\n            }),\n            cid: this.targetComponentID(e.form, t)\n          }, r);\n        }\n      }, {\n        key: \"pushFormSubmit\",\n        value: function (e, t, n, i) {\n          var r = this,\n              o = function (e) {\n            return !G(e, \"\".concat(r.binding(\"update\"), \"=ignore\"), e.form);\n          };\n\n          this.pushWithReply(function () {\n            var t = re.all(e, \"[\".concat(r.binding(\"disable-with\"), \"]\")),\n                n = re.all(e, \"button\").filter(o),\n                i = re.all(e, \"input,textarea,select\").filter(o);\n            return n.forEach(function (e) {\n              e.setAttribute(\"data-phx-disabled\", e.disabled), e.disabled = !0;\n            }), i.forEach(function (e) {\n              e.setAttribute(\"data-phx-readonly\", e.readOnly), e.readOnly = !0;\n            }), e.setAttribute(r.binding(\"page-loading\"), \"\"), r.putRef([e].concat(t).concat(n).concat(i), \"submit\");\n          }, \"event\", {\n            type: \"form\",\n            event: n,\n            value: ee(e),\n            cid: this.targetComponentID(e, t)\n          }, i);\n        }\n      }, {\n        key: \"pushFormRecovery\",\n        value: function (e, t) {\n          var n = this;\n          this.liveSocket.withinOwners(e, function (i, r) {\n            var o = e.elements[0],\n                a = e.getAttribute(n.binding(\"auto-recover\")) || e.getAttribute(n.binding(\"change\"));\n            i.pushInput(o, r, a, o, t);\n          });\n        }\n      }, {\n        key: \"pushLinkPatch\",\n        value: function (e, t, n) {\n          var i = this,\n              r = this.liveSocket.setPendingLink(e),\n              o = t ? function () {\n            return i.putRef([t], \"click\");\n          } : null;\n          this.pushWithReply(o, \"link\", {\n            url: e\n          }, function (t) {\n            t.link_redirect ? i.liveSocket.replaceMain(e, null, n, r) : i.liveSocket.commitPendingLink(r) && (i.href = e, i.applyPendingUpdates(), n && n());\n          }).receive(\"timeout\", function () {\n            return i.liveSocket.redirect(window.location.href);\n          });\n        }\n      }, {\n        key: \"formsForRecovery\",\n        value: function (e) {\n          var t = this,\n              n = this.binding(\"change\"),\n              i = document.createElement(\"template\");\n          return i.innerHTML = e, re.all(this.el, \"form[\".concat(n, \"]\")).filter(function (e) {\n            return t.ownsElement(e);\n          }).filter(function (e) {\n            return \"ignore\" !== e.getAttribute(t.binding(\"auto-recover\"));\n          }).filter(function (e) {\n            return i.content.querySelector(\"form[\".concat(n, '=\"').concat(e.getAttribute(n), '\"]'));\n          });\n        }\n      }, {\n        key: \"maybePushComponentsDestroyed\",\n        value: function (e) {\n          var t = this,\n              n = e.filter(function (e) {\n            return 0 === re.findComponentNodeList(t.el, e).length;\n          });\n          n.length > 0 && this.pushWithReply(null, \"cids_destroyed\", {\n            cids: n\n          }, function () {\n            t.rendered.pruneCIDs(n);\n          });\n        }\n      }, {\n        key: \"ownsElement\",\n        value: function (e) {\n          return e.getAttribute(\"data-phx-parent-id\") === this.id || Z(e.closest(B), function (e) {\n            return e.id;\n          }) === this.id;\n        }\n      }, {\n        key: \"submitForm\",\n        value: function (e, t, n) {\n          var i = this;\n          re.putPrivate(e, \"phx-has-submitted\", !0), this.liveSocket.blurActiveElement(this), this.pushFormSubmit(e, t, n, function () {\n            i.liveSocket.restorePreviouslyActiveFocus();\n          });\n        }\n      }, {\n        key: \"binding\",\n        value: function (e) {\n          return this.liveSocket.binding(e);\n        }\n      }]), e;\n    }(),\n        ce = 1,\n        se = function () {\n      function e(t, n, i) {\n        for (var r in S(this, e), this.__view = t, this.__liveSocket = t.liveSocket, this.__callbacks = i, this.__listeners = new Set(), this.el = n, this.viewName = t.name(), this.el.phxHookId = this.constructor.makeID(), this.__callbacks) this[r] = this.__callbacks[r];\n      }\n\n      return P(e, null, [{\n        key: \"makeID\",\n        value: function () {\n          return ce++;\n        }\n      }, {\n        key: \"elementID\",\n        value: function (e) {\n          return e.phxHookId;\n        }\n      }]), P(e, [{\n        key: \"pushEvent\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {};\n          return this.__view.pushHookEvent(null, e, t, n);\n        }\n      }, {\n        key: \"pushEventTo\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n              i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {};\n          return this.__view.withinTargets(e, function (e, r) {\n            return e.pushHookEvent(r, t, n, i);\n          });\n        }\n      }, {\n        key: \"handleEvent\",\n        value: function (e, t) {\n          var n = function (n, i) {\n            return i ? e : t(n.detail);\n          };\n\n          return window.addEventListener(\"phx:hook:\".concat(e), n), this.__listeners.add(n), n;\n        }\n      }, {\n        key: \"removeHandleEvent\",\n        value: function (e) {\n          var t = e(null, !0);\n          window.removeEventListener(\"phx:hook:\".concat(t), e), this.__listeners.delete(e);\n        }\n      }, {\n        key: \"__cleanup__\",\n        value: function () {\n          var e = this;\n\n          this.__listeners.forEach(function (t) {\n            return e.removeHandleEvent(t);\n          });\n        }\n      }, {\n        key: \"__trigger__\",\n        value: function (e) {\n          var t = this.__callbacks[e];\n          t && t.call(this);\n        }\n      }]), e;\n    }();\n\n    t.default = ne;\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || Function(\"return this\")() || (0, eval)(\"this\");\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    (function (t) {\n      t.Phoenix || (t.Phoenix = {}), e.exports = t.Phoenix.LiveView = n(0);\n    }).call(this, n(1));\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9wcml2L3N0YXRpYy9waG9lbml4X2xpdmVfdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L3ByaXYvc3RhdGljL3Bob2VuaXhfbGl2ZV92aWV3LmpzPzJjOTAiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5waG9lbml4X2xpdmVfdmlldz10KCk6ZS5waG9lbml4X2xpdmVfdmlldz10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gbihpKXtpZih0W2ldKXJldHVybiB0W2ldLmV4cG9ydHM7dmFyIHI9dFtpXT17aTppLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbaV0uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsbiksci5sPSEwLHIuZXhwb3J0c31yZXR1cm4gbi5tPWUsbi5jPXQsbi5kPWZ1bmN0aW9uKGUsdCxpKXtuLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Oml9KX0sbi5yPWZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LFwiYVwiLHQpLHR9LG4ubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sbi5wPVwiXCIsbihuLnM9Mil9KFtmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7bi5yKHQpO3ZhciBpLHI9MTE7dmFyIG89XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsYT1cInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQ/dm9pZCAwOmRvY3VtZW50LHU9ISFhJiZcImNvbnRlbnRcImluIGEuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpLGM9ISFhJiZhLmNyZWF0ZVJhbmdlJiZcImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFwiaW4gYS5jcmVhdGVSYW5nZSgpO2Z1bmN0aW9uIHMoZSl7cmV0dXJuIGU9ZS50cmltKCksdT9mdW5jdGlvbihlKXt2YXIgdD1hLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtyZXR1cm4gdC5pbm5lckhUTUw9ZSx0LmNvbnRlbnQuY2hpbGROb2Rlc1swXX0oZSk6Yz9mdW5jdGlvbihlKXtyZXR1cm4gaXx8KGk9YS5jcmVhdGVSYW5nZSgpKS5zZWxlY3ROb2RlKGEuYm9keSksaS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoZSkuY2hpbGROb2Rlc1swXX0oZSk6ZnVuY3Rpb24oZSl7dmFyIHQ9YS5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtyZXR1cm4gdC5pbm5lckhUTUw9ZSx0LmNoaWxkTm9kZXNbMF19KGUpfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbixpLHI9ZS5ub2RlTmFtZSxvPXQubm9kZU5hbWU7cmV0dXJuIHI9PT1vfHwobj1yLmNoYXJDb2RlQXQoMCksaT1vLmNoYXJDb2RlQXQoMCksbjw9OTAmJmk+PTk3P3I9PT1vLnRvVXBwZXJDYXNlKCk6aTw9OTAmJm4+PTk3JiZvPT09ci50b1VwcGVyQ2FzZSgpKX1mdW5jdGlvbiBkKGUsdCxuKXtlW25dIT09dFtuXSYmKGVbbl09dFtuXSxlW25dP2Uuc2V0QXR0cmlidXRlKG4sXCJcIik6ZS5yZW1vdmVBdHRyaWJ1dGUobikpfXZhciBoPXtPUFRJT046ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLnBhcmVudE5vZGU7aWYobil7dmFyIGk9bi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1wiT1BUR1JPVVBcIj09PWkmJihpPShuPW4ucGFyZW50Tm9kZSkmJm4ubm9kZU5hbWUudG9VcHBlckNhc2UoKSksXCJTRUxFQ1RcIiE9PWl8fG4uaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIil8fChlLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpJiYhdC5zZWxlY3RlZCYmKGUuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIixcInNlbGVjdGVkXCIpLGUucmVtb3ZlQXR0cmlidXRlKFwic2VsZWN0ZWRcIikpLG4uc2VsZWN0ZWRJbmRleD0tMSl9ZChlLHQsXCJzZWxlY3RlZFwiKX0sSU5QVVQ6ZnVuY3Rpb24oZSx0KXtkKGUsdCxcImNoZWNrZWRcIiksZChlLHQsXCJkaXNhYmxlZFwiKSxlLnZhbHVlIT09dC52YWx1ZSYmKGUudmFsdWU9dC52YWx1ZSksdC5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKXx8ZS5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKX0sVEVYVEFSRUE6ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnZhbHVlO2UudmFsdWUhPT1uJiYoZS52YWx1ZT1uKTt2YXIgaT1lLmZpcnN0Q2hpbGQ7aWYoaSl7dmFyIHI9aS5ub2RlVmFsdWU7aWYocj09bnx8IW4mJnI9PWUucGxhY2Vob2xkZXIpcmV0dXJuO2kubm9kZVZhbHVlPW59fSxTRUxFQ1Q6ZnVuY3Rpb24oZSx0KXtpZighdC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSl7Zm9yKHZhciBuLGkscj0tMSxvPTAsYT1lLmZpcnN0Q2hpbGQ7YTspaWYoXCJPUFRHUk9VUFwiPT09KGk9YS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpKSlhPShuPWEpLmZpcnN0Q2hpbGQ7ZWxzZXtpZihcIk9QVElPTlwiPT09aSl7aWYoYS5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSl7cj1vO2JyZWFrfW8rK30hKGE9YS5uZXh0U2libGluZykmJm4mJihhPW4ubmV4dFNpYmxpbmcsbj1udWxsKX1lLnNlbGVjdGVkSW5kZXg9cn19fSxmPTEsdj0xMSxwPTMsZz04O2Z1bmN0aW9uIG0oKXt9ZnVuY3Rpb24geShlKXtpZihlKXJldHVybiBlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKXx8ZS5pZH12YXIgYj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxuLGkpe2lmKGl8fChpPXt9KSxcInN0cmluZ1wiPT10eXBlb2YgbilpZihcIiNkb2N1bWVudFwiPT09dC5ub2RlTmFtZXx8XCJIVE1MXCI9PT10Lm5vZGVOYW1lfHxcIkJPRFlcIj09PXQubm9kZU5hbWUpe3ZhciByPW47KG49YS5jcmVhdGVFbGVtZW50KFwiaHRtbFwiKSkuaW5uZXJIVE1MPXJ9ZWxzZSBuPXMobik7dmFyIHU9aS5nZXROb2RlS2V5fHx5LGM9aS5vbkJlZm9yZU5vZGVBZGRlZHx8bSxkPWkub25Ob2RlQWRkZWR8fG0sYj1pLm9uQmVmb3JlRWxVcGRhdGVkfHxtLGs9aS5vbkVsVXBkYXRlZHx8bSx3PWkub25CZWZvcmVOb2RlRGlzY2FyZGVkfHxtLEU9aS5vbk5vZGVEaXNjYXJkZWR8fG0seD1pLm9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWR8fG0sQT0hMD09PWkuY2hpbGRyZW5Pbmx5LFM9T2JqZWN0LmNyZWF0ZShudWxsKSxDPVtdO2Z1bmN0aW9uIFAoZSl7Qy5wdXNoKGUpfWZ1bmN0aW9uIEwoZSx0LG4peyExIT09dyhlKSYmKHQmJnQucmVtb3ZlQ2hpbGQoZSksRShlKSxmdW5jdGlvbiBlKHQsbil7aWYodC5ub2RlVHlwZT09PWYpZm9yKHZhciBpPXQuZmlyc3RDaGlsZDtpOyl7dmFyIHI9dm9pZCAwO24mJihyPXUoaSkpP1Aocik6KEUoaSksaS5maXJzdENoaWxkJiZlKGksbikpLGk9aS5uZXh0U2libGluZ319KGUsbikpfWZ1bmN0aW9uIFQoZSl7ZChlKTtmb3IodmFyIHQ9ZS5maXJzdENoaWxkO3Q7KXt2YXIgbj10Lm5leHRTaWJsaW5nLGk9dSh0KTtpZihpKXt2YXIgcj1TW2ldO3ImJmwodCxyKT8odC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyLHQpLEkocix0KSk6VCh0KX1lbHNlIFQodCk7dD1ufX1mdW5jdGlvbiBJKHQsbixpKXt2YXIgcj11KG4pO2lmKHImJmRlbGV0ZSBTW3JdLCFpKXtpZighMT09PWIodCxuKSlyZXR1cm47aWYoZSh0LG4pLGsodCksITE9PT14KHQsbikpcmV0dXJufVwiVEVYVEFSRUFcIiE9PXQubm9kZU5hbWU/ZnVuY3Rpb24oZSx0KXt2YXIgbixpLHIsbyxzLGQ9dC5maXJzdENoaWxkLHY9ZS5maXJzdENoaWxkO2U6Zm9yKDtkOyl7Zm9yKG89ZC5uZXh0U2libGluZyxuPXUoZCk7djspe2lmKHI9di5uZXh0U2libGluZyxkLmlzU2FtZU5vZGUmJmQuaXNTYW1lTm9kZSh2KSl7ZD1vLHY9cjtjb250aW51ZSBlfWk9dSh2KTt2YXIgbT12Lm5vZGVUeXBlLHk9dm9pZCAwO2lmKG09PT1kLm5vZGVUeXBlJiYobT09PWY/KG4/biE9PWkmJigocz1TW25dKT9yPT09cz95PSExOihlLmluc2VydEJlZm9yZShzLHYpLGk/UChpKTpMKHYsZSwhMCksdj1zKTp5PSExKTppJiYoeT0hMSksKHk9ITEhPT15JiZsKHYsZCkpJiZJKHYsZCkpOm0hPT1wJiZtIT1nfHwoeT0hMCx2Lm5vZGVWYWx1ZSE9PWQubm9kZVZhbHVlJiYodi5ub2RlVmFsdWU9ZC5ub2RlVmFsdWUpKSkseSl7ZD1vLHY9cjtjb250aW51ZSBlfWk/UChpKTpMKHYsZSwhMCksdj1yfWlmKG4mJihzPVNbbl0pJiZsKHMsZCkpZS5hcHBlbmRDaGlsZChzKSxJKHMsZCk7ZWxzZXt2YXIgYj1jKGQpOyExIT09YiYmKGImJihkPWIpLGQuYWN0dWFsaXplJiYoZD1kLmFjdHVhbGl6ZShlLm93bmVyRG9jdW1lbnR8fGEpKSxlLmFwcGVuZENoaWxkKGQpLFQoZCkpfWQ9byx2PXJ9IWZ1bmN0aW9uKGUsdCxuKXtmb3IoO3Q7KXt2YXIgaT10Lm5leHRTaWJsaW5nOyhuPXUodCkpP1Aobik6TCh0LGUsITApLHQ9aX19KGUsdixpKTt2YXIgaz1oW2Uubm9kZU5hbWVdO2smJmsoZSx0KX0odCxuKTpoLlRFWFRBUkVBKHQsbil9IWZ1bmN0aW9uIGUodCl7aWYodC5ub2RlVHlwZT09PWZ8fHQubm9kZVR5cGU9PT12KWZvcih2YXIgbj10LmZpcnN0Q2hpbGQ7bjspe3ZhciBpPXUobik7aSYmKFNbaV09biksZShuKSxuPW4ubmV4dFNpYmxpbmd9fSh0KTt2YXIgRD10LE49RC5ub2RlVHlwZSxfPW4ubm9kZVR5cGU7aWYoIUEpaWYoTj09PWYpXz09PWY/bCh0LG4pfHwoRSh0KSxEPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPWUuZmlyc3RDaGlsZDtuOyl7dmFyIGk9bi5uZXh0U2libGluZzt0LmFwcGVuZENoaWxkKG4pLG49aX1yZXR1cm4gdH0odCxmdW5jdGlvbihlLHQpe3JldHVybiB0JiZ0IT09bz9hLmNyZWF0ZUVsZW1lbnROUyh0LGUpOmEuY3JlYXRlRWxlbWVudChlKX0obi5ub2RlTmFtZSxuLm5hbWVzcGFjZVVSSSkpKTpEPW47ZWxzZSBpZihOPT09cHx8Tj09PWcpe2lmKF89PT1OKXJldHVybiBELm5vZGVWYWx1ZSE9PW4ubm9kZVZhbHVlJiYoRC5ub2RlVmFsdWU9bi5ub2RlVmFsdWUpLEQ7RD1ufWlmKEQ9PT1uKUUodCk7ZWxzZXtpZihuLmlzU2FtZU5vZGUmJm4uaXNTYW1lTm9kZShEKSlyZXR1cm47aWYoSShELG4sQSksQylmb3IodmFyIE89MCxSPUMubGVuZ3RoO088UjtPKyspe3ZhciBIPVNbQ1tPXV07SCYmTChILEgucGFyZW50Tm9kZSwhMSl9fXJldHVybiFBJiZEIT09dCYmdC5wYXJlbnROb2RlJiYoRC5hY3R1YWxpemUmJihEPUQuYWN0dWFsaXplKHQub3duZXJEb2N1bWVudHx8YSkpLHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoRCx0KSksRH19KGZ1bmN0aW9uKGUsdCl7dmFyIG4saSxvLGEsdT10LmF0dHJpYnV0ZXM7aWYodC5ub2RlVHlwZSE9PXImJmUubm9kZVR5cGUhPT1yKXtmb3IodmFyIGM9dS5sZW5ndGgtMTtjPj0wO2MtLSlpPShuPXVbY10pLm5hbWUsbz1uLm5hbWVzcGFjZVVSSSxhPW4udmFsdWUsbz8oaT1uLmxvY2FsTmFtZXx8aSxlLmdldEF0dHJpYnV0ZU5TKG8saSkhPT1hJiYoXCJ4bWxuc1wiPT09bi5wcmVmaXgmJihpPW4ubmFtZSksZS5zZXRBdHRyaWJ1dGVOUyhvLGksYSkpKTplLmdldEF0dHJpYnV0ZShpKSE9PWEmJmUuc2V0QXR0cmlidXRlKGksYSk7Zm9yKHZhciBzPWUuYXR0cmlidXRlcyxsPXMubGVuZ3RoLTE7bD49MDtsLS0paT0obj1zW2xdKS5uYW1lLChvPW4ubmFtZXNwYWNlVVJJKT8oaT1uLmxvY2FsTmFtZXx8aSx0Lmhhc0F0dHJpYnV0ZU5TKG8saSl8fGUucmVtb3ZlQXR0cmlidXRlTlMobyxpKSk6dC5oYXNBdHRyaWJ1dGUoaSl8fGUucmVtb3ZlQXR0cmlidXRlKGkpfX0pO2Z1bmN0aW9uIGsoZSl7cmV0dXJuIEkoZSl8fEEoZSl8fEQoZSl8fFQoKX1mdW5jdGlvbiB3KGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYoaT1pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSksbi5wdXNoLmFwcGx5KG4saSl9cmV0dXJuIG59ZnVuY3Rpb24gRShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24geChlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gTihlKX0oZSl8fEEoZSl8fEQoZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gQShlKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfWZ1bmN0aW9uIFMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIEMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaS5rZXksaSl9fWZ1bmN0aW9uIFAoZSx0LG4pe3JldHVybiB0JiZDKGUucHJvdG90eXBlLHQpLG4mJkMoZSxuKSxlfWZ1bmN0aW9uIEwoZSx0KXtyZXR1cm4gSShlKXx8ZnVuY3Rpb24oZSx0KXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU3ltYm9sfHwhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpKXJldHVybjt2YXIgbj1bXSxpPSEwLHI9ITEsbz12b2lkIDA7dHJ5e2Zvcih2YXIgYSx1PWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEoaT0oYT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goYS52YWx1ZSksIXR8fG4ubGVuZ3RoIT09dCk7aT0hMCk7fWNhdGNoKGUpe3I9ITAsbz1lfWZpbmFsbHl7dHJ5e2l8fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYocil0aHJvdyBvfX1yZXR1cm4gbn0oZSx0KXx8RChlLHQpfHxUKCl9ZnVuY3Rpb24gVCgpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9ZnVuY3Rpb24gSShlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfWZ1bmN0aW9uIEQoZSx0KXtpZihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gTihlLHQpO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4/QXJyYXkuZnJvbShlKTpcIkFyZ3VtZW50c1wiPT09bnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qobik/TihlLHQpOnZvaWQgMH19ZnVuY3Rpb24gTihlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgbj0wLGk9bmV3IEFycmF5KHQpO248dDtuKyspaVtuXT1lW25dO3JldHVybiBpfWZ1bmN0aW9uIF8oZSl7XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO3JldHVybihfPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1uLmQodCxcImRlYnVnXCIsZnVuY3Rpb24oKXtyZXR1cm4gJH0pLG4uZCh0LFwiUmVuZGVyZWRcIixmdW5jdGlvbigpe3JldHVybiB0ZX0pLG4uZCh0LFwiTGl2ZVNvY2tldFwiLGZ1bmN0aW9uKCl7cmV0dXJuIG5lfSksbi5kKHQsXCJCcm93c2VyXCIsZnVuY3Rpb24oKXtyZXR1cm4gaWV9KSxuLmQodCxcIkRPTVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHJlfSksbi5kKHQsXCJWaWV3XCIsZnVuY3Rpb24oKXtyZXR1cm4gdWV9KTt2YXIgTz1bMWUzLDNlM10sUj1cImRhdGEtcGh4LXZpZXdcIixIPVtcInBoeC1jbGljay1sb2FkaW5nXCIsXCJwaHgtY2hhbmdlLWxvYWRpbmdcIixcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFwicGh4LWtleWRvd24tbG9hZGluZ1wiLFwicGh4LWtleXVwLWxvYWRpbmdcIixcInBoeC1ibHVyLWxvYWRpbmdcIixcInBoeC1mb2N1cy1sb2FkaW5nXCJdLGo9XCJkYXRhLXBoeC1jb21wb25lbnRcIixNPVwiZGF0YS1waHgtcmVmXCIsQj1cIltcIi5jb25jYXQoUixcIl1cIiksVT1bXCJ0ZXh0XCIsXCJ0ZXh0YXJlYVwiLFwibnVtYmVyXCIsXCJlbWFpbFwiLFwicGFzc3dvcmRcIixcInNlYXJjaFwiLFwidGVsXCIsXCJ1cmxcIixcImRhdGVcIixcInRpbWVcIl0sSj1bXCJjaGVja2JveFwiLFwicmFkaW9cIl0sRj1cImRhdGEtcGh4LXN0YXRpY1wiLFY9MSxxPVwicGh4LVwiLFc9e2RlYm91bmNlOjMwMCx0aHJvdHRsZTozMDB9LEs9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gY29uc29sZS5lcnJvciYmY29uc29sZS5lcnJvcihlLHQpfTt2YXIgJD1mdW5jdGlvbihlLHQsbixpKXtlLmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSYmY29uc29sZS5sb2coXCJcIi5jb25jYXQoZS5pZCxcIiBcIikuY29uY2F0KHQsXCI6IFwiKS5jb25jYXQobixcIiAtIFwiKSxpKX0sWD1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6ZnVuY3Rpb24oKXtyZXR1cm4gZX19LHo9ZnVuY3Rpb24oZSl7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpfSxHPWZ1bmN0aW9uKGUsdCxuKXtkb3tpZihlLm1hdGNoZXMoXCJbXCIuY29uY2F0KHQsXCJdXCIpKSlyZXR1cm4gZTtlPWUucGFyZW50RWxlbWVudHx8ZS5wYXJlbnROb2RlfXdoaWxlKG51bGwhPT1lJiYxPT09ZS5ub2RlVHlwZSYmIShuJiZuLmlzU2FtZU5vZGUoZSl8fGUubWF0Y2hlcyhCKSkpO3JldHVybiBudWxsfSxZPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09PV8oZSkmJiEoZSBpbnN0YW5jZW9mIEFycmF5KX0sUT1mdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH0sWj1mdW5jdGlvbihlLHQpe3JldHVybiBlJiZ0KGUpfSxlZT1mdW5jdGlvbihlKXt2YXIgdCxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxpPW5ldyBGb3JtRGF0YShlKSxyPW5ldyBVUkxTZWFyY2hQYXJhbXMsbz1mdW5jdGlvbihlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU3ltYm9sfHxudWxsPT1lW1N5bWJvbC5pdGVyYXRvcl0pe2lmKEFycmF5LmlzQXJyYXkoZSl8fChlPUQoZSkpKXt2YXIgdD0wLG49ZnVuY3Rpb24oKXt9O3JldHVybntzOm4sbjpmdW5jdGlvbigpe3JldHVybiB0Pj1lLmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6ZVt0KytdfX0sZTpmdW5jdGlvbihlKXt0aHJvdyBlfSxmOm59fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX12YXIgaSxyLG89ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe2k9ZVtTeW1ib2wuaXRlcmF0b3JdKCl9LG46ZnVuY3Rpb24oKXt2YXIgZT1pLm5leHQoKTtyZXR1cm4gbz1lLmRvbmUsZX0sZTpmdW5jdGlvbihlKXthPSEwLHI9ZX0sZjpmdW5jdGlvbigpe3RyeXtvfHxudWxsPT1pLnJldHVybnx8aS5yZXR1cm4oKX1maW5hbGx5e2lmKGEpdGhyb3cgcn19fX0oaS5lbnRyaWVzKCkpO3RyeXtmb3Ioby5zKCk7ISh0PW8ubigpKS5kb25lOyl7dmFyIGE9TCh0LnZhbHVlLDIpLHU9YVswXSxjPWFbMV07ci5hcHBlbmQodSxjKX19Y2F0Y2goZSl7by5lKGUpfWZpbmFsbHl7by5mKCl9Zm9yKHZhciBzIGluIG4pci5hcHBlbmQocyxuW3NdKTtyZXR1cm4gci50b1N0cmluZygpfSx0ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXtTKHRoaXMsZSksdGhpcy52aWV3SWQ9dCx0aGlzLnJlbmRlcmVkPXt9LHRoaXMubWVyZ2VEaWZmKG4pfXJldHVybiBQKGUsbnVsbCxbe2tleTpcImV4dHJhY3RcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnIsbj1lLmUsaT1lLnQ7cmV0dXJuIGRlbGV0ZSBlLnIsZGVsZXRlIGUuZSxkZWxldGUgZS50LHtkaWZmOmUsdGl0bGU6aSxyZXBseTp0fHxudWxsLGV2ZW50czpufHxbXX19fV0pLFAoZSxbe2tleTpcInBhcmVudFZpZXdJZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlld0lkfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVjdXJzaXZlVG9TdHJpbmcodGhpcy5yZW5kZXJlZCx0aGlzLnJlbmRlcmVkLmMsZSl9fSx7a2V5OlwicmVjdXJzaXZlVG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZS5jLG49YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsaT17YnVmZmVyOlwiXCIsY29tcG9uZW50czp0LG9ubHlDaWRzOm49bj9uZXcgU2V0KG4pOm51bGx9O3JldHVybiB0aGlzLnRvT3V0cHV0QnVmZmVyKGUsaSksaS5idWZmZXJ9fSx7a2V5OlwiY29tcG9uZW50Q0lEc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3Qua2V5cyhlLmN8fHt9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUpfSl9fSx7a2V5OlwiaXNDb21wb25lbnRPbmx5RGlmZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiEhZS5jJiYxPT09T2JqZWN0LmtleXMoZSkubGVuZ3RofX0se2tleTpcImdldENvbXBvbmVudFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY1t0XX19LHtrZXk6XCJtZXJnZURpZmZcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmM7aWYoZGVsZXRlIGUuYyx0aGlzLnJlbmRlcmVkPXRoaXMucmVjdXJzaXZlTWVyZ2UodGhpcy5yZW5kZXJlZCxlKSx0aGlzLnJlbmRlcmVkLmM9dGhpcy5yZW5kZXJlZC5jfHx7fSx0KXt2YXIgbj10aGlzLnJlbmRlcmVkLmM7Zm9yKHZhciBpIGluIHQpe3ZhciByPXRbaV0sbz1yLGE9by5zO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXtmb3IoO1wibnVtYmVyXCI9PXR5cGVvZiBhOylhPShvPWE+MD90W2FdOm5bLWFdKS5zO289eihvKSx0aGlzLmRvUmVjdXJzaXZlTWVyZ2UobyxyKSxvLnM9YX1lbHNlIG89bltpXXx8e30sbz10aGlzLnJlY3Vyc2l2ZU1lcmdlKG8scik7dFtpXT1vfWZvcih2YXIgdSBpbiB0KW5bdV09dFt1XTtlLmM9dH19fSx7a2V5OlwicmVjdXJzaXZlTWVyZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDAhPT10LnM/dDoodGhpcy5kb1JlY3Vyc2l2ZU1lcmdlKGUsdCksZSl9fSx7a2V5OlwiZG9SZWN1cnNpdmVNZXJnZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIHQpe3ZhciBpPXRbbl0scj1lW25dO1koaSkmJnZvaWQgMD09PWkucyYmWShyKT90aGlzLmRvUmVjdXJzaXZlTWVyZ2UocixpKTplW25dPWl9fX0se2tleTpcImNvbXBvbmVudFRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcodGhpcy5yZW5kZXJlZC5jLGUpfX0se2tleTpcInBydW5lQ0lEc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBkZWxldGUgdC5yZW5kZXJlZC5jW2VdfSl9fSx7a2V5OlwiZ2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW5kZXJlZH19LHtrZXk6XCJpc05ld0ZpbmdlcnByaW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hIShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30pLnN9fSx7a2V5OlwidG9PdXRwdXRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGUuZClyZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIoZSx0KTt2YXIgbj1lLnM7dC5idWZmZXIrPW5bMF07Zm9yKHZhciBpPTE7aTxuLmxlbmd0aDtpKyspdGhpcy5keW5hbWljVG9CdWZmZXIoZVtpLTFdLHQpLHQuYnVmZmVyKz1uW2ldfX0se2tleTpcImNvbXByZWhlbnNpb25Ub0J1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPWUuZCxpPWUucyxyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBvPW5bcl07dC5idWZmZXIrPWlbMF07Zm9yKHZhciBhPTE7YTxpLmxlbmd0aDthKyspdGhpcy5keW5hbWljVG9CdWZmZXIob1thLTFdLHQpLHQuYnVmZmVyKz1pW2FdfX19LHtrZXk6XCJkeW5hbWljVG9CdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe1wibnVtYmVyXCI9PXR5cGVvZiBlP3QuYnVmZmVyKz10aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHQuY29tcG9uZW50cyxlLHQub25seUNpZHMpOlkoZSk/dGhpcy50b091dHB1dEJ1ZmZlcihlLHQpOnQuYnVmZmVyKz1lfX0se2tleTpcInJlY3Vyc2l2ZUNJRFRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj1lW3RdfHxLKFwibm8gY29tcG9uZW50IGZvciBDSUQgXCIuY29uY2F0KHQpLGUpLG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO28uaW5uZXJIVE1MPXRoaXMucmVjdXJzaXZlVG9TdHJpbmcocixlLG4pO3ZhciBhPW8uY29udGVudCx1PW4mJiFuLmhhcyh0KSxjPUwoQXJyYXkuZnJvbShhLmNoaWxkTm9kZXMpLnJlZHVjZShmdW5jdGlvbihlLG4scil7dmFyIGE9TChlLDIpLGM9YVswXSxzPWFbMV07cmV0dXJuIG4ubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERT9uLmdldEF0dHJpYnV0ZShqKT9bYywhMF06KG4uc2V0QXR0cmlidXRlKGosdCksbi5pZHx8KG4uaWQ9XCJcIi5jb25jYXQoaS5wYXJlbnRWaWV3SWQoKSxcIi1cIikuY29uY2F0KHQsXCItXCIpLmNvbmNhdChyKSksdSYmKG4uc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtc2tpcFwiLFwiXCIpLG4uaW5uZXJIVE1MPVwiXCIpLFshMCxzXSk6XCJcIiE9PW4ubm9kZVZhbHVlLnRyaW0oKT8oSyhcIm9ubHkgSFRNTCBlbGVtZW50IHRhZ3MgYXJlIGFsbG93ZWQgYXQgdGhlIHJvb3Qgb2YgY29tcG9uZW50cy5cXG5cXG5cIisnZ290OiBcIicuY29uY2F0KG4ubm9kZVZhbHVlLnRyaW0oKSwnXCJcXG5cXG4nKStcIndpdGhpbjpcXG5cIixvLmlubmVySFRNTC50cmltKCkpLG4ucmVwbGFjZVdpdGgoaS5jcmVhdGVTcGFuKG4ubm9kZVZhbHVlLHQpKSxbITAsc10pOihuLnJlbW92ZSgpLFtjLHNdKX0sWyExLCExXSksMikscz1jWzBdLGw9Y1sxXTtyZXR1cm4gc3x8bD8hcyYmbD8oSyhcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGRpcmVjdGx5IGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IG9ubHkgc3ViY29tcG9uZW50cyB3ZXJlIGZvdW5kLiBBIGNvbXBvbmVudCBtdXN0IHJlbmRlciBhdCBsZWFzdCBvbmUgSFRNTCB0YWcgZGlyZWN0bHkgaW5zaWRlIGl0c2VsZi5cIixvLmlubmVySFRNTC50cmltKCkpLG8uaW5uZXJIVE1MKTpvLmlubmVySFRNTDooSyhcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IHRoZSBjb21wb25lbnQgaXMgZW1wdHk6XFxuXCIsby5pbm5lckhUTUwudHJpbSgpKSx0aGlzLmNyZWF0ZVNwYW4oXCJcIix0KS5vdXRlckhUTUwpfX0se2tleTpcImNyZWF0ZVNwYW5cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3JldHVybiBuLmlubmVyVGV4dD1lLG4uc2V0QXR0cmlidXRlKGosdCksbn19XSksZX0oKSxuZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXt2YXIgaT10aGlzLHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O2lmKFModGhpcyxlKSx0aGlzLnVubG9hZGVkPSExLCFufHxcIk9iamVjdFwiPT09bi5jb25zdHJ1Y3Rvci5uYW1lKXRocm93IG5ldyBFcnJvcignXFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxcblxcbiAgICAgICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxcbiAgICAgICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXFxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxcbiAgICAgICcpO3RoaXMuc29ja2V0PW5ldyBuKHQsciksdGhpcy5iaW5kaW5nUHJlZml4PXIuYmluZGluZ1ByZWZpeHx8cSx0aGlzLm9wdHM9cix0aGlzLnBhcmFtcz1YKHIucGFyYW1zfHx7fSksdGhpcy52aWV3TG9nZ2VyPXIudmlld0xvZ2dlcix0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzPXIubWV0YWRhdGF8fHt9LHRoaXMuZGVmYXVsdHM9T2JqZWN0LmFzc2lnbih6KFcpLHIuZGVmYXVsdHN8fHt9KSx0aGlzLmFjdGl2ZUVsZW1lbnQ9bnVsbCx0aGlzLnByZXZBY3RpdmU9bnVsbCx0aGlzLnNpbGVuY2VkPSExLHRoaXMubWFpbj1udWxsLHRoaXMubGlua1JlZj0wLHRoaXMucm9vdHM9e30sdGhpcy5ocmVmPXdpbmRvdy5sb2NhdGlvbi5ocmVmLHRoaXMucGVuZGluZ0xpbms9bnVsbCx0aGlzLmN1cnJlbnRMb2NhdGlvbj16KHdpbmRvdy5sb2NhdGlvbiksdGhpcy5ob29rcz1yLmhvb2tzfHx7fSx0aGlzLmxvYWRlclRpbWVvdXQ9ci5sb2FkZXJUaW1lb3V0fHxWLHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cz0hMSx0aGlzLmRvbUNhbGxiYWNrcz1yLmRvbXx8e29uQmVmb3JlRWxVcGRhdGVkOlgoKX0sd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIixmdW5jdGlvbihlKXtpLnVubG9hZGVkPSEwfSksdGhpcy5zb2NrZXQub25PcGVuKGZ1bmN0aW9uKCl7aS5pc1VubG9hZGVkKCkmJndpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKX0pfXJldHVybiBQKGUsW3trZXk6XCJpc1Byb2ZpbGVFbmFibGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cInRydWVcIj09PXNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCIpfX0se2tleTpcImlzRGVidWdFbmFibGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cInRydWVcIj09PXNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIil9fSx7a2V5OlwiZW5hYmxlRGVidWdcIix2YWx1ZTpmdW5jdGlvbigpe3Nlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIixcInRydWVcIil9fSx7a2V5OlwiZW5hYmxlUHJvZmlsaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OnByb2ZpbGluZ1wiLFwidHJ1ZVwiKX19LHtrZXk6XCJkaXNhYmxlRGVidWdcIix2YWx1ZTpmdW5jdGlvbigpe3Nlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIil9fSx7a2V5OlwiZGlzYWJsZVByb2ZpbGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIil9fSx7a2V5OlwiZW5hYmxlTGF0ZW5jeVNpbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuZW5hYmxlRGVidWcoKSxjb25zb2xlLmxvZyhcImxhdGVuY3kgc2ltdWxhdG9yIGVuYWJsZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGlzIGJyb3dzZXIgc2Vzc2lvbi4gQ2FsbCBkaXNhYmxlTGF0ZW5jeVNpbSgpIHRvIGRpc2FibGVcIiksc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiLGUpfX0se2tleTpcImRpc2FibGVMYXRlbmN5U2ltXCIsdmFsdWU6ZnVuY3Rpb24oKXtzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCIpfX0se2tleTpcImdldExhdGVuY3lTaW1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6bGF0ZW5jeS1zaW1cIik7cmV0dXJuIGU/cGFyc2VJbnQoZSk6bnVsbH19LHtrZXk6XCJnZXRTb2NrZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvY2tldH19LHtrZXk6XCJjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ZnVuY3Rpb24oKXtlLmpvaW5Sb290Vmlld3MoKSYmKGUuYmluZFRvcExldmVsRXZlbnRzKCksZS5zb2NrZXQuY29ubmVjdCgpKX07W1wiY29tcGxldGVcIixcImxvYWRlZFwiLFwiaW50ZXJhY3RpdmVcIl0uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKT49MD90KCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpe3JldHVybiB0KCl9KX19LHtrZXk6XCJkaXNjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5zb2NrZXQuZGlzY29ubmVjdChlKX19LHtrZXk6XCJ0cmlnZ2VyRE9NXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbjsobj10aGlzLmRvbUNhbGxiYWNrcylbZV0uYXBwbHkobix4KHQpKX19LHtrZXk6XCJ0aW1lXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZighdGhpcy5pc1Byb2ZpbGVFbmFibGVkKCl8fCFjb25zb2xlLnRpbWUpcmV0dXJuIHQoKTtjb25zb2xlLnRpbWUoZSk7dmFyIG49dCgpO3JldHVybiBjb25zb2xlLnRpbWVFbmQoZSksbn19LHtrZXk6XCJsb2dcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYodGhpcy52aWV3TG9nZ2VyKXt2YXIgaT1MKG4oKSwyKSxyPWlbMF0sbz1pWzFdO3RoaXMudmlld0xvZ2dlcihlLHQscixvKX1lbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7dmFyIGE9TChuKCksMiksdT1hWzBdLGM9YVsxXTskKGUsdCx1LGMpfX19LHtrZXk6XCJvbkNoYW5uZWxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcztlLm9uKHQsZnVuY3Rpb24oZSl7dmFyIHQ9aS5nZXRMYXRlbmN5U2ltKCk7dD8oY29uc29sZS5sb2coXCJzaW11bGF0aW5nIFwiLmNvbmNhdCh0LFwibXMgb2YgbGF0ZW5jeSBmcm9tIHNlcnZlciB0byBjbGllbnRcIikpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gbihlKX0sdCkpOm4oZSl9KX19LHtrZXk6XCJ3cmFwUHVzaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0TGF0ZW5jeVNpbSgpO2lmKCF0KXJldHVybiBlKCk7Y29uc29sZS5sb2coXCJzaW11bGF0aW5nIFwiLmNvbmNhdCh0LFwibXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJcIikpO3ZhciBuPXtyZWNlaXZlczpbXSxyZWNlaXZlOmZ1bmN0aW9uKGUsdCl7dGhpcy5yZWNlaXZlcy5wdXNoKFtlLHRdKX19O3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bi5yZWNlaXZlcy5yZWR1Y2UoZnVuY3Rpb24oZSx0KXt2YXIgbj1MKHQsMiksaT1uWzBdLHI9blsxXTtyZXR1cm4gZS5yZWNlaXZlKGkscil9LGUoKSl9LHQpLG59fSx7a2V5OlwicmVsb2FkV2l0aEppdHRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7ZS5kZXN0cm95KCksdGhpcy5kaXNjb25uZWN0KCk7dmFyIG49T1swXSxpPU9bMV0scj1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKGktbisxKSkrbixvPWllLnVwZGF0ZUxvY2FsKGUubmFtZSgpLFwiY29uc2VjdXRpdmUtcmVsb2Fkc1wiLDAsZnVuY3Rpb24oZSl7cmV0dXJuIGUrMX0pO3RoaXMubG9nKGUsXCJqb2luXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJlbmNvdW50ZXJlZCBcIi5jb25jYXQobyxcIiBjb25zZWN1dGl2ZSByZWxvYWRzXCIpXX0pLG8+MTAmJih0aGlzLmxvZyhlLFwiam9pblwiLGZ1bmN0aW9uKCl7cmV0dXJuW1wiZXhjZWVkZWQgXCIuY29uY2F0KDEwLFwiIGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVcIildfSkscj0zZTQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0Lmhhc1BlbmRpbmdMaW5rKCk/d2luZG93LmxvY2F0aW9uPXQucGVuZGluZ0xpbms6d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpfSxyKX19LHtrZXk6XCJnZXRIb29rQ2FsbGJhY2tzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaG9va3NbZV19fSx7a2V5OlwiaXNVbmxvYWRlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5sb2FkZWR9fSx7a2V5OlwiaXNDb25uZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpfX0se2tleTpcImdldEJpbmRpbmdQcmVmaXhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJpbmRpbmdQcmVmaXh9fSx7a2V5OlwiYmluZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiXCIuY29uY2F0KHRoaXMuZ2V0QmluZGluZ1ByZWZpeCgpKS5jb25jYXQoZSl9fSx7a2V5OlwiY2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwoZSx0KX19LHtrZXk6XCJqb2luUm9vdFZpZXdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ITE7cmV0dXJuIHJlLmFsbChkb2N1bWVudCxcIlwiLmNvbmNhdChCLFwiOm5vdChbXCIpLmNvbmNhdChcImRhdGEtcGh4LXBhcmVudC1pZFwiLFwiXSlcIiksZnVuY3Rpb24obil7aWYoIWUuZ2V0Um9vdEJ5SWQobi5pZCkpe3ZhciBpPWUuam9pblJvb3RWaWV3KG4sZS5nZXRIcmVmKCkpO2Uucm9vdD1lLnJvb3R8fGksbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1tYWluXCIpJiYoZS5tYWluPWkpfXQ9ITB9KSx0fX0se2tleTpcInJlZGlyZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmRpc2Nvbm5lY3QoKSxpZS5yZWRpcmVjdChlLHQpfX0se2tleTpcInJlcGxhY2VNYWluXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwscj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106dGhpcy5zZXRQZW5kaW5nTGluayhlKSxvPXRoaXMubWFpbi5lbDt0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpLHRoaXMubWFpbi5kZXN0cm95KCksaWUuZmV0Y2hQYWdlKGUsZnVuY3Rpb24oYSx1KXtpZigyMDAhPT1hKXJldHVybiBuLnJlZGlyZWN0KGUpO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtjLmlubmVySFRNTD11O3ZhciBzPWMuY29udGVudC5jaGlsZE5vZGVzWzBdO2lmKCFzfHwhbi5pc1BoeFZpZXcocykpcmV0dXJuIG4ucmVkaXJlY3QoZSk7bi5qb2luUm9vdFZpZXcocyxlLHQsZnVuY3Rpb24oZSx0KXsxPT09dCYmKG4uY29tbWl0UGVuZGluZ0xpbmsocik/KG8ucmVwbGFjZVdpdGgoZS5lbCksbi5tYWluPWUsaSYmaSgpKTplLmRlc3Ryb3koKSl9KX0pfX0se2tleTpcImlzUGh4Vmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZSYmbnVsbCE9PWUuZ2V0QXR0cmlidXRlKFIpfX0se2tleTpcImpvaW5Sb290Vmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3ZhciByPW5ldyB1ZShlLHRoaXMsbnVsbCx0LG4pO3JldHVybiB0aGlzLnJvb3RzW3IuaWRdPXIsci5qb2luKGkpLHJ9fSx7a2V5Olwib3duZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMsaT1aKGUuY2xvc2VzdChCKSxmdW5jdGlvbihlKXtyZXR1cm4gbi5nZXRWaWV3QnlFbChlKX0pO2kmJnQoaSl9fSx7a2V5Olwid2l0aGluT3duZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3RoaXMub3duZXIoZSxmdW5jdGlvbihpKXt2YXIgcj1lLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJ0YXJnZXRcIikpO251bGw9PT1yP3QoaSxlKTppLndpdGhpblRhcmdldHMocix0KX0pfX0se2tleTpcImdldFZpZXdCeUVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIpO3JldHVybiBaKHRoaXMuZ2V0Um9vdEJ5SWQodCksZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0RGVzY2VuZGVudEJ5RWwoZSl9KX19LHtrZXk6XCJnZXRSb290QnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJvb3RzW2VdfX0se2tleTpcImRlc3Ryb3lBbGxWaWV3c1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMucm9vdHMpdGhpcy5yb290c1tlXS5kZXN0cm95KCksZGVsZXRlIHRoaXMucm9vdHNbZV19fSx7a2V5OlwiZGVzdHJveVZpZXdCeUVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRSb290QnlJZChlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXJvb3QtaWRcIikpO3QmJnQuZGVzdHJveURlc2NlbmRlbnQoZS5pZCl9fSx7a2V5Olwic2V0QWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYodGhpcy5hY3RpdmVFbGVtZW50IT09ZSl7dGhpcy5hY3RpdmVFbGVtZW50PWU7dmFyIG49ZnVuY3Rpb24oKXtlPT09dC5hY3RpdmVFbGVtZW50JiYodC5hY3RpdmVFbGVtZW50PW51bGwpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0KSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHQpfTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsbiksZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixuKX19fSx7a2V5OlwiZ2V0QWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1kb2N1bWVudC5ib2R5P3RoaXMuYWN0aXZlRWxlbWVudHx8ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDpkb2N1bWVudC5hY3RpdmVFbGVtZW50fHxkb2N1bWVudC5ib2R5fX0se2tleTpcImRyb3BBY3RpdmVFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wcmV2QWN0aXZlJiZlLm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkmJih0aGlzLnByZXZBY3RpdmU9bnVsbCl9fSx7a2V5OlwicmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcmV2QWN0aXZlJiZ0aGlzLnByZXZBY3RpdmUhPT1kb2N1bWVudC5ib2R5JiZ0aGlzLnByZXZBY3RpdmUuZm9jdXMoKX19LHtrZXk6XCJibHVyQWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcmV2QWN0aXZlPXRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpLHRoaXMucHJldkFjdGl2ZSE9PWRvY3VtZW50LmJvZHkmJnRoaXMucHJldkFjdGl2ZS5ibHVyKCl9fSx7a2V5OlwiYmluZFRvcExldmVsRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuYm91bmRUb3BMZXZlbEV2ZW50c3x8KHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cz0hMCx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsZnVuY3Rpb24odCl7dC5wZXJzaXN0ZWQmJihlLndpdGhQYWdlTG9hZGluZyh7dG86d2luZG93LmxvY2F0aW9uLmhyZWYsa2luZDpcInJlZGlyZWN0XCJ9KSx3aW5kb3cubG9jYXRpb24ucmVsb2FkKCkpfSksdGhpcy5iaW5kQ2xpY2tzKCksdGhpcy5iaW5kTmF2KCksdGhpcy5iaW5kRm9ybXMoKSx0aGlzLmJpbmQoe2tleXVwOlwia2V5dXBcIixrZXlkb3duOlwia2V5ZG93blwifSxmdW5jdGlvbih0LG4saSxyLG8sYSx1KXt2YXIgYz1yLmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJrZXlcIikpLHM9dC5rZXkmJnQua2V5LnRvTG93ZXJDYXNlKCk7YyYmYy50b0xvd2VyQ2FzZSgpIT09c3x8aS5wdXNoS2V5KHIsbyxuLGEsZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/dyhPYmplY3QobiksITApLmZvckVhY2goZnVuY3Rpb24odCl7RShlLHQsblt0XSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKTp3KE9iamVjdChuKSkuZm9yRWFjaChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KSl9KX1yZXR1cm4gZX0oe2tleTp0LmtleX0sZS5ldmVudE1ldGEobix0LHIpKSl9KSx0aGlzLmJpbmQoe2JsdXI6XCJmb2N1c291dFwiLGZvY3VzOlwiZm9jdXNpblwifSxmdW5jdGlvbih0LG4saSxyLG8sYSx1KXt1fHxpLnB1c2hFdmVudChuLHIsbyxhLGUuZXZlbnRNZXRhKG4sdCxyKSl9KSx0aGlzLmJpbmQoe2JsdXI6XCJibHVyXCIsZm9jdXM6XCJmb2N1c1wifSxmdW5jdGlvbih0LG4saSxyLG8sYSx1KXt1JiZcIndpbmRvd1wiIT09IXUmJmkucHVzaEV2ZW50KG4scixvLGEsZS5ldmVudE1ldGEobix0LHIpKX0pKX19LHtrZXk6XCJldmVudE1ldGFcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcy5tZXRhZGF0YUNhbGxiYWNrc1tlXTtyZXR1cm4gaT9pKHQsbik6e319fSx7a2V5Olwic2V0UGVuZGluZ0xpbmtcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saW5rUmVmKyssdGhpcy5wZW5kaW5nTGluaz1lLHRoaXMubGlua1JlZn19LHtrZXk6XCJjb21taXRQZW5kaW5nTGlua1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxpbmtSZWY9PT1lJiYodGhpcy5ocmVmPXRoaXMucGVuZGluZ0xpbmssdGhpcy5wZW5kaW5nTGluaz1udWxsLCEwKX19LHtrZXk6XCJnZXRIcmVmXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ocmVmfX0se2tleTpcImhhc1BlbmRpbmdMaW5rXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMucGVuZGluZ0xpbmt9fSx7a2V5OlwiYmluZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxpPWZ1bmN0aW9uKGkpe3ZhciByPWVbaV07bi5vbihyLGZ1bmN0aW9uKGUpe3ZhciByPW4uYmluZGluZyhpKSxvPW4uYmluZGluZyhcIndpbmRvdy1cIi5jb25jYXQoaSkpLGE9ZS50YXJnZXQuZ2V0QXR0cmlidXRlJiZlLnRhcmdldC5nZXRBdHRyaWJ1dGUocik7YT9uLmRlYm91bmNlKGUudGFyZ2V0LGUsZnVuY3Rpb24oKXtuLndpdGhpbk93bmVycyhlLnRhcmdldCxmdW5jdGlvbihuLHIpe3QoZSxpLG4sZS50YXJnZXQscixhLG51bGwpfSl9KTpyZS5hbGwoZG9jdW1lbnQsXCJbXCIuY29uY2F0KG8sXCJdXCIpLGZ1bmN0aW9uKHIpe3ZhciBhPXIuZ2V0QXR0cmlidXRlKG8pO24uZGVib3VuY2UocixlLGZ1bmN0aW9uKCl7bi53aXRoaW5Pd25lcnMocixmdW5jdGlvbihuLG8pe3QoZSxpLG4scixvLGEsXCJ3aW5kb3dcIil9KX0pfSl9KX07Zm9yKHZhciByIGluIGUpaShyKX19LHtrZXk6XCJiaW5kQ2xpY2tzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO1shMCwhMV0uZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj10P2UuYmluZGluZyhcImNhcHR1cmUtY2xpY2tcIik6ZS5iaW5kaW5nKFwiY2xpY2tcIik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGkpe3ZhciByPW51bGwsbz0ocj10P2kudGFyZ2V0Lm1hdGNoZXMoXCJbXCIuY29uY2F0KG4sXCJdXCIpKT9pLnRhcmdldDppLnRhcmdldC5xdWVyeVNlbGVjdG9yKFwiW1wiLmNvbmNhdChuLFwiXVwiKSk6RyhpLnRhcmdldCxuKSkmJnIuZ2V0QXR0cmlidXRlKG4pO28mJihcIiNcIj09PXIuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSYmaS5wcmV2ZW50RGVmYXVsdCgpLGUuZGVib3VuY2UocixpLGZ1bmN0aW9uKCl7ZS53aXRoaW5Pd25lcnMocixmdW5jdGlvbih0LG4pe3QucHVzaEV2ZW50KFwiY2xpY2tcIixyLG4sbyxlLmV2ZW50TWV0YShcImNsaWNrXCIsaSxyKSl9KX0pKX0sdCl9KX19LHtrZXk6XCJiaW5kTmF2XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2llLmNhblB1c2hTdGF0ZSgpJiYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLGZ1bmN0aW9uKHQpe2lmKGUucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXt2YXIgbj10LnN0YXRlfHx7fSxpPW4udHlwZSxyPW4uaWQsbz1uLnJvb3QsYT13aW5kb3cubG9jYXRpb24uaHJlZjtlLm1haW4uaXNDb25uZWN0ZWQoKSYmXCJwYXRjaFwiPT09aSYmcj09PWUubWFpbi5pZD9lLm1haW4ucHVzaExpbmtQYXRjaChhLG51bGwpOmUucmVwbGFjZU1haW4oYSxudWxsLGZ1bmN0aW9uKCl7byYmZS5yZXBsYWNlUm9vdEhpc3RvcnkoKX0pfX0sITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbih0KXt2YXIgbj1HKHQudGFyZ2V0LFwiZGF0YS1waHgtbGlua1wiKSxpPW4mJm4uZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtbGlua1wiKSxyPXQubWV0YUtleXx8dC5jdHJsS2V5fHwxPT09dC5idXR0b247aWYoaSYmZS5pc0Nvbm5lY3RlZCgpJiZlLm1haW4mJiFyKXt2YXIgbz1uLmhyZWYsYT1uLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWxpbmstc3RhdGVcIik7aWYodC5wcmV2ZW50RGVmYXVsdCgpLGUucGVuZGluZ0xpbmshPT1vKWlmKFwicGF0Y2hcIj09PWkpZS5wdXNoSGlzdG9yeVBhdGNoKG8sYSxuKTtlbHNle2lmKFwicmVkaXJlY3RcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgXCIuY29uY2F0KFwiZGF0YS1waHgtbGlua1wiLCcgdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAnKS5jb25jYXQoaSkpO2UuaGlzdG9yeVJlZGlyZWN0KG8sYSl9fX0sITEpKX19LHtrZXk6XCJ3aXRoUGFnZUxvYWRpbmdcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JlLmRpc3BhdGNoRXZlbnQod2luZG93LFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLGUpO3ZhciBuPWZ1bmN0aW9uKCl7cmV0dXJuIHJlLmRpc3BhdGNoRXZlbnQod2luZG93LFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsZSl9O3JldHVybiB0P3Qobik6bn19LHtrZXk6XCJwdXNoSGlzdG9yeVBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7dGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOmUsa2luZDpcInBhdGNoXCJ9LGZ1bmN0aW9uKHIpe2kubWFpbi5wdXNoTGlua1BhdGNoKGUsbixmdW5jdGlvbigpe2kuaGlzdG9yeVBhdGNoKGUsdCkscigpfSl9KX19LHtrZXk6XCJoaXN0b3J5UGF0Y2hcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2llLnB1c2hTdGF0ZSh0LHt0eXBlOlwicGF0Y2hcIixpZDp0aGlzLm1haW4uaWR9LGUpLHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pfX0se2tleTpcImhpc3RvcnlSZWRpcmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzO3RoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzplLGtpbmQ6XCJyZWRpcmVjdFwifSxmdW5jdGlvbihyKXtpLnJlcGxhY2VNYWluKGUsbixmdW5jdGlvbigpe2llLnB1c2hTdGF0ZSh0LHt0eXBlOlwicmVkaXJlY3RcIixpZDppLm1haW4uaWR9LGUpLGkucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pLHIoKX0pfSl9fSx7a2V5OlwicmVwbGFjZVJvb3RIaXN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZS5wdXNoU3RhdGUoXCJyZXBsYWNlXCIse3Jvb3Q6ITAsdHlwZTpcInBhdGNoXCIsaWQ6dGhpcy5tYWluLmlkfSl9fSx7a2V5OlwicmVnaXN0ZXJOZXdMb2NhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY3VycmVudExvY2F0aW9uO3JldHVybiB0LnBhdGhuYW1lK3Quc2VhcmNoIT09ZS5wYXRobmFtZStlLnNlYXJjaCYmKHRoaXMuY3VycmVudExvY2F0aW9uPXooZSksITApfX0se2tleTpcImJpbmRGb3Jtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PTA7dGhpcy5vbihcInN1Ym1pdFwiLGZ1bmN0aW9uKHQpe3ZhciBuPXQudGFyZ2V0LmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJzdWJtaXRcIikpO24mJih0LnByZXZlbnREZWZhdWx0KCksdC50YXJnZXQuZGlzYWJsZWQ9ITAsZS53aXRoaW5Pd25lcnModC50YXJnZXQsZnVuY3Rpb24oZSxpKXtyZXR1cm4gZS5zdWJtaXRGb3JtKHQudGFyZ2V0LGksbil9KSl9LCExKTtmb3IodmFyIG49ZnVuY3Rpb24oKXt2YXIgbj1yW2ldO2Uub24obixmdW5jdGlvbihpKXt2YXIgcj1pLnRhcmdldCxvPXIuZm9ybSYmci5mb3JtLmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJjaGFuZ2VcIikpO2lmKG8mJihcIm51bWJlclwiIT09ci50eXBlfHwhci52YWxpZGl0eXx8IXIudmFsaWRpdHkuYmFkSW5wdXQpKXt2YXIgYT10O3QrKzt2YXIgdT1yZS5wcml2YXRlKHIsXCJwcmV2LWl0ZXJhdGlvblwiKXx8e30sYz11LmF0LHM9dS50eXBlO2M9PT1hLTEmJm4hPT1zfHwocmUucHV0UHJpdmF0ZShyLFwicHJldi1pdGVyYXRpb25cIix7YXQ6YSx0eXBlOm59KSxlLmRlYm91bmNlKHIsaSxmdW5jdGlvbigpe2Uud2l0aGluT3duZXJzKHIuZm9ybSxmdW5jdGlvbih0LG4pe3JlLnB1dFByaXZhdGUocixcInBoeC1oYXMtZm9jdXNlZFwiLCEwKSxyZS5pc1RleHR1YWxJbnB1dChyKXx8ZS5zZXRBY3RpdmVFbGVtZW50KHIpLHQucHVzaElucHV0KHIsbixvLGkudGFyZ2V0KX0pfSkpfX0sITEpfSxpPTAscj1bXCJjaGFuZ2VcIixcImlucHV0XCJdO2k8ci5sZW5ndGg7aSsrKW4oKX19LHtrZXk6XCJkZWJvdW5jZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzLmJpbmRpbmcoXCJkZWJvdW5jZVwiKSxyPXRoaXMuYmluZGluZyhcInRocm90dGxlXCIpLG89dGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpLGE9dGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpO3JlLmRlYm91bmNlKGUsdCxpLG8scixhLG4pfX0se2tleTpcInNpbGVuY2VFdmVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNpbGVuY2VkPSEwLGUoKSx0aGlzLnNpbGVuY2VkPSExfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsZnVuY3Rpb24oZSl7bi5zaWxlbmNlZHx8dChlKX0pfX1dKSxlfSgpLGllPXtjYW5QdXNoU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09aGlzdG9yeS5wdXNoU3RhdGV9LGRyb3BMb2NhbDpmdW5jdGlvbihlLHQpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5sb2NhbEtleShlLHQpKX0sdXBkYXRlTG9jYWw6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9dGhpcy5nZXRMb2NhbChlLHQpLG89dGhpcy5sb2NhbEtleShlLHQpLGE9bnVsbD09PXI/bjppKHIpO3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0obyxKU09OLnN0cmluZ2lmeShhKSksYX0sZ2V0TG9jYWw6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShlLHQpKSl9LGZldGNoUGFnZTpmdW5jdGlvbihlLHQpe3ZhciBuPW5ldyBYTUxIdHRwUmVxdWVzdDtuLm9wZW4oXCJHRVRcIixlLCEwKSxuLnRpbWVvdXQ9M2U0LG4uc2V0UmVxdWVzdEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLFwidGV4dC9odG1sXCIpLG4uc2V0UmVxdWVzdEhlYWRlcihcImNhY2hlLWNvbnRyb2xcIixcIm1heC1hZ2U9MCwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtdXN0LXJldmFsaWRhdGUsIHBvc3QtY2hlY2s9MCwgcHJlLWNoZWNrPTBcIiksbi5zZXRSZXF1ZXN0SGVhZGVyKFwieC1yZXF1ZXN0ZWQtd2l0aFwiLFwibGl2ZS1saW5rXCIpLG4ub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiB0KDQwMCl9LG4ub250aW1lb3V0PWZ1bmN0aW9uKCl7cmV0dXJuIHQoNTA0KX0sbi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT09bi5yZWFkeVN0YXRlKXt2YXIgaT1uZXcgVVJMKGUpLHI9aS5wYXRobmFtZStpLnNlYXJjaCxvPVoobi5nZXRSZXNwb25zZUhlYWRlcihcIngtcmVzcG9uc2UtdXJsXCIpfHxuLnJlc3BvbnNlVVJMLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgVVJMKGUpfSksYT1vP28ucGF0aG5hbWUrby5zZWFyY2g6bnVsbDtyZXR1cm5cImxpdmUtbGlua1wiIT09bi5nZXRSZXNwb25zZUhlYWRlcihcIngtcmVxdWVzdGVkLXdpdGhcIik/dCg0MDApOm51bGw9PT1vfHxhIT1yP3QoMzAyKToyMDAhPT1uLnN0YXR1cz90KG4uc3RhdHVzKTp2b2lkIHQoMjAwLG4ucmVzcG9uc2VUZXh0KX19LG4uc2VuZCgpfSxwdXNoU3RhdGU6ZnVuY3Rpb24oZSx0LG4pe2lmKHRoaXMuY2FuUHVzaFN0YXRlKCkpe2lmKG4hPT13aW5kb3cubG9jYXRpb24uaHJlZil7aGlzdG9yeVtlK1wiU3RhdGVcIl0odCxcIlwiLG58fG51bGwpO3ZhciBpPXRoaXMuZ2V0SGFzaFRhcmdldEVsKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtpP2kuc2Nyb2xsSW50b1ZpZXcoKTpcInJlZGlyZWN0XCI9PT10LnR5cGUmJndpbmRvdy5zY3JvbGwoMCwwKX19ZWxzZSB0aGlzLnJlZGlyZWN0KG4pfSxzZXRDb29raWU6ZnVuY3Rpb24oZSx0KXtkb2N1bWVudC5jb29raWU9XCJcIi5jb25jYXQoZSxcIj1cIikuY29uY2F0KHQpfSxnZXRDb29raWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzooPzpefC4qO3MqKVwiLmNvbmNhdChlLFwicyo9cyooW147XSopLiokKXxeLiokXCIpKSxcIiQxXCIpfSxyZWRpcmVjdDpmdW5jdGlvbihlLHQpe3QmJmllLnNldENvb2tpZShcIl9fcGhvZW5peF9mbGFzaF9fXCIsdCtcIjsgbWF4LWFnZT02MDAwMDsgcGF0aD0vXCIpLHdpbmRvdy5sb2NhdGlvbj1lfSxsb2NhbEtleTpmdW5jdGlvbihlLHQpe3JldHVyblwiXCIuY29uY2F0KGUsXCItXCIpLmNvbmNhdCh0KX0sZ2V0SGFzaFRhcmdldEVsOmZ1bmN0aW9uKGUpe2lmKFwiXCIhPT1lLnRvU3RyaW5nKCkpcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpfHxkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdhW25hbWU9XCInLmNvbmNhdChlLnN1YnN0cmluZygxKSwnXCJdJykpfX0scmU9e2J5SWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpfHxLKFwibm8gaWQgZm91bmQgZm9yIFwiLmNvbmNhdChlKSl9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUsdCl7ZS5jbGFzc0xpc3QucmVtb3ZlKHQpLDA9PT1lLmNsYXNzTGlzdC5sZW5ndGgmJmUucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIil9LGFsbDpmdW5jdGlvbihlLHQsbil7dmFyIGk9QXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwodCkpO3JldHVybiBuP2kuZm9yRWFjaChuKTppfSxmaW5kQ29tcG9uZW50Tm9kZUxpc3Q6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmFsbChlLEIpLGk9dGhpcy5hbGwoZSxcIltcIi5jb25jYXQoaiwnPVwiJykuY29uY2F0KHQsJ1wiXScpKTtyZXR1cm4gMD09PW4ubGVuZ3RoP2k6aS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIW4uc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdC5jb250YWlucyhlKX0pfSl9LGZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7cmV0dXJuIG4uaW5uZXJIVE1MPWUsdGhpcy5maW5kUGh4Q2hpbGRyZW4obi5jb250ZW50LHQpfSxpc1BoeFVwZGF0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZuLmluZGV4T2YoZS5nZXRBdHRyaWJ1dGUodCkpPj0wfSxmaW5kUGh4Q2hpbGRyZW46ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hbGwoZSxcIlwiLmNvbmNhdChCLFwiW1wiKS5jb25jYXQoXCJkYXRhLXBoeC1wYXJlbnQtaWRcIiwnPVwiJykuY29uY2F0KHQsJ1wiXScpKX0sZmluZFBhcmVudENJRHM6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9bmV3IFNldCh0KTtyZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24odCxpKXt2YXIgcj1cIltcIi5jb25jYXQoaiwnPVwiJykuY29uY2F0KGksJ1wiXSBbJykuY29uY2F0KGosXCJdXCIpO3JldHVybiBuLmFsbChlLHIpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoaikpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5kZWxldGUoZSl9KSx0fSxpKX0scHJpdmF0ZTpmdW5jdGlvbihlLHQpe3JldHVybiBlLnBoeFByaXZhdGUmJmUucGh4UHJpdmF0ZVt0XX0sZGVsZXRlUHJpdmF0ZTpmdW5jdGlvbihlLHQpe2UucGh4UHJpdmF0ZSYmZGVsZXRlIGUucGh4UHJpdmF0ZVt0XX0scHV0UHJpdmF0ZTpmdW5jdGlvbihlLHQsbil7ZS5waHhQcml2YXRlfHwoZS5waHhQcml2YXRlPXt9KSxlLnBoeFByaXZhdGVbdF09bn0sY29weVByaXZhdGVzOmZ1bmN0aW9uKGUsdCl7dC5waHhQcml2YXRlJiYoZS5waHhQcml2YXRlPXoodC5waHhQcml2YXRlKSl9LHB1dFRpdGxlOmZ1bmN0aW9uKGUpe3ZhciB0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0aXRsZVwiKS5kYXRhc2V0LG49dC5wcmVmaXgsaT10LnN1ZmZpeDtkb2N1bWVudC50aXRsZT1cIlwiLmNvbmNhdChufHxcIlwiKS5jb25jYXQoZSkuY29uY2F0KGl8fFwiXCIpfSxkZWJvdW5jZTpmdW5jdGlvbihlLHQsbixpLHIsbyxhKXt2YXIgdT10aGlzLGM9ZS5nZXRBdHRyaWJ1dGUobikscz1lLmdldEF0dHJpYnV0ZShyKTtcIlwiPT09YyYmKGM9aSksXCJcIj09PXMmJihzPW8pO3ZhciBsPWN8fHM7c3dpdGNoKGwpe2Nhc2UgbnVsbDpyZXR1cm4gYSgpO2Nhc2VcImJsdXJcIjpyZXR1cm4gdm9pZCh0aGlzLm9uY2UoZSxcImRlYm91bmNlLWJsdXJcIikmJmUuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIixmdW5jdGlvbigpe3JldHVybiBhKCl9KSk7ZGVmYXVsdDp2YXIgZD1wYXJzZUludChsKSxoPXRoaXMuaW5jQ3ljbGUoZSxcImRlYm91bmNlLXRyaWdnZXJcIixmdW5jdGlvbigpe3JldHVybiBzP3UuZGVsZXRlUHJpdmF0ZShlLFwidGhyb3R0bGVkXCIpOmEoKX0pO2lmKGlzTmFOKGQpKXJldHVybiBLKFwiaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogXCIuY29uY2F0KGwpKTtpZihzKXt2YXIgZj0hMTtpZihcImtleWRvd25cIj09PXQudHlwZSl7dmFyIHY9dGhpcy5wcml2YXRlKGUsXCJkZWJvdW5jZS1wcmV2LWtleVwiKTt0aGlzLnB1dFByaXZhdGUoZSxcImRlYm91bmNlLXByZXYta2V5XCIsdC5rZXkpLGY9diE9PXQua2V5fWlmKCFmJiZ0aGlzLnByaXZhdGUoZSxcInRocm90dGxlZFwiKSlyZXR1cm4hMTthKCksdGhpcy5wdXRQcml2YXRlKGUsXCJ0aHJvdHRsZWRcIiwhMCksc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiB1LnRyaWdnZXJDeWNsZShlLFwiZGVib3VuY2UtdHJpZ2dlclwiKX0sZCl9ZWxzZSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHUudHJpZ2dlckN5Y2xlKGUsXCJkZWJvdW5jZS10cmlnZ2VyXCIsaCl9LGQpO2UuZm9ybSYmdGhpcy5vbmNlKGUuZm9ybSxcImJpbmQtZGVib3VuY2VcIikmJmUuZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsZnVuY3Rpb24odCl7QXJyYXkuZnJvbShuZXcgRm9ybURhdGEoZS5mb3JtKS5lbnRyaWVzKCksZnVuY3Rpb24odCl7dmFyIG49TCh0LDIpLGk9blswXSxyPShuWzFdLGUuZm9ybS5xdWVyeVNlbGVjdG9yKCdbbmFtZT1cIicuY29uY2F0KGksJ1wiXScpKSk7dS5pbmNDeWNsZShyLFwiZGVib3VuY2UtdHJpZ2dlclwiKSx1LmRlbGV0ZVByaXZhdGUocixcInRocm90dGxlZFwiKX0pfSksdGhpcy5vbmNlKGUsXCJiaW5kLWRlYm91bmNlXCIpJiZlLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsZnVuY3Rpb24odCl7cmV0dXJuIHUudHJpZ2dlckN5Y2xlKGUsXCJkZWJvdW5jZS10cmlnZ2VyXCIpfSl9fSx0cmlnZ2VyQ3ljbGU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPUwodGhpcy5wcml2YXRlKGUsdCksMikscj1pWzBdLG89aVsxXTtufHwobj1yKSxuPT09ciYmKHRoaXMuaW5jQ3ljbGUoZSx0KSxvKCkpfSxvbmNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuITAhPT10aGlzLnByaXZhdGUoZSx0KSYmKHRoaXMucHV0UHJpdmF0ZShlLHQsITApLCEwKX0saW5jQ3ljbGU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06ZnVuY3Rpb24oKXt9LGk9TCh0aGlzLnByaXZhdGUoZSx0KXx8WzAsbl0sMikscj1pWzBdO2lbMV07cmV0dXJuIHIrKyx0aGlzLnB1dFByaXZhdGUoZSx0LFtyLG5dKSxyfSxkaXNjYXJkRXJyb3I6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXQuZ2V0QXR0cmlidXRlJiZ0LmdldEF0dHJpYnV0ZShuKSxyPWkmJmUucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQoaSkpO3ImJih0aGlzLnByaXZhdGUocixcInBoeC1oYXMtZm9jdXNlZFwiKXx8dGhpcy5wcml2YXRlKHIuZm9ybSxcInBoeC1oYXMtc3VibWl0dGVkXCIpfHx0LmNsYXNzTGlzdC5hZGQoXCJwaHgtbm8tZmVlZGJhY2tcIikpfSxpc1BoeENoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1wYXJlbnQtaWRcIil9LGRpc3BhdGNoRXZlbnQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30saT1uZXcgQ3VzdG9tRXZlbnQodCx7YnViYmxlczohMCxjYW5jZWxhYmxlOiEwLGRldGFpbDpufSk7ZS5kaXNwYXRjaEV2ZW50KGkpfSxjbG9uZU5vZGU6ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT10KXJldHVybiBlLmNsb25lTm9kZSghMCk7dmFyIG49ZS5jbG9uZU5vZGUoITEpO3JldHVybiBuLmlubmVySFRNTD10LG59LG1lcmdlQXR0cnM6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOltdLGk9dC5hdHRyaWJ1dGVzLHI9aS5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIG89aVtyXS5uYW1lO24uaW5kZXhPZihvKTwwJiZlLnNldEF0dHJpYnV0ZShvLHQuZ2V0QXR0cmlidXRlKG8pKX1mb3IodmFyIGE9ZS5hdHRyaWJ1dGVzLHU9YS5sZW5ndGgtMTt1Pj0wO3UtLSl7dmFyIGM9YVt1XS5uYW1lO3QuaGFzQXR0cmlidXRlKGMpfHxlLnJlbW92ZUF0dHJpYnV0ZShjKX19LG1lcmdlRm9jdXNlZElucHV0OmZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50fHxyZS5tZXJnZUF0dHJzKGUsdCxbXCJ2YWx1ZVwiXSksdC5yZWFkT25seT9lLnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsITApOmUucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIil9LGhhc1NlbGVjdGlvblJhbmdlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnNldFNlbGVjdGlvblJhbmdlJiYoXCJ0ZXh0XCI9PT1lLnR5cGV8fFwidGV4dGFyZWFcIj09PWUudHlwZSl9LHJlc3RvcmVGb2N1czpmdW5jdGlvbihlLHQsbil7aWYocmUuaXNUZXh0dWFsSW5wdXQoZSkpe3ZhciBpPWUubWF0Y2hlcyhcIjpmb2N1c1wiKTtlLnJlYWRPbmx5JiZlLmJsdXIoKSxpfHxlLmZvY3VzKCksdGhpcy5oYXNTZWxlY3Rpb25SYW5nZShlKSYmZS5zZXRTZWxlY3Rpb25SYW5nZSh0LG4pfX0saXNGb3JtSW5wdXQ6ZnVuY3Rpb24oZSl7cmV0dXJuL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLnRlc3QoZS50YWdOYW1lKSYmXCJidXR0b25cIiE9PWUudHlwZX0sc3luY0F0dHJzVG9Qcm9wczpmdW5jdGlvbihlKXtlIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmSi5pbmRleE9mKGUudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKT49MCYmKGUuY2hlY2tlZD1udWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKX0saXNUZXh0dWFsSW5wdXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFUuaW5kZXhPZihlLnR5cGUpPj0wfSxpc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWw6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUmJm51bGwhPT1lLmdldEF0dHJpYnV0ZSh0KX0sc3luY1BlbmRpbmdSZWY6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPWUuZ2V0QXR0cmlidXRlKE0pO3JldHVybiBudWxsPT09aXx8KHJlLmlzRm9ybUlucHV0KGUpfHxudWxsIT09ZS5nZXRBdHRyaWJ1dGUobik/KHJlLnB1dFByaXZhdGUoZSxNLHQpLCExKTooSC5mb3JFYWNoKGZ1bmN0aW9uKG4pe2UuY2xhc3NMaXN0LmNvbnRhaW5zKG4pJiZ0LmNsYXNzTGlzdC5hZGQobil9KSx0LnNldEF0dHJpYnV0ZShNLGkpLCEwKSl9LGNsZWFuQ2hpbGROb2RlczpmdW5jdGlvbihlLHQpe2lmKHJlLmlzUGh4VXBkYXRlKGUsdCxbXCJhcHBlbmRcIixcInByZXBlbmRcIl0pKXt2YXIgbj1bXTtlLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmlkfHwoZS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiZcIlwiPT09ZS5ub2RlVmFsdWUudHJpbSgpfHxLKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIisncmVtb3ZpbmcgaWxsZWdhbCBub2RlOiBcIicuY29uY2F0KChlLm91dGVySFRNTHx8ZS5ub2RlVmFsdWUpLnRyaW0oKSwnXCJcXG5cXG4nKSksbi5wdXNoKGUpKX0pLG4uZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZW1vdmUoKX0pfX19LG9lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSl7Uyh0aGlzLGUpO3ZhciByPUFycmF5LmZyb20obi5jaGlsZHJlbikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSksbz1bXSxhPVtdO3QuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaWQmJihvLnB1c2goZS5pZCksci5pbmRleE9mKGUuaWQpPj0wJiZhLnB1c2goW2UuaWQsZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nJiZlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWRdKSl9KSx0aGlzLmNvbnRhaW5lcklEPW4uaWQsdGhpcy51cGRhdGVUeXBlPWksdGhpcy5tb2RpZmllZElkcz1hLHRoaXMubmV3SWRzPXIuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBvLmluZGV4T2YoZSk8MH0pfXJldHVybiBQKGUsW3trZXk6XCJwZXJmb3JtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1yZS5ieUlkKHRoaXMuY29udGFpbmVySUQpO3RoaXMubW9kaWZpZWRJZHMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbj1MKHQsMiksaT1uWzBdLHI9blsxXTtyP1ooZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQociksZnVuY3Rpb24oZSl7Wihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpKSxmdW5jdGlvbih0KXt0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcmJnQucHJldmlvdXNFbGVtZW50U2libGluZy5pZD09ZS5pZHx8ZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLHQpfSl9KTpaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGkpLGZ1bmN0aW9uKHQpe251bGw9PXQucHJldmlvdXNFbGVtZW50U2libGluZ3x8ZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsdCl9KX0pLFwicHJlcGVuZFwiPT10aGlzLnVwZGF0ZVR5cGUmJnRoaXMubmV3SWRzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe1ooZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodCksZnVuY3Rpb24odCl7cmV0dXJuIGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLHQpfSl9KX19XSksZX0oKSxhZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkscixvKXtTKHRoaXMsZSksdGhpcy52aWV3PXQsdGhpcy5saXZlU29ja2V0PXQubGl2ZVNvY2tldCx0aGlzLmNvbnRhaW5lcj1uLHRoaXMuaWQ9aSx0aGlzLnJvb3RJRD10LnJvb3QuaWQsdGhpcy5odG1sPXIsdGhpcy50YXJnZXRDSUQ9byx0aGlzLmNpZFBhdGNoPVwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLnRhcmdldENJRCx0aGlzLmNhbGxiYWNrcz17YmVmb3JlYWRkZWQ6W10sYmVmb3JldXBkYXRlZDpbXSxiZWZvcmVkaXNjYXJkZWQ6W10sYmVmb3JlcGh4Q2hpbGRBZGRlZDpbXSxhZnRlcmFkZGVkOltdLGFmdGVydXBkYXRlZDpbXSxhZnRlcmRpc2NhcmRlZDpbXSxhZnRlcnBoeENoaWxkQWRkZWQ6W119fXJldHVybiBQKGUsbnVsbCxbe2tleTpcInBhdGNoRWxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7YihlLHQse2NoaWxkcmVuT25seTohMSxvbkJlZm9yZUVsVXBkYXRlZDpmdW5jdGlvbihlLHQpe2lmKG4mJm4uaXNTYW1lTm9kZShlKSYmcmUuaXNGb3JtSW5wdXQoZSkpcmV0dXJuIHJlLm1lcmdlRm9jdXNlZElucHV0KGUsdCksITF9fSl9fV0pLFAoZSxbe2tleTpcImJlZm9yZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5jYWxsYmFja3NbXCJiZWZvcmVcIi5jb25jYXQoZSldLnB1c2godCl9fSx7a2V5OlwiYWZ0ZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuY2FsbGJhY2tzW1wiYWZ0ZXJcIi5jb25jYXQoZSldLnB1c2godCl9fSx7a2V5OlwidHJhY2tCZWZvcmVcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLGk9MTtpPHQ7aSsrKW5baS0xXT1hcmd1bWVudHNbaV07dGhpcy5jYWxsYmFja3NbXCJiZWZvcmVcIi5jb25jYXQoZSldLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwbHkodm9pZCAwLG4pfSl9fSx7a2V5OlwidHJhY2tBZnRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCksaT0xO2k8dDtpKyspbltpLTFdPWFyZ3VtZW50c1tpXTt0aGlzLmNhbGxiYWNrc1tcImFmdGVyXCIuY29uY2F0KGUpXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFwcGx5KHZvaWQgMCxuKX0pfX0se2tleTpcIm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZS5hbGwodGhpcy5jb250YWluZXIsXCJbcGh4LXVwZGF0ZT1hcHBlbmRdID4gKiwgW3BoeC11cGRhdGU9cHJlcGVuZF0gPiAqXCIsZnVuY3Rpb24oZSl7ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZW1vdmVcIixcIlwiKX0pfX0se2tleTpcInBlcmZvcm1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnZpZXcsbj10aGlzLmxpdmVTb2NrZXQsaT10aGlzLmNvbnRhaW5lcixyPXRoaXMuaHRtbCxvPXRoaXMuaXNDSURQYXRjaCgpP3RoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKCk6aTtpZighdGhpcy5pc0NJRFBhdGNoKCl8fG8pe3ZhciBhPW4uZ2V0QWN0aXZlRWxlbWVudCgpLHU9YSYmcmUuaGFzU2VsZWN0aW9uUmFuZ2UoYSk/YTp7fSxjPXUuc2VsZWN0aW9uU3RhcnQscz11LnNlbGVjdGlvbkVuZCxsPW4uYmluZGluZyhcInVwZGF0ZVwiKSxkPW4uYmluZGluZyhcImZlZWRiYWNrLWZvclwiKSxoPW4uYmluZGluZyhcImRpc2FibGUtd2l0aFwiKSxmPW4uYmluZGluZyhcInRyaWdnZXItYWN0aW9uXCIpLHY9W10scD1bXSxnPVtdLG09bi50aW1lKFwicHJlbW9ycGggY29udGFpbmVyIHByZXBcIixmdW5jdGlvbigpe3JldHVybiBlLmJ1aWxkRGlmZkhUTUwoaSxyLGwsbyl9KTtyZXR1cm4gdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsaSksdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIixpLGkpLG4udGltZShcIm1vcnBoZG9tXCIsZnVuY3Rpb24oKXtiKG8sbSx7Y2hpbGRyZW5Pbmx5Om51bGw9PT1vLmdldEF0dHJpYnV0ZShqKSxvbkJlZm9yZU5vZGVBZGRlZDpmdW5jdGlvbih0KXtyZXR1cm4gcmUuZGlzY2FyZEVycm9yKG8sdCxkKSxlLnRyYWNrQmVmb3JlKFwiYWRkZWRcIix0KSx0fSxvbk5vZGVBZGRlZDpmdW5jdGlvbihuKXtyZS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwobixmKSYmbi5zdWJtaXQoKSxyZS5pc1BoeENoaWxkKG4pJiZ0Lm93bnNFbGVtZW50KG4pJiZlLnRyYWNrQWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsbiksdi5wdXNoKG4pfSxvbk5vZGVEaXNjYXJkZWQ6ZnVuY3Rpb24odCl7cmUuaXNQaHhDaGlsZCh0KSYmbi5kZXN0cm95Vmlld0J5RWwodCksZS50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsdCl9LG9uQmVmb3JlTm9kZURpc2NhcmRlZDpmdW5jdGlvbih0KXtyZXR1cm4hKCF0LmdldEF0dHJpYnV0ZXx8bnVsbD09PXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcmVtb3ZlXCIpKXx8KG51bGw9PT10LnBhcmVudE5vZGV8fCFyZS5pc1BoeFVwZGF0ZSh0LnBhcmVudE5vZGUsbCxbXCJhcHBlbmRcIixcInByZXBlbmRcIl0pfHwhdC5pZCkmJighZS5za2lwQ0lEU2libGluZyh0KSYmKGUudHJhY2tCZWZvcmUoXCJkaXNjYXJkZWRcIix0KSwhMCkpfSxvbkVsVXBkYXRlZDpmdW5jdGlvbihlKXtyZS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZSxmKSYmZS5zdWJtaXQoKSxwLnB1c2goZSl9LG9uQmVmb3JlRWxVcGRhdGVkOmZ1bmN0aW9uKHQsbil7aWYocmUuY2xlYW5DaGlsZE5vZGVzKG4sbCksZS5za2lwQ0lEU2libGluZyhuKSlyZXR1cm4hMTtpZihcImlnbm9yZVwiPT09dC5nZXRBdHRyaWJ1dGUobCkpcmV0dXJuIGUudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsdCxuKSxyZS5tZXJnZUF0dHJzKHQsbikscC5wdXNoKHQpLCExO2lmKFwibnVtYmVyXCI9PT10LnR5cGUmJnQudmFsaWRpdHkmJnQudmFsaWRpdHkuYmFkSW5wdXQpcmV0dXJuITE7aWYoIXJlLnN5bmNQZW5kaW5nUmVmKHQsbixoKSlyZXR1cm4hMTtpZihyZS5pc1BoeENoaWxkKG4pKXt2YXIgaT10LmdldEF0dHJpYnV0ZShGKTtyZXR1cm4gcmUubWVyZ2VBdHRycyh0LG4pLHQuc2V0QXR0cmlidXRlKEYsaSksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIsZS5yb290SUQpLCExfXJldHVybiByZS5jb3B5UHJpdmF0ZXMobix0KSxyZS5kaXNjYXJkRXJyb3IobyxuLGQpLGEmJnQuaXNTYW1lTm9kZShhKSYmcmUuaXNGb3JtSW5wdXQodCkmJiFlLmZvcmNlRm9jdXNlZFNlbGVjdFVwZGF0ZSh0LG4pPyhlLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLHQsbikscmUubWVyZ2VGb2N1c2VkSW5wdXQodCxuKSxyZS5zeW5jQXR0cnNUb1Byb3BzKHQpLHAucHVzaCh0KSwhMSk6KHJlLmlzUGh4VXBkYXRlKG4sbCxbXCJhcHBlbmRcIixcInByZXBlbmRcIl0pJiZnLnB1c2gobmV3IG9lKHQsbixuLmdldEF0dHJpYnV0ZShsKSkpLHJlLnN5bmNBdHRyc1RvUHJvcHMobiksZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLCEwKX19KX0pLG4uaXNEZWJ1Z0VuYWJsZWQoKSYmZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IFNldCx0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKSxuPTAsaT10Lmxlbmd0aDtuPGk7bisrKWUuaGFzKHRbbl0uaWQpP2NvbnNvbGUuZXJyb3IoXCJNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6IFwiLmNvbmNhdCh0W25dLmlkLFwiLiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLlwiKSk6ZS5hZGQodFtuXS5pZCl9KCksZy5sZW5ndGg+MCYmbi50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLGZ1bmN0aW9uKCl7Zy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBlcmZvcm0oKX0pfSksbi5zaWxlbmNlRXZlbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIHJlLnJlc3RvcmVGb2N1cyhhLGMscyl9KSxyZS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LFwicGh4OnVwZGF0ZVwiKSx2LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tBZnRlcihcImFkZGVkXCIsdCl9KSxwLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tBZnRlcihcInVwZGF0ZWRcIix0KX0pLCEwfX19LHtrZXk6XCJmb3JjZUZvY3VzZWRTZWxlY3RVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiEwPT09ZS5tdWx0aXBsZXx8ZS5pbm5lckhUTUwhPXQuaW5uZXJIVE1MfX0se2tleTpcImlzQ0lEUGF0Y2hcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNpZFBhdGNofX0se2tleTpcInNraXBDSURTaWJsaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmbnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtc2tpcFwiKX19LHtrZXk6XCJ0YXJnZXRDSURDb250YWluZXJcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuaXNDSURQYXRjaCgpKXt2YXIgZT1rKHJlLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmNvbnRhaW5lcix0aGlzLnRhcmdldENJRCkpLHQ9ZVswXTtyZXR1cm4gMD09PWUuc2xpY2UoMSkubGVuZ3RoP3Q6dCYmdC5wYXJlbnROb2RlfX19LHtrZXk6XCJidWlsZERpZmZIVE1MXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9dGhpcyxvPXRoaXMuaXNDSURQYXRjaCgpLGE9byYmaS5nZXRBdHRyaWJ1dGUoaik9PT10aGlzLnRhcmdldENJRC50b1N0cmluZygpO2lmKCFvfHxhKXJldHVybiB0O3ZhciB1PW51bGwsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7dT1yZS5jbG9uZU5vZGUoaSk7dmFyIHM9ayhyZS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodSx0aGlzLnRhcmdldENJRCkpLGw9c1swXSxkPXMuc2xpY2UoMSk7cmV0dXJuIGMuaW5uZXJIVE1MPXQsZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbW92ZSgpfSksQXJyYXkuZnJvbSh1LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5pZCYmZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZlLmdldEF0dHJpYnV0ZShqKSE9PXIudGFyZ2V0Q0lELnRvU3RyaW5nKCkmJihlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LXNraXBcIixcIlwiKSxlLmlubmVySFRNTD1cIlwiKX0pLEFycmF5LmZyb20oYy5jb250ZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHUuaW5zZXJ0QmVmb3JlKGUsbCl9KSxsLnJlbW92ZSgpLHUub3V0ZXJIVE1MfX1dKSxlfSgpLHVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSxyLG8pe3ZhciBhPXRoaXM7Uyh0aGlzLGUpLHRoaXMubGl2ZVNvY2tldD1uLHRoaXMuZmxhc2g9byx0aGlzLnBhcmVudD1pLHRoaXMucm9vdD1pP2kucm9vdDp0aGlzLHRoaXMuZWw9dCx0aGlzLmlkPXRoaXMuZWwuaWQsdGhpcy52aWV3PXRoaXMuZWwuZ2V0QXR0cmlidXRlKFIpLHRoaXMucmVmPTAsdGhpcy5jaGlsZEpvaW5zPTAsdGhpcy5sb2FkZXJUaW1lcj1udWxsLHRoaXMucGVuZGluZ0RpZmZzPVtdLHRoaXMuaHJlZj1yLHRoaXMuam9pbkNvdW50PXRoaXMucGFyZW50P3RoaXMucGFyZW50LmpvaW5Db3VudC0xOjAsdGhpcy5qb2luUGVuZGluZz0hMCx0aGlzLmRlc3Ryb3llZD0hMSx0aGlzLmpvaW5DYWxsYmFjaz1mdW5jdGlvbigpe30sdGhpcy5zdG9wQ2FsbGJhY2s9ZnVuY3Rpb24oKXt9LHRoaXMucGVuZGluZ0pvaW5PcHM9dGhpcy5wYXJlbnQ/bnVsbDpbXSx0aGlzLnZpZXdIb29rcz17fSx0aGlzLmNoaWxkcmVuPXRoaXMucGFyZW50P251bGw6e30sdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdPXt9LHRoaXMuY2hhbm5lbD10aGlzLmxpdmVTb2NrZXQuY2hhbm5lbChcImx2OlwiLmNvbmNhdCh0aGlzLmlkKSxmdW5jdGlvbigpe3JldHVybnt1cmw6YS5ocmVmLHBhcmFtczphLmNvbm5lY3RQYXJhbXMoKSxzZXNzaW9uOmEuZ2V0U2Vzc2lvbigpLHN0YXRpYzphLmdldFN0YXRpYygpLGZsYXNoOmEuZmxhc2h9fSksdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KSx0aGlzLmJpbmRDaGFubmVsKCl9cmV0dXJuIFAoZSxbe2tleTpcImlzTWFpblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl2ZVNvY2tldC5tYWluPT09dGhpc319LHtrZXk6XCJjb25uZWN0UGFyYW1zXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMudmlldyksdD1yZS5hbGwoZG9jdW1lbnQsXCJbXCIuY29uY2F0KHRoaXMuYmluZGluZyhcInRyYWNrLXN0YXRpY1wiKSxcIl1cIikpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcmN8fGUuaHJlZn0pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZX0pO3JldHVybiB0Lmxlbmd0aD4wJiYoZS5fdHJhY2tfc3RhdGljPXQpLGUuX21vdW50cz10aGlzLmpvaW5Db3VudCxlfX0se2tleTpcIm5hbWVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXd9fSx7a2V5OlwiaXNDb25uZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoYW5uZWwuY2FuUHVzaCgpfX0se2tleTpcImdldFNlc3Npb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXNlc3Npb25cIil9fSx7a2V5OlwiZ2V0U3RhdGljXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmVsLmdldEF0dHJpYnV0ZShGKTtyZXR1cm5cIlwiPT09ZT9udWxsOmV9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpmdW5jdGlvbigpe307dGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKSx0aGlzLmRlc3Ryb3llZD0hMCxkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdLHRoaXMucGFyZW50JiZkZWxldGUgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMucGFyZW50LmlkXVt0aGlzLmlkXSxjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7dmFyIG49ZnVuY3Rpb24oKXtmb3IodmFyIG4gaW4gdCgpLGUudmlld0hvb2tzKWUudmlld0hvb2tzW25dLl9fdHJpZ2dlcl9fKFwiYmVmb3JlRGVzdHJveVwiKSxlLmRlc3Ryb3lIb29rKGUudmlld0hvb2tzW25dKX07dGhpcy5sb2coXCJkZXN0cm95ZWRcIixmdW5jdGlvbigpe3JldHVybltcInRoZSBjaGlsZCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudFwiXX0pLHRoaXMuY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLG4pLnJlY2VpdmUoXCJlcnJvclwiLG4pLnJlY2VpdmUoXCJ0aW1lb3V0XCIsbil9fSx7a2V5Olwic2V0Q29udGFpbmVyQ2xhc3Nlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU7dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwicGh4LWNvbm5lY3RlZFwiLFwicGh4LWRpc2Nvbm5lY3RlZFwiLFwicGh4LWVycm9yXCIpLChlPXRoaXMuZWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoZSxhcmd1bWVudHMpfX0se2tleTpcImlzTG9hZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwicGh4LWRpc2Nvbm5lY3RlZFwiKX19LHtrZXk6XCJzaG93TG9hZGVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZihjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lciksZSl0aGlzLmxvYWRlclRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdC5zaG93TG9hZGVyKCl9LGUpO2Vsc2V7Zm9yKHZhciBuIGluIHRoaXMudmlld0hvb2tzKXRoaXMudmlld0hvb2tzW25dLl9fdHJpZ2dlcl9fKFwiZGlzY29ubmVjdGVkXCIpO3RoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhcInBoeC1kaXNjb25uZWN0ZWRcIil9fX0se2tleTpcImhpZGVMb2FkZXJcIix2YWx1ZTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKSx0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoXCJwaHgtY29ubmVjdGVkXCIpfX0se2tleTpcInRyaWdnZXJSZWNvbm5lY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMudmlld0hvb2tzKXRoaXMudmlld0hvb2tzW2VdLl9fdHJpZ2dlcl9fKFwicmVjb25uZWN0ZWRcIil9fSx7a2V5OlwibG9nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmxpdmVTb2NrZXQubG9nKHRoaXMsZSx0KX19LHtrZXk6XCJ3aXRoaW5UYXJnZXRzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO2lmKC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QoZSkpe3ZhciBpPXJlLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLGUpOzA9PT1pLmxlbmd0aD9LKFwibm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgXCIuY29uY2F0KGUpKTp0KHRoaXMsaVswXSl9ZWxzZXt2YXIgcj1BcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSkpOzA9PT1yLmxlbmd0aCYmSygnbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIicuY29uY2F0KGUsJ1wiJykpLHIuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gbi5saXZlU29ja2V0Lm93bmVyKGUsZnVuY3Rpb24obil7cmV0dXJuIHQobixlKX0pfSl9fX0se2tleTpcImFwcGx5RGlmZlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt0aGlzLmxvZyhlLGZ1bmN0aW9uKCl7cmV0dXJuW1wiXCIseih0KV19KTt2YXIgaT10ZS5leHRyYWN0KHQpLHI9aS5kaWZmLG89aS5yZXBseSxhPWkuZXZlbnRzLHU9aS50aXRsZTtyZXR1cm4gdSYmcmUucHV0VGl0bGUodSksbih7ZGlmZjpyLHJlcGx5Om8sZXZlbnRzOmF9KSxvfX0se2tleTpcIm9uSm9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1lLnJlbmRlcmVkO3RoaXMuam9pbkNvdW50KyssdGhpcy5jaGlsZEpvaW5zPTAsdGhpcy5qb2luUGVuZGluZz0hMCx0aGlzLmZsYXNoPW51bGwsaWUuZHJvcExvY2FsKHRoaXMubmFtZSgpLFwiY29uc2VjdXRpdmUtcmVsb2Fkc1wiKSx0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsbixmdW5jdGlvbihuKXt2YXIgaT1uLmRpZmYscj1uLmV2ZW50czt0LnJlbmRlcmVkPW5ldyB0ZSh0LmlkLGkpO3ZhciBvPXQucmVuZGVyQ29udGFpbmVyKG51bGwsXCJqb2luXCIpO3QuZHJvcFBlbmRpbmdSZWZzKCk7dmFyIGE9dC5mb3Jtc0ZvclJlY292ZXJ5KG8pO3Quam9pbkNvdW50PjEmJmEubGVuZ3RoPjA/YS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7dC5wdXNoRm9ybVJlY292ZXJ5KGUsZnVuY3Rpb24oZSl7bj09PWEubGVuZ3RoLTEmJnQub25Kb2luQ29tcGxldGUoZSxvLHIpfSl9KTp0Lm9uSm9pbkNvbXBsZXRlKGUsbyxyKX0pfX0se2tleTpcImRyb3BQZW5kaW5nUmVmc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmUuYWxsKHRoaXMuZWwsXCJbXCIuY29uY2F0KE0sXCJdXCIpLGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbW92ZUF0dHJpYnV0ZShNKX0pfX0se2tleTpcIm9uSm9pbkNvbXBsZXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj1lLmxpdmVfcGF0Y2g7aWYodGhpcy5qb2luQ291bnQ+MXx8dGhpcy5wYXJlbnQmJiF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gocix0LG4pOzA9PT1yZS5maW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KHQsdGhpcy5pZCkuZmlsdGVyKGZ1bmN0aW9uKGUpe3ZhciB0PWUuaWQmJmkuZWwucXVlcnlTZWxlY3RvcihcIiNcIi5jb25jYXQoZS5pZCkpLG49dCYmdC5nZXRBdHRyaWJ1dGUoRik7cmV0dXJuIG4mJmUuc2V0QXR0cmlidXRlKEYsbiksaS5qb2luQ2hpbGQoZSl9KS5sZW5ndGg/dGhpcy5wYXJlbnQ/KHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGkuYXBwbHlKb2luUGF0Y2gocix0LG4pfV0pLHRoaXMucGFyZW50LmFja0pvaW4odGhpcykpOih0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCksdGhpcy5hcHBseUpvaW5QYXRjaChyLHQsbikpOnRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGkuYXBwbHlKb2luUGF0Y2gocix0LG4pfV0pfX0se2tleTpcImF0dGFjaFRydWVEb2NFbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5lbD1yZS5ieUlkKHRoaXMuaWQpLHRoaXMuZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcm9vdC1pZFwiLHRoaXMucm9vdC5pZCl9fSx7a2V5OlwiZGlzcGF0Y2hFdmVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9TChlLDIpLG49dFswXSxpPXRbMV07d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicGh4Omhvb2s6XCIuY29uY2F0KG4pLHtkZXRhaWw6aX0pKX0pfX0se2tleTpcImFwcGx5Sm9pblBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7dGhpcy5hdHRhY2hUcnVlRG9jRWwoKTt2YXIgcj1uZXcgYWUodGhpcyx0aGlzLmVsLHRoaXMuaWQsdCxudWxsKTtpZihyLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCksdGhpcy5wZXJmb3JtUGF0Y2gociwhMSksdGhpcy5qb2luTmV3Q2hpbGRyZW4oKSxyZS5hbGwodGhpcy5lbCxcIltcIi5jb25jYXQodGhpcy5iaW5kaW5nKFwiaG9va1wiKSxcIl1cIiksZnVuY3Rpb24oZSl7dmFyIHQ9aS5hZGRIb29rKGUpO3QmJnQuX190cmlnZ2VyX18oXCJtb3VudGVkXCIpfSksdGhpcy5qb2luUGVuZGluZz0hMSx0aGlzLmRpc3BhdGNoRXZlbnRzKG4pLHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpLGUpe3ZhciBvPWUua2luZCxhPWUudG87dGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaChhLG8pfXRoaXMuaGlkZUxvYWRlcigpLHRoaXMuam9pbkNvdW50PjEmJnRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCksdGhpcy5zdG9wQ2FsbGJhY2soKX19LHtrZXk6XCJ0cmlnZ2VyQmVmb3JlVXBkYXRlSG9va1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLFtlLHRdKTt2YXIgbj10aGlzLmdldEhvb2soZSksaT1uJiZcImlnbm9yZVwiPT09ZS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidXBkYXRlXCIpKTtpZihuJiYhZS5pc0VxdWFsTm9kZSh0KSYmKCFpfHwhZnVuY3Rpb24oZSx0KXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSk9PT1KU09OLnN0cmluZ2lmeSh0KX0oZS5kYXRhc2V0LHQuZGF0YXNldCkpKXJldHVybiBuLl9fdHJpZ2dlcl9fKFwiYmVmb3JlVXBkYXRlXCIpLG59fSx7a2V5OlwidHJpZ2dlclVwZGF0ZWRIb29rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5fX3RyaWdnZXJfXyhcInVwZGF0ZWRcIil9fSx7a2V5OlwicGVyZm9ybVBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9W10scj0hMSxvPW5ldyBTZXQ7cmV0dXJuIGUuYWZ0ZXIoXCJhZGRlZFwiLGZ1bmN0aW9uKGUpe3ZhciB0PW4uYWRkSG9vayhlKTt0JiZ0Ll9fdHJpZ2dlcl9fKFwibW91bnRlZFwiKX0pLGUuYWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHI9ITB9KSxlLmJlZm9yZShcInVwZGF0ZWRcIixmdW5jdGlvbihlLHQpe24udHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZSx0KSYmby5hZGQoZS5pZCl9KSxlLmFmdGVyKFwidXBkYXRlZFwiLGZ1bmN0aW9uKGUpe28uaGFzKGUuaWQpJiZuLnRyaWdnZXJVcGRhdGVkSG9vayhuLmdldEhvb2soZSkpfSksZS5iZWZvcmUoXCJkaXNjYXJkZWRcIixmdW5jdGlvbihlKXt2YXIgdD1uLmdldEhvb2soZSk7dCYmdC5fX3RyaWdnZXJfXyhcImJlZm9yZURlc3Ryb3lcIil9KSxlLmFmdGVyKFwiZGlzY2FyZGVkXCIsZnVuY3Rpb24oZSl7dmFyIHQ9bi5jb21wb25lbnRJRChlKTtcIm51bWJlclwiPT10eXBlb2YgdCYmLTE9PT1pLmluZGV4T2YodCkmJmkucHVzaCh0KTt2YXIgcj1uLmdldEhvb2soZSk7ciYmbi5kZXN0cm95SG9vayhyKX0pLGUucGVyZm9ybSgpLHQmJnRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChpKSxyfX0se2tleTpcImpvaW5OZXdDaGlsZHJlblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZS5maW5kUGh4Q2hpbGRyZW4odGhpcy5lbCx0aGlzLmlkKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmpvaW5DaGlsZCh0KX0pfX0se2tleTpcImdldENoaWxkQnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bZV19fSx7a2V5OlwiZ2V0RGVzY2VuZGVudEJ5RWxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXRoaXMuaWQ/dGhpczp0aGlzLmNoaWxkcmVuW2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcGFyZW50LWlkXCIpXVtlLmlkXX19LHtrZXk6XCJkZXN0cm95RGVzY2VuZGVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pZm9yKHZhciBuIGluIHRoaXMucm9vdC5jaGlsZHJlblt0XSlpZihuPT09ZSlyZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RdW25dLmRlc3Ryb3koKX19LHtrZXk6XCJqb2luQ2hpbGRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdGhpcy5nZXRDaGlsZEJ5SWQodC5pZCkpe3ZhciBuPW5ldyBlKHQsdGhpcy5saXZlU29ja2V0LHRoaXMpO3JldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bbi5pZF09bixuLmpvaW4oKSx0aGlzLmNoaWxkSm9pbnMrKywhMH19fSx7a2V5OlwiaXNKb2luUGVuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblBlbmRpbmd9fSx7a2V5OlwiYWNrSm9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2hpbGRKb2lucy0tLDA9PT10aGlzLmNoaWxkSm9pbnMmJih0aGlzLnBhcmVudD90aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpOnRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSl9fSx7a2V5Olwib25BbGxDaGlsZEpvaW5zQ29tcGxldGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuam9pbkNhbGxiYWNrKCksdGhpcy5wZW5kaW5nSm9pbk9wcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PUwoZSwyKSxuPXRbMF0saT10WzFdO24uaXNEZXN0cm95ZWQoKXx8aSgpfSksdGhpcy5wZW5kaW5nSm9pbk9wcz1bXX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYodGhpcy5pc0pvaW5QZW5kaW5nKCl8fHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpKXJldHVybiB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKHtkaWZmOmUsZXZlbnRzOnR9KTt0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihlKTt2YXIgaT0hMTt0aGlzLnJlbmRlcmVkLmlzQ29tcG9uZW50T25seURpZmYoZSk/dGhpcy5saXZlU29ja2V0LnRpbWUoXCJjb21wb25lbnQgcGF0Y2ggY29tcGxldGVcIixmdW5jdGlvbigpe3JlLmZpbmRQYXJlbnRDSURzKG4uZWwsbi5yZW5kZXJlZC5jb21wb25lbnRDSURzKGUpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe24uY29tcG9uZW50UGF0Y2gobi5yZW5kZXJlZC5nZXRDb21wb25lbnQoZSx0KSx0KSYmKGk9ITApfSl9KTpRKGUpfHx0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIixmdW5jdGlvbigpe3ZhciB0PW4ucmVuZGVyQ29udGFpbmVyKGUsXCJ1cGRhdGVcIikscj1uZXcgYWUobixuLmVsLG4uaWQsdCxudWxsKTtpPW4ucGVyZm9ybVBhdGNoKHIsITApfSksdGhpcy5kaXNwYXRjaEV2ZW50cyh0KSxpJiZ0aGlzLmpvaW5OZXdDaGlsZHJlbigpfX0se2tleTpcInJlbmRlckNvbnRhaW5lclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoXCJ0b1N0cmluZyBkaWZmIChcIi5jb25jYXQodCxcIilcIiksZnVuY3Rpb24oKXt2YXIgdD1uLmVsLnRhZ05hbWUsaT1lP24ucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhlKTpudWxsLHI9bi5yZW5kZXJlZC50b1N0cmluZyhpKTtyZXR1cm5cIjxcIi5jb25jYXQodCxcIj5cIikuY29uY2F0KHIsXCI8L1wiKS5jb25jYXQodCxcIj5cIil9KX19LHtrZXk6XCJjb21wb25lbnRQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoUShlKSlyZXR1cm4hMTt2YXIgbj10aGlzLnJlbmRlcmVkLmNvbXBvbmVudFRvU3RyaW5nKHQpLGk9bmV3IGFlKHRoaXMsdGhpcy5lbCx0aGlzLmlkLG4sdCk7cmV0dXJuIHRoaXMucGVyZm9ybVBhdGNoKGksITApfX0se2tleTpcImdldEhvb2tcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy52aWV3SG9va3Nbc2UuZWxlbWVudElEKGUpXX19LHtrZXk6XCJhZGRIb29rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIXNlLmVsZW1lbnRJRChlKSYmZS5nZXRBdHRyaWJ1dGUpe3ZhciB0PWUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImhvb2tcIikpO2lmKCF0fHx0aGlzLm93bnNFbGVtZW50KGUpKXt2YXIgbj10aGlzLmxpdmVTb2NrZXQuZ2V0SG9va0NhbGxiYWNrcyh0KTtpZihuKXtlLmlkfHxLKCdubyBET00gSUQgZm9yIGhvb2sgXCInLmNvbmNhdCh0LCdcIi4gSG9va3MgcmVxdWlyZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIGVsZW1lbnQuJyksZSk7dmFyIGk9bmV3IHNlKHRoaXMsZSxuKTtyZXR1cm4gdGhpcy52aWV3SG9va3Nbc2UuZWxlbWVudElEKGkuZWwpXT1pLGl9bnVsbCE9PXQmJksoJ3Vua25vd24gaG9vayBmb3VuZCBmb3IgXCInLmNvbmNhdCh0LCdcIicpLGUpfX19fSx7a2V5OlwiZGVzdHJveUhvb2tcIix2YWx1ZTpmdW5jdGlvbihlKXtlLl9fdHJpZ2dlcl9fKFwiZGVzdHJveWVkXCIpLGUuX19jbGVhbnVwX18oKSxkZWxldGUgdGhpcy52aWV3SG9va3Nbc2UuZWxlbWVudElEKGUuZWwpXX19LHtrZXk6XCJhcHBseVBlbmRpbmdVcGRhdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49dC5kaWZmLGk9dC5ldmVudHM7cmV0dXJuIGUudXBkYXRlKG4saSl9KSx0aGlzLnBlbmRpbmdEaWZmcz1bXX19LHtrZXk6XCJvbkNoYW5uZWxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7dGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsZSxmdW5jdGlvbihlKXtuLmlzSm9pblBlbmRpbmcoKT9uLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbbixmdW5jdGlvbigpe3JldHVybiB0KGUpfV0pOnQoZSl9KX19LHtrZXk6XCJiaW5kQ2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCxcImRpZmZcIixmdW5jdGlvbih0KXtlLmFwcGx5RGlmZihcInVwZGF0ZVwiLHQsZnVuY3Rpb24odCl7dmFyIG49dC5kaWZmLGk9dC5ldmVudHM7cmV0dXJuIGUudXBkYXRlKG4saSl9KX0pLHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIixmdW5jdGlvbih0KXt2YXIgbj10LnRvLGk9dC5mbGFzaDtyZXR1cm4gZS5vblJlZGlyZWN0KHt0bzpuLGZsYXNoOml9KX0pLHRoaXMub25DaGFubmVsKFwibGl2ZV9wYXRjaFwiLGZ1bmN0aW9uKHQpe3JldHVybiBlLm9uTGl2ZVBhdGNoKHQpfSksdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsZnVuY3Rpb24odCl7cmV0dXJuIGUub25MaXZlUmVkaXJlY3QodCl9KSx0aGlzLmNoYW5uZWwub25FcnJvcihmdW5jdGlvbih0KXtyZXR1cm4gZS5vbkVycm9yKHQpfSksdGhpcy5jaGFubmVsLm9uQ2xvc2UoZnVuY3Rpb24oKXtyZXR1cm4gZS5vbkNsb3NlKCl9KX19LHtrZXk6XCJkZXN0cm95QWxsQ2hpbGRyZW5cIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZSBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0pdGhpcy5nZXRDaGlsZEJ5SWQoZSkuZGVzdHJveSgpfX0se2tleTpcIm9uTGl2ZVJlZGlyZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50byxuPWUua2luZCxpPWUuZmxhc2gscj10aGlzLmV4cGFuZFVSTCh0KTt0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KHIsbixpKX19LHtrZXk6XCJvbkxpdmVQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudG8sbj1lLmtpbmQ7dGhpcy5ocmVmPXRoaXMuZXhwYW5kVVJMKHQpLHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godCxuKX19LHtrZXk6XCJleHBhbmRVUkxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5zdGFydHNXaXRoKFwiL1wiKT9cIlwiLmNvbmNhdCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wsXCIvL1wiKS5jb25jYXQod2luZG93LmxvY2F0aW9uLmhvc3QpLmNvbmNhdChlKTplfX0se2tleTpcIm9uUmVkaXJlY3RcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRvLG49ZS5mbGFzaDt0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3QodCxuKX19LHtrZXk6XCJpc0Rlc3Ryb3llZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVzdHJveWVkfX0se2tleTpcImpvaW5cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMucGFyZW50fHwodGhpcy5zdG9wQ2FsbGJhY2s9dGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7dG86dGhpcy5ocmVmLGtpbmQ6XCJpbml0aWFsXCJ9KSksdGhpcy5qb2luQ2FsbGJhY2s9ZnVuY3Rpb24oKXtyZXR1cm4gZSYmZSh0LHQuam9pbkNvdW50KX0sdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY2hhbm5lbC5qb2luKCkucmVjZWl2ZShcIm9rXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQub25Kb2luKGUpfSkucmVjZWl2ZShcImVycm9yXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQub25Kb2luRXJyb3IoZSl9KS5yZWNlaXZlKFwidGltZW91dFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHQub25Kb2luRXJyb3Ioe3JlYXNvbjpcInRpbWVvdXRcIn0pfSl9KX19LHtrZXk6XCJvbkpvaW5FcnJvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybihlLnJlZGlyZWN0fHxlLmxpdmVfcmVkaXJlY3QpJiYodGhpcy5qb2luUGVuZGluZz0hMSx0aGlzLmNoYW5uZWwubGVhdmUoKSksZS5yZWRpcmVjdD90aGlzLm9uUmVkaXJlY3QoZS5yZWRpcmVjdCk6ZS5saXZlX3JlZGlyZWN0P3RoaXMub25MaXZlUmVkaXJlY3QoZS5saXZlX3JlZGlyZWN0KToodGhpcy5sb2coXCJlcnJvclwiLGZ1bmN0aW9uKCl7cmV0dXJuW1widW5hYmxlIHRvIGpvaW5cIixlXX0pLHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpKX19LHtrZXk6XCJvbkNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighdGhpcy5pc0Rlc3Ryb3llZCgpKXtpZih0aGlzLmlzSm9pblBlbmRpbmcoKXx8dGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkpcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO3RoaXMuZGVzdHJveUFsbENoaWxkcmVuKCksdGhpcy5saXZlU29ja2V0LmRyb3BBY3RpdmVFbGVtZW50KHRoaXMpLGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpLHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkmJnRoaXMuc2hvd0xvYWRlcigyMDApfX19LHtrZXk6XCJvbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5vbkNsb3NlKCksdGhpcy5sb2coXCJlcnJvclwiLGZ1bmN0aW9uKCl7cmV0dXJuW1widmlldyBjcmFzaGVkXCIsZV19KSx0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpfHx0aGlzLmRpc3BsYXlFcnJvcigpfX0se2tleTpcImRpc3BsYXlFcnJvclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc01haW4oKSYmcmUuZGlzcGF0Y2hFdmVudCh3aW5kb3csXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIse3RvOnRoaXMuaHJlZixraW5kOlwiZXJyb3JcIn0pLHRoaXMuc2hvd0xvYWRlcigpLHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhcInBoeC1kaXNjb25uZWN0ZWRcIixcInBoeC1lcnJvclwiKX19LHtrZXk6XCJwdXNoV2l0aFJlcGx5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106ZnVuY3Rpb24oKXt9LG89TChlP2UoKTpbbnVsbCxbXV0sMiksYT1vWzBdLHU9TChvWzFdLDEpWzBdLGM9ZnVuY3Rpb24oKXt9O3JldHVybiB1JiZudWxsIT09dS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwicGFnZS1sb2FkaW5nXCIpKSYmKGM9dGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7a2luZDpcImVsZW1lbnRcIix0YXJnZXQ6dX0pKSxcIm51bWJlclwiIT10eXBlb2Ygbi5jaWQmJmRlbGV0ZSBuLmNpZCx0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2goZnVuY3Rpb24oKXtyZXR1cm4gaS5jaGFubmVsLnB1c2godCxuLDNlNCkucmVjZWl2ZShcIm9rXCIsZnVuY3Rpb24oZSl7dmFyIHQ9bnVsbDtudWxsIT09YSYmaS51bmRvUmVmcyhhKSxlLmRpZmYmJih0PWkuYXBwbHlEaWZmKFwidXBkYXRlXCIsZS5kaWZmLGZ1bmN0aW9uKGUpe3ZhciB0PWUuZGlmZixuPWUuZXZlbnRzO2kudXBkYXRlKHQsbil9KSksZS5yZWRpcmVjdCYmaS5vblJlZGlyZWN0KGUucmVkaXJlY3QpLGUubGl2ZV9wYXRjaCYmaS5vbkxpdmVQYXRjaChlLmxpdmVfcGF0Y2gpLGUubGl2ZV9yZWRpcmVjdCYmaS5vbkxpdmVSZWRpcmVjdChlLmxpdmVfcmVkaXJlY3QpLGMoKSxyKGUsdCl9KX0pfX0se2tleTpcInVuZG9SZWZzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZS5hbGwodGhpcy5lbCxcIltcIi5jb25jYXQoTSwnPVwiJykuY29uY2F0KGUsJ1wiXScpLGZ1bmN0aW9uKGUpe2UucmVtb3ZlQXR0cmlidXRlKE0pLG51bGwhPT1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXJlYWRvbmx5XCIpJiYoZS5yZWFkT25seT0hMSxlLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtcGh4LXJlYWRvbmx5XCIpKSxudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1kaXNhYmxlZFwiKSYmKGUuZGlzYWJsZWQ9ITEsZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXBoeC1kaXNhYmxlZFwiKSksSC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiByZS5yZW1vdmVDbGFzcyhlLHQpfSk7dmFyIG49ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1kaXNhYmxlLXdpdGgtcmVzdG9yZVwiKTtudWxsIT09biYmKGUuaW5uZXJUZXh0PW4sZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXBoeC1kaXNhYmxlLXdpdGgtcmVzdG9yZVwiKSk7dmFyIGk9cmUucHJpdmF0ZShlLE0pO2lmKGkpe3ZhciByPXQudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZSxpKTthZS5wYXRjaEVsKGUsaSx0LmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKSxyJiZ0LnRyaWdnZXJVcGRhdGVkSG9vayhyKSxyZS5kZWxldGVQcml2YXRlKGUsTSl9fSl9fSx7a2V5OlwicHV0UmVmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLnJlZisrLGk9dGhpcy5iaW5kaW5nKFwiZGlzYWJsZS13aXRoXCIpO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5jbGFzc0xpc3QuYWRkKFwicGh4LVwiLmNvbmNhdCh0LFwiLWxvYWRpbmdcIikpLGUuc2V0QXR0cmlidXRlKE0sbik7dmFyIHI9ZS5nZXRBdHRyaWJ1dGUoaSk7bnVsbCE9PXImJihlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCIpfHxlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCIsZS5pbm5lclRleHQpLGUuaW5uZXJUZXh0PXIpfSksW24sZV19fSx7a2V5OlwiY29tcG9uZW50SURcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoaik7cmV0dXJuIHQ/cGFyc2VJbnQodCk6bnVsbH19LHtrZXk6XCJ0YXJnZXRDb21wb25lbnRJRFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSk/dGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodCk6bnVsbH19LHtrZXk6XCJjbG9zZXN0Q29tcG9uZW50SURcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlP1ooZS5jbG9zZXN0KFwiW1wiLmNvbmNhdChqLFwiXVwiKSksZnVuY3Rpb24oZSl7cmV0dXJuIHQub3duc0VsZW1lbnQoZSkmJnQuY29tcG9uZW50SUQoZSl9KTpudWxsfX0se2tleTpcInB1c2hIb29rRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXt2YXIgcj1MKHRoaXMucHV0UmVmKFtdLFwiaG9va1wiKSwyKSxvPXJbMF0sYT1yWzFdO3JldHVybiB0aGlzLnB1c2hXaXRoUmVwbHkoZnVuY3Rpb24oKXtyZXR1cm5bbyxhXX0sXCJldmVudFwiLHt0eXBlOlwiaG9va1wiLGV2ZW50OnQsdmFsdWU6bixjaWQ6dGhpcy5jbG9zZXN0Q29tcG9uZW50SUQoZSl9LGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGkodCxvKX0pLG99fSx7a2V5OlwiZXh0cmFjdE1ldGFcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIiksaT0wO2k8ZS5hdHRyaWJ1dGVzLmxlbmd0aDtpKyspe3ZhciByPWUuYXR0cmlidXRlc1tpXS5uYW1lO3Iuc3RhcnRzV2l0aChuKSYmKHRbci5yZXBsYWNlKG4sXCJcIildPWUuZ2V0QXR0cmlidXRlKHIpKX1yZXR1cm4gdm9pZCAwIT09ZS52YWx1ZSYmKHQudmFsdWU9ZS52YWx1ZSxcIklOUFVUXCI9PT1lLnRhZ05hbWUmJkouaW5kZXhPZihlLnR5cGUpPj0wJiYhZS5jaGVja2VkJiZkZWxldGUgdC52YWx1ZSksdH19LHtrZXk6XCJwdXNoRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLHIpe3ZhciBvPXRoaXM7dGhpcy5wdXNoV2l0aFJlcGx5KGZ1bmN0aW9uKCl7cmV0dXJuIG8ucHV0UmVmKFt0XSxlKX0sXCJldmVudFwiLHt0eXBlOmUsZXZlbnQ6aSx2YWx1ZTp0aGlzLmV4dHJhY3RNZXRhKHQsciksY2lkOnRoaXMudGFyZ2V0Q29tcG9uZW50SUQodCxuKX0pfX0se2tleTpcInB1c2hLZXlcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLHIpe3ZhciBvPXRoaXM7dGhpcy5wdXNoV2l0aFJlcGx5KGZ1bmN0aW9uKCl7cmV0dXJuIG8ucHV0UmVmKFtlXSxuKX0sXCJldmVudFwiLHt0eXBlOm4sZXZlbnQ6aSx2YWx1ZTp0aGlzLmV4dHJhY3RNZXRhKGUsciksY2lkOnRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZSx0KX0pfX0se2tleTpcInB1c2hJbnB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkscil7dmFyIG89dGhpczt0aGlzLnB1c2hXaXRoUmVwbHkoZnVuY3Rpb24oKXtyZXR1cm4gby5wdXRSZWYoW2UsZS5mb3JtXSxcImNoYW5nZVwiKX0sXCJldmVudFwiLHt0eXBlOlwiZm9ybVwiLGV2ZW50Om4sdmFsdWU6ZWUoZS5mb3JtLHtfdGFyZ2V0OmkubmFtZX0pLGNpZDp0aGlzLnRhcmdldENvbXBvbmVudElEKGUuZm9ybSx0KX0scil9fSx7a2V5OlwicHVzaEZvcm1TdWJtaXRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXt2YXIgcj10aGlzLG89ZnVuY3Rpb24oZSl7cmV0dXJuIUcoZSxcIlwiLmNvbmNhdChyLmJpbmRpbmcoXCJ1cGRhdGVcIiksXCI9aWdub3JlXCIpLGUuZm9ybSl9O3RoaXMucHVzaFdpdGhSZXBseShmdW5jdGlvbigpe3ZhciB0PXJlLmFsbChlLFwiW1wiLmNvbmNhdChyLmJpbmRpbmcoXCJkaXNhYmxlLXdpdGhcIiksXCJdXCIpKSxuPXJlLmFsbChlLFwiYnV0dG9uXCIpLmZpbHRlcihvKSxpPXJlLmFsbChlLFwiaW5wdXQsdGV4dGFyZWEsc2VsZWN0XCIpLmZpbHRlcihvKTtyZXR1cm4gbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZWRcIixlLmRpc2FibGVkKSxlLmRpc2FibGVkPSEwfSksaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcmVhZG9ubHlcIixlLnJlYWRPbmx5KSxlLnJlYWRPbmx5PSEwfSksZS5zZXRBdHRyaWJ1dGUoci5iaW5kaW5nKFwicGFnZS1sb2FkaW5nXCIpLFwiXCIpLHIucHV0UmVmKFtlXS5jb25jYXQodCkuY29uY2F0KG4pLmNvbmNhdChpKSxcInN1Ym1pdFwiKX0sXCJldmVudFwiLHt0eXBlOlwiZm9ybVwiLGV2ZW50Om4sdmFsdWU6ZWUoZSksY2lkOnRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZSx0KX0saSl9fSx7a2V5OlwicHVzaEZvcm1SZWNvdmVyeVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpczt0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGUsZnVuY3Rpb24oaSxyKXt2YXIgbz1lLmVsZW1lbnRzWzBdLGE9ZS5nZXRBdHRyaWJ1dGUobi5iaW5kaW5nKFwiYXV0by1yZWNvdmVyXCIpKXx8ZS5nZXRBdHRyaWJ1dGUobi5iaW5kaW5nKFwiY2hhbmdlXCIpKTtpLnB1c2hJbnB1dChvLHIsYSxvLHQpfSl9fSx7a2V5OlwicHVzaExpbmtQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzLHI9dGhpcy5saXZlU29ja2V0LnNldFBlbmRpbmdMaW5rKGUpLG89dD9mdW5jdGlvbigpe3JldHVybiBpLnB1dFJlZihbdF0sXCJjbGlja1wiKX06bnVsbDt0aGlzLnB1c2hXaXRoUmVwbHkobyxcImxpbmtcIix7dXJsOmV9LGZ1bmN0aW9uKHQpe3QubGlua19yZWRpcmVjdD9pLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oZSxudWxsLG4scik6aS5saXZlU29ja2V0LmNvbW1pdFBlbmRpbmdMaW5rKHIpJiYoaS5ocmVmPWUsaS5hcHBseVBlbmRpbmdVcGRhdGVzKCksbiYmbigpKX0pLnJlY2VpdmUoXCJ0aW1lb3V0XCIsZnVuY3Rpb24oKXtyZXR1cm4gaS5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKX0pfX0se2tleTpcImZvcm1zRm9yUmVjb3ZlcnlcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49dGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpLGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiBpLmlubmVySFRNTD1lLHJlLmFsbCh0aGlzLmVsLFwiZm9ybVtcIi5jb25jYXQobixcIl1cIikpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gdC5vd25zRWxlbWVudChlKX0pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm5cImlnbm9yZVwiIT09ZS5nZXRBdHRyaWJ1dGUodC5iaW5kaW5nKFwiYXV0by1yZWNvdmVyXCIpKX0pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gaS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJmb3JtW1wiLmNvbmNhdChuLCc9XCInKS5jb25jYXQoZS5nZXRBdHRyaWJ1dGUobiksJ1wiXScpKX0pfX0se2tleTpcIm1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIDA9PT1yZS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodC5lbCxlKS5sZW5ndGh9KTtuLmxlbmd0aD4wJiZ0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCxcImNpZHNfZGVzdHJveWVkXCIse2NpZHM6bn0sZnVuY3Rpb24oKXt0LnJlbmRlcmVkLnBydW5lQ0lEcyhuKX0pfX0se2tleTpcIm93bnNFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcGFyZW50LWlkXCIpPT09dGhpcy5pZHx8WihlLmNsb3Nlc3QoQiksZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KT09PXRoaXMuaWR9fSx7a2V5Olwic3VibWl0Rm9ybVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzO3JlLnB1dFByaXZhdGUoZSxcInBoeC1oYXMtc3VibWl0dGVkXCIsITApLHRoaXMubGl2ZVNvY2tldC5ibHVyQWN0aXZlRWxlbWVudCh0aGlzKSx0aGlzLnB1c2hGb3JtU3VibWl0KGUsdCxuLGZ1bmN0aW9uKCl7aS5saXZlU29ja2V0LnJlc3RvcmVQcmV2aW91c2x5QWN0aXZlRm9jdXMoKX0pfX0se2tleTpcImJpbmRpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoZSl9fV0pLGV9KCksY2U9MSxzZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkpe2Zvcih2YXIgciBpbiBTKHRoaXMsZSksdGhpcy5fX3ZpZXc9dCx0aGlzLl9fbGl2ZVNvY2tldD10LmxpdmVTb2NrZXQsdGhpcy5fX2NhbGxiYWNrcz1pLHRoaXMuX19saXN0ZW5lcnM9bmV3IFNldCx0aGlzLmVsPW4sdGhpcy52aWV3TmFtZT10Lm5hbWUoKSx0aGlzLmVsLnBoeEhvb2tJZD10aGlzLmNvbnN0cnVjdG9yLm1ha2VJRCgpLHRoaXMuX19jYWxsYmFja3MpdGhpc1tyXT10aGlzLl9fY2FsbGJhY2tzW3JdfXJldHVybiBQKGUsbnVsbCxbe2tleTpcIm1ha2VJRFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGNlKyt9fSx7a2V5OlwiZWxlbWVudElEXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucGh4SG9va0lkfX1dKSxQKGUsW3trZXk6XCJwdXNoRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06ZnVuY3Rpb24oKXt9O3JldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsZSx0LG4pfX0se2tleTpcInB1c2hFdmVudFRvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30saT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106ZnVuY3Rpb24oKXt9O3JldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKGUsZnVuY3Rpb24oZSxyKXtyZXR1cm4gZS5wdXNoSG9va0V2ZW50KHIsdCxuLGkpfSl9fSx7a2V5OlwiaGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWZ1bmN0aW9uKG4saSl7cmV0dXJuIGk/ZTp0KG4uZGV0YWlsKX07cmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4Omhvb2s6XCIuY29uY2F0KGUpLG4pLHRoaXMuX19saXN0ZW5lcnMuYWRkKG4pLG59fSx7a2V5OlwicmVtb3ZlSGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lKG51bGwsITApO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGh4Omhvb2s6XCIuY29uY2F0KHQpLGUpLHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGUpfX0se2tleTpcIl9fY2xlYW51cF9fXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuX19saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5yZW1vdmVIYW5kbGVFdmVudCh0KX0pfX0se2tleTpcIl9fdHJpZ2dlcl9fXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fX2NhbGxiYWNrc1tlXTt0JiZ0LmNhbGwodGhpcyl9fV0pLGV9KCk7dC5kZWZhdWx0PW5lfSxmdW5jdGlvbihlLHQpe3ZhciBuO249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7bj1ufHxGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl8fCgwLGV2YWwpKFwidGhpc1wiKX1jYXRjaChlKXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYobj13aW5kb3cpfWUuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsbil7KGZ1bmN0aW9uKHQpe3QuUGhvZW5peHx8KHQuUGhvZW5peD17fSksZS5leHBvcnRzPXQuUGhvZW5peC5MaXZlVmlldz1uKDApfSkuY2FsbCh0aGlzLG4oMSkpfV0pfSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix_live_view/priv/static/phoenix_live_view.js\n");

/***/ }),

/***/ "./css/app.scss":
/*!**********************!*\
  !*** ./css/app.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXBwLnNjc3M/MjQyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/app.scss\n");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.scss */ \"./css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nprogress */ \"./node_modules/nprogress/nprogress.js\");\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(nprogress__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! phoenix_live_view */ \"../deps/phoenix_live_view/priv/static/phoenix_live_view.js\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chart */ \"./js/chart.js\");\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import deps with the dep name or local files with a relative path, for example:\n//\n//     import {Socket} from \"phoenix\"\n//     import socket from \"./socket\"\n//\n\n\n\n\n\n\nvar csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\");\nvar Hooks = {\n  ChartData: _chart__WEBPACK_IMPORTED_MODULE_5__[\"ChartData\"]\n};\nvar liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__[\"LiveSocket\"](\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"], {\n  hooks: Hooks,\n  params: {\n    _csrf_token: csrfToken\n  }\n}); // Show progress bar on live navigation and form submits\n\nwindow.addEventListener(\"phx:page-loading-start\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.start();\n});\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.done();\n}); // connect if there are any LiveViews on the page\n\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\n// >> liveSocket.disableLatencySim()\n\nwindow.liveSocket = liveSocket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/NzQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ1NTIHNvIHRoYXQgd2VicGFjayB3aWxsIGxvYWQgaXQuXG4vLyBUaGUgTWluaUNzc0V4dHJhY3RQbHVnaW4gaXMgdXNlZCB0byBzZXBhcmF0ZSBpdCBvdXQgaW50b1xuLy8gaXRzIG93biBDU1MgZmlsZS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuc2Nzc1wiXG5cbi8vIHdlYnBhY2sgYXV0b21hdGljYWxseSBidW5kbGVzIGFsbCBtb2R1bGVzIGluIHlvdXJcbi8vIGVudHJ5IHBvaW50cy4gVGhvc2UgZW50cnkgcG9pbnRzIGNhbiBiZSBjb25maWd1cmVkXG4vLyBpbiBcIndlYnBhY2suY29uZmlnLmpzXCIuXG4vL1xuLy8gSW1wb3J0IGRlcHMgd2l0aCB0aGUgZGVwIG5hbWUgb3IgbG9jYWwgZmlsZXMgd2l0aCBhIHJlbGF0aXZlIHBhdGgsIGZvciBleGFtcGxlOlxuLy9cbi8vICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuLy8gICAgIGltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0XCJcbi8vXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxuaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcInBob2VuaXhcIlxuaW1wb3J0IE5Qcm9ncmVzcyBmcm9tIFwibnByb2dyZXNzXCJcbmltcG9ydCB7IExpdmVTb2NrZXQgfSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuaW1wb3J0IHsgQ2hhcnREYXRhIH0gZnJvbSBcIi4vY2hhcnRcIlxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5cbmxldCBIb29rcyA9IHtcbiAgICBDaGFydERhdGE6IENoYXJ0RGF0YVxufVxuXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7IGhvb2tzOiBIb29rcywgcGFyYW1zOiB7IF9jc3JmX3Rva2VuOiBjc3JmVG9rZW4gfSB9KVxuXG4vLyBTaG93IHByb2dyZXNzIGJhciBvbiBsaXZlIG5hdmlnYXRpb24gYW5kIGZvcm0gc3VibWl0c1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8gPT4gTlByb2dyZXNzLnN0YXJ0KCkpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCBpbmZvID0+IE5Qcm9ncmVzcy5kb25lKCkpXG5cbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcbmxpdmVTb2NrZXQuY29ubmVjdCgpXG5cbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/app.js\n");

/***/ }),

/***/ "./js/chart.js":
/*!*********************!*\
  !*** ./js/chart.js ***!
  \*********************/
/*! exports provided: ChartData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChartData\", function() { return ChartData; });\n/* harmony import */ var uplot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uplot */ \"./node_modules/uplot/dist/uPlot.esm.js\");\n\nvar chart = null;\n\nfunction paths(u, sidx, i0, i1) {\n  var s = u.series[sidx];\n  var xdata = u.data[0];\n  var ydata = u.data[sidx];\n  var scaleX = 'x';\n  var scaleY = s.scale;\n  var stroke = new Path2D();\n  var step = 1; // 1 second, hard code for now, but we can make this dynamic in the future\n\n  var x_width = Math.abs((u.valToPos(step, scaleX, true) - u.valToPos(2 * step, scaleX, true)) / 2);\n  stroke.moveTo(Math.round(u.valToPos(xdata[0], scaleX, true)), Math.round(u.valToPos(ydata[0], scaleY, true)));\n\n  for (var i = i0; i < i1; i++) {\n    var x0 = Math.round(u.valToPos(xdata[i], scaleX, true));\n    var y0 = Math.round(u.valToPos(ydata[i], scaleY, true));\n    var x1 = Math.round(u.valToPos(xdata[i + 1], scaleX, true));\n    var y1 = Math.round(u.valToPos(ydata[i + 1], scaleY, true));\n    stroke.lineTo(x0 - x_width, y0);\n    stroke.lineTo(x1 - x_width, y0);\n\n    if (i == i1 - 1) {\n      // the last bit\n      stroke.lineTo(x1 - x_width, y1);\n      stroke.lineTo(x1, y1);\n    }\n  }\n\n  var fill = new Path2D(stroke);\n  var minY = Math.round(u.valToPos(u.scales[scaleY].min, scaleY, true));\n  var minX = Math.round(u.valToPos(u.scales[scaleX].min, scaleX, true));\n  var maxX = Math.round(u.valToPos(u.scales[scaleX].max, scaleX, true));\n  fill.lineTo(maxX, minY);\n  fill.lineTo(minX, minY);\n  return {\n    stroke: stroke,\n    fill: fill\n  };\n}\n\nfunction safe_to_fixed(number, decimals) {\n  return number && number.toFixed(decimals);\n}\n\nfunction create_chart(data, scale) {\n  var rect = {\n    width: window.innerWidth * 0.6,\n    height: 400\n  };\n  var scales = {};\n\n  if (scale == \"Log10\") {\n    scales = {\n      ms: {\n        distr: 3\n      },\n      reqs: {\n        distr: 3\n      }\n    };\n  }\n\n  var existing = document.getElementById(\"chart1\");\n  existing && existing.remove();\n  var opts = {\n    title: \"Web Request Response Time [ms]\",\n    id: \"chart1\",\n    \"class\": \"my-chart\",\n    width: rect.width,\n    height: rect.height,\n    labelSize: 100,\n    scales: scales,\n    labelFont: \"bold 8px Arial\",\n    font: \"8px Arial\",\n    axes: [{\n      grid: {\n        show: false\n      }\n    }, {\n      scale: \"ms\",\n      grid: {\n        show: false\n      },\n      values: function values(u, vals, space) {\n        return vals.map(function (val) {\n          return safe_to_fixed(val, 0) + \"ms\";\n        });\n      }\n    }, {\n      scale: \"reqs\",\n      side: 1,\n      values: function values(u, vals, space) {\n        return vals.map(function (val) {\n          return safe_to_fixed(val, 2) + \"reqs\";\n        });\n      },\n      grid: {\n        show: false\n      }\n    }],\n    series: [{\n      value: '{YYYY}-{MM}-{DD} {HH}:{mm}:{ss}'\n    }, {\n      label: \"P99\",\n      stroke: \"rgb(155, 214, 206)\",\n      value: function value(self, rawValue) {\n        return safe_to_fixed(rawValue, 3) + \"ms\";\n      },\n      fill: \"rgb(155, 214, 206, 0.5 )\",\n      paths: paths,\n      scale: \"ms\",\n      points: {\n        show: false\n      },\n      ticks: {\n        show: false\n      }\n    }, {\n      label: \"P90\",\n      stroke: \"rgb(79, 169, 184)\",\n      value: function value(self, rawValue) {\n        return safe_to_fixed(rawValue, 3) + \"ms\";\n      },\n      fill: \"rgb(79, 169, 184, 0.5)\",\n      paths: paths,\n      scale: \"ms\",\n      points: {\n        show: false\n      },\n      ticks: {\n        show: false\n      }\n    }, {\n      label: \"P50\",\n      stroke: \"rgb(2, 88, 115)\",\n      value: function value(self, rawValue) {\n        return safe_to_fixed(rawValue, 3) + \"ms\";\n      },\n      fill: \"rgb(2, 88, 115, 0.5)\",\n      paths: paths,\n      points: {\n        show: false\n      },\n      ticks: {\n        show: false\n      },\n      scale: \"ms\"\n    }, {\n      label: \"Throughput\",\n      stroke: \"rgb(30, 30, 30)\",\n      value: function value(self, rawValue) {\n        return rawValue + \"reqs\";\n      },\n      points: {\n        show: false\n      },\n      ticks: {\n        show: false\n      },\n      scale: \"reqs\"\n    }]\n  };\n  chart = new uplot__WEBPACK_IMPORTED_MODULE_0__[\"default\"](opts, data, document.getElementById(\"chart\"));\n}\n\nvar scale = \"\";\nvar ChartData = {\n  mounted: function mounted() {\n    scale = JSON.parse(this.el.dataset.scale);\n    var quantile_data = JSON.parse(this.el.dataset.quantile);\n    create_chart(quantile_data, scale);\n  },\n  updated: function updated() {\n    var new_scale = JSON.parse(this.el.dataset.scale);\n\n    if (scale == new_scale) {\n      var quantile_data = JSON.parse(this.el.dataset.quantile);\n      chart.setData(quantile_data, scale);\n    } else {\n      this.mounted();\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9jaGFydC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2pzL2NoYXJ0LmpzP2Y4YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVQbG90IGZyb20gJ3VwbG90J1xuXG5sZXQgY2hhcnQgPSBudWxsO1xuXG5mdW5jdGlvbiBwYXRocyh1LCBzaWR4LCBpMCwgaTEpIHtcblx0Y29uc3QgcyA9IHUuc2VyaWVzW3NpZHhdO1xuXHRjb25zdCB4ZGF0YSA9IHUuZGF0YVswXTtcblx0Y29uc3QgeWRhdGEgPSB1LmRhdGFbc2lkeF07XG5cdGNvbnN0IHNjYWxlWCA9ICd4Jztcblx0Y29uc3Qgc2NhbGVZID0gcy5zY2FsZTtcblxuXHRjb25zdCBzdHJva2UgPSBuZXcgUGF0aDJEKCk7XG5cbiAgbGV0IHN0ZXAgPSAxOyAvLyAxIHNlY29uZCwgaGFyZCBjb2RlIGZvciBub3csIGJ1dCB3ZSBjYW4gbWFrZSB0aGlzIGR5bmFtaWMgaW4gdGhlIGZ1dHVyZVxuXG4gIGNvbnN0IHhfd2lkdGggPSBNYXRoLmFicygodS52YWxUb1BvcyhzdGVwLCBzY2FsZVgsIHRydWUpIC0gdS52YWxUb1BvcygyICogc3RlcCwgc2NhbGVYLCB0cnVlKSkgLyAyKTtcblxuXHRzdHJva2UubW92ZVRvKFxuXHRcdE1hdGgucm91bmQodS52YWxUb1Bvcyh4ZGF0YVswXSwgc2NhbGVYLCB0cnVlKSksXG5cdFx0TWF0aC5yb3VuZCh1LnZhbFRvUG9zKHlkYXRhWzBdLCBzY2FsZVksIHRydWUpKVxuXHQpO1xuXG5cdGZvciAobGV0IGkgPSBpMDsgaSA8IGkxOyBpKyspIHtcblx0XHRsZXQgeDAgPSBNYXRoLnJvdW5kKHUudmFsVG9Qb3MoeGRhdGFbaV0sIHNjYWxlWCwgdHJ1ZSkpO1xuXHRcdGxldCB5MCA9IE1hdGgucm91bmQodS52YWxUb1Bvcyh5ZGF0YVtpXSwgc2NhbGVZLCB0cnVlKSk7XG5cdFx0bGV0IHgxID0gTWF0aC5yb3VuZCh1LnZhbFRvUG9zKHhkYXRhW2kgKyAxXSwgc2NhbGVYLCB0cnVlKSk7XG5cdFx0bGV0IHkxID0gTWF0aC5yb3VuZCh1LnZhbFRvUG9zKHlkYXRhW2kgKyAxXSwgc2NhbGVZLCB0cnVlKSk7XG5cbiAgICBzdHJva2UubGluZVRvKHgwIC0geF93aWR0aCwgeTApO1xuICAgIHN0cm9rZS5saW5lVG8oeDEgLSB4X3dpZHRoLCB5MCk7XG5cblx0XHRpZiAoaSA9PSBpMSAtIDEpIHtcbiAgICAgIC8vIHRoZSBsYXN0IGJpdFxuXHRcdFx0c3Ryb2tlLmxpbmVUbyh4MSAtIHhfd2lkdGgsIHkxKTtcblx0XHRcdHN0cm9rZS5saW5lVG8oeDEsIHkxKTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBmaWxsID0gbmV3IFBhdGgyRChzdHJva2UpO1xuXG5cdGxldCBtaW5ZID0gTWF0aC5yb3VuZCh1LnZhbFRvUG9zKHUuc2NhbGVzW3NjYWxlWV0ubWluLCBzY2FsZVksIHRydWUpKTtcblx0bGV0IG1pblggPSBNYXRoLnJvdW5kKHUudmFsVG9Qb3ModS5zY2FsZXNbc2NhbGVYXS5taW4sIHNjYWxlWCwgdHJ1ZSkpO1xuXHRsZXQgbWF4WCA9IE1hdGgucm91bmQodS52YWxUb1Bvcyh1LnNjYWxlc1tzY2FsZVhdLm1heCwgc2NhbGVYLCB0cnVlKSk7XG5cblx0ZmlsbC5saW5lVG8obWF4WCwgbWluWSk7XG5cdGZpbGwubGluZVRvKG1pblgsIG1pblkpO1xuXG5cdHJldHVybiB7XG5cdFx0c3Ryb2tlLFxuXHRcdGZpbGwsXG5cdH07XG59XG5cbmZ1bmN0aW9uIHNhZmVfdG9fZml4ZWQobnVtYmVyLCBkZWNpbWFscykge1xuXHRyZXR1cm4gbnVtYmVyICYmIG51bWJlci50b0ZpeGVkKGRlY2ltYWxzKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVfY2hhcnQoZGF0YSwgc2NhbGUpIHtcblx0bGV0IHJlY3QgPSB7IHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAqIDAuNiwgaGVpZ2h0OiA0MDAgfTtcblxuICBsZXQgc2NhbGVzID0ge307XG5cbiAgaWYgKHNjYWxlID09IFwiTG9nMTBcIikge1xuICAgIHNjYWxlcyA9IHtcbiAgICAgIG1zOiB7XG4gICAgICAgIGRpc3RyOiAzLFxuICAgICAgfSxcbiAgICAgIHJlcXM6IHtcbiAgICAgICAgZGlzdHI6IDNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXHRsZXQgZXhpc3RpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0MVwiKTtcblx0ZXhpc3RpbmcgJiYgZXhpc3RpbmcucmVtb3ZlKCk7XG5cblx0bGV0IG9wdHMgPSB7XG5cdFx0dGl0bGU6IFwiV2ViIFJlcXVlc3QgUmVzcG9uc2UgVGltZSBbbXNdXCIsXG5cdFx0aWQ6IFwiY2hhcnQxXCIsXG5cdFx0Y2xhc3M6IFwibXktY2hhcnRcIixcblx0XHR3aWR0aDogcmVjdC53aWR0aCxcblx0XHRoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuXHRcdGxhYmVsU2l6ZTogMTAwLFxuXHRcdHNjYWxlczogc2NhbGVzLFxuXHRcdGxhYmVsRm9udDogXCJib2xkIDhweCBBcmlhbFwiLFxuXHRcdGZvbnQ6IFwiOHB4IEFyaWFsXCIsXG5cdFx0YXhlczogW1xuXHRcdFx0eyBncmlkOiB7IHNob3c6IGZhbHNlIH19LFxuXHRcdFx0e1xuXHRcdFx0XHRzY2FsZTogXCJtc1wiLFxuXHRcdFx0XHRncmlkOiB7IHNob3c6IGZhbHNlIH0sXG5cdFx0XHRcdHZhbHVlczogKHUsIHZhbHMsIHNwYWNlKSA9PiB2YWxzLm1hcCgodmFsKSA9PiBzYWZlX3RvX2ZpeGVkKHZhbCwgMCkgKyBcIm1zXCIpLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0c2NhbGU6IFwicmVxc1wiLFxuXHRcdFx0XHRzaWRlOiAxLFxuXHRcdFx0XHR2YWx1ZXM6ICh1LCB2YWxzLCBzcGFjZSkgPT4gdmFscy5tYXAoKHZhbCkgPT4gc2FmZV90b19maXhlZCh2YWwsIDIpICsgXCJyZXFzXCIpLFxuXHRcdFx0XHRncmlkOiB7IHNob3c6IGZhbHNlIH0sXG5cdFx0XHR9LFxuXHRcdF0sXG5cdFx0c2VyaWVzOiBbXG5cdFx0XHR7IHZhbHVlOiAne1lZWVl9LXtNTX0te0REfSB7SEh9OnttbX06e3NzfScgfSxcblx0XHRcdHtcblx0XHRcdFx0bGFiZWw6IFwiUDk5XCIsXG5cdFx0XHRcdHN0cm9rZTogXCJyZ2IoMTU1LCAyMTQsIDIwNilcIixcblx0XHRcdFx0dmFsdWU6IChzZWxmLCByYXdWYWx1ZSkgPT4gc2FmZV90b19maXhlZChyYXdWYWx1ZSwgMykgKyBcIm1zXCIsXG5cdFx0XHRcdGZpbGw6IFwicmdiKDE1NSwgMjE0LCAyMDYsIDAuNSApXCIsXG5cdFx0XHRcdHBhdGhzOiBwYXRocyxcbiAgICAgICAgc2NhbGU6IFwibXNcIixcbiAgICAgICAgcG9pbnRzOiB7IHNob3c6IGZhbHNlIH0sXG4gICAgICAgIHRpY2tzOiB7IHNob3c6IGZhbHNlIH1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGxhYmVsOiBcIlA5MFwiLFxuXHRcdFx0XHRzdHJva2U6IFwicmdiKDc5LCAxNjksIDE4NClcIixcblx0XHRcdFx0dmFsdWU6IChzZWxmLCByYXdWYWx1ZSkgPT4gc2FmZV90b19maXhlZChyYXdWYWx1ZSwgMykgKyBcIm1zXCIsXG5cdFx0XHRcdGZpbGw6IFwicmdiKDc5LCAxNjksIDE4NCwgMC41KVwiLFxuXHRcdFx0XHRwYXRoczogcGF0aHMsXG5cdFx0XHRcdHNjYWxlOiBcIm1zXCIsXG4gICAgICAgIHBvaW50czogeyBzaG93OiBmYWxzZSB9LFxuICAgICAgICB0aWNrczogeyBzaG93OiBmYWxzZSB9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRsYWJlbDogXCJQNTBcIixcblx0XHRcdFx0c3Ryb2tlOiBcInJnYigyLCA4OCwgMTE1KVwiLFxuXHRcdFx0XHR2YWx1ZTogKHNlbGYsIHJhd1ZhbHVlKSA9PiBzYWZlX3RvX2ZpeGVkKHJhd1ZhbHVlLCAzKSArIFwibXNcIixcblx0XHRcdFx0ZmlsbDogXCJyZ2IoMiwgODgsIDExNSwgMC41KVwiLFxuXHRcdFx0XHRwYXRoczogcGF0aHMsXG4gICAgICAgIHBvaW50czogeyBzaG93OiBmYWxzZSB9LFxuICAgICAgICB0aWNrczogeyBzaG93OiBmYWxzZSB9LFxuXHRcdFx0XHRzY2FsZTogXCJtc1wiXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRsYWJlbDogXCJUaHJvdWdocHV0XCIsXG5cdFx0XHRcdHN0cm9rZTogXCJyZ2IoMzAsIDMwLCAzMClcIixcblx0XHRcdFx0dmFsdWU6IChzZWxmLCByYXdWYWx1ZSkgPT4gcmF3VmFsdWUgKyBcInJlcXNcIixcbiAgICAgICAgcG9pbnRzOiB7IHNob3c6IGZhbHNlIH0sXG4gICAgICAgIHRpY2tzOiB7IHNob3c6IGZhbHNlIH0sXG5cdFx0XHRcdHNjYWxlOiBcInJlcXNcIlxuXHRcdFx0fVxuXHRcdF1cblx0fTtcblxuXHRjaGFydCA9IG5ldyB1UGxvdChvcHRzLCBkYXRhLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0XCIpKTtcbn1cblxubGV0IHNjYWxlID0gXCJcIjtcblxuZXhwb3J0IGNvbnN0IENoYXJ0RGF0YSA9IHtcblx0bW91bnRlZCgpIHtcblx0XHRzY2FsZSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LnNjYWxlKTtcblx0XHRsZXQgcXVhbnRpbGVfZGF0YSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LnF1YW50aWxlKTtcblx0XHRjcmVhdGVfY2hhcnQocXVhbnRpbGVfZGF0YSwgc2NhbGUpO1xuXHR9LFxuXHR1cGRhdGVkKCkge1xuXHRcdGxldCBuZXdfc2NhbGUgPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5zY2FsZSk7XG5cdFx0aWYgKHNjYWxlID09IG5ld19zY2FsZSkge1xuXHRcdFx0bGV0IHF1YW50aWxlX2RhdGEgPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5xdWFudGlsZSk7XG5cdFx0XHRjaGFydC5zZXREYXRhKHF1YW50aWxlX2RhdGEsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tb3VudGVkKCk7XG5cdFx0fVxuXHR9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU9BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQU5BO0FBeERBO0FBbUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/chart.js\n");

/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMi4wJztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtICRwcm9taXNlIGpRVWVyeSBQcm9taXNlXG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRpYWwgPSAwLCBjdXJyZW50ID0gMDtcblxuICAgIE5Qcm9ncmVzcy5wcm9taXNlID0gZnVuY3Rpb24oJHByb21pc2UpIHtcbiAgICAgIGlmICghJHByb21pc2UgfHwgJHByb21pc2Uuc3RhdGUoKSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSAwO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgICBwcm9ncmVzcyAmJiByZW1vdmVFbGVtZW50KHByb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmVzcyBiYXIgaXMgcmVuZGVyZWQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pc1JlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9zaXRpb25pbmcgQ1NTIHJ1bGUgdG8gdXNlLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTbmlmZiBvbiBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgdmFyIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAvLyBTbmlmZiBwcmVmaXhlc1xuICAgIHZhciB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdXZWJraXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdNb3pUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTW96JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnbXNUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnbXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdPVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ08nIDogJyc7XG5cbiAgICBpZiAodmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyB3aXRoIDNEIHN1cHBvcnQsIGUuZy4gV2Via2l0LCBJRTEwXG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkJztcbiAgICB9IGVsc2UgaWYgKHZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCAzRCBzdXBwb3J0LCBlLmcuIElFOVxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IHRyYW5zbGF0ZSgpIHN1cHBvcnQsIGUuZy4gSUU3LThcbiAgICAgIHJldHVybiAnbWFyZ2luJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICBpZiAobiA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICBpZiAobiA+IG1heCkgcmV0dXJuIG1heDtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIGNvbnZlcnRzIGEgcGVyY2VudGFnZSAoYDAuLjFgKSB0byBhIGJhciB0cmFuc2xhdGVYXG4gICAqIHBlcmNlbnRhZ2UgKGAtMTAwJS4uMCVgKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9CYXJQZXJjKG4pIHtcbiAgICByZXR1cm4gKC0xICsgbikgKiAxMDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJldHVybnMgdGhlIGNvcnJlY3QgQ1NTIGZvciBjaGFuZ2luZyB0aGUgYmFyJ3NcbiAgICogcG9zaXRpb24gZ2l2ZW4gYW4gbiBwZXJjZW50YWdlLCBhbmQgc3BlZWQgYW5kIGVhc2UgZnJvbSBTZXR0aW5nc1xuICAgKi9cblxuICBmdW5jdGlvbiBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkge1xuICAgIHZhciBiYXJDU1M7XG5cbiAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnK3RvQmFyUGVyYyhuKSsnJSwwLDApJyB9O1xuICAgIH0gZWxzZSBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcrdG9CYXJQZXJjKG4pKyclLDApJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJDU1MgPSB7ICdtYXJnaW4tbGVmdCc6IHRvQmFyUGVyYyhuKSsnJScgfTtcbiAgICB9XG5cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9ICdhbGwgJytzcGVlZCsnbXMgJytlYXNlO1xuXG4gICAgcmV0dXJuIGJhckNTUztcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cblxuICB2YXIgcXVldWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGZuID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PSAxKSBuZXh0KCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBBcHBsaWVzIGNzcyBwcm9wZXJ0aWVzIHRvIGFuIGVsZW1lbnQsIHNpbWlsYXIgdG8gdGhlIGpRdWVyeSBcbiAgICogY3NzIG1ldGhvZC5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBoZWxwZXIgZG9lcyBhc3Npc3Qgd2l0aCB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkgbmFtZXMsIGl0IFxuICAgKiBkb2VzIG5vdCBwZXJmb3JtIGFueSBtYW5pcHVsYXRpb24gb2YgdmFsdWVzIHByaW9yIHRvIHNldHRpbmcgc3R5bGVzLlxuICAgKi9cblxuICB2YXIgY3NzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdPJywgJ01veicsICdtcycgXSxcbiAgICAgICAgY3NzUHJvcHMgICAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXi1tcy0vLCAnbXMtJykucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHJldHVybiBuYW1lO1xuXG4gICAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgICBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgdmVuZG9yTmFtZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKHZlbmRvck5hbWUgaW4gc3R5bGUpIHJldHVybiB2ZW5kb3JOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHlsZVByb3AobmFtZSkge1xuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICAgIHJldHVybiBjc3NQcm9wc1tuYW1lXSB8fCAoY3NzUHJvcHNbbmFtZV0gPSBnZXRWZW5kb3JQcm9wKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJvcCA9IGdldFN0eWxlUHJvcChwcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvcCwgXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlDc3MoZWxlbWVudCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lcyBjb250YWlucyBhIGNsYXNzIG5hbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID8gZWxlbWVudCA6IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBBZGRzIGEgY2xhc3MgdG8gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0ID0gb2xkTGlzdCArIG5hbWU7XG5cbiAgICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjsgXG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3Q7XG5cbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBjbGFzcyBuYW1lLlxuICAgIG5ld0xpc3QgPSBvbGRMaXN0LnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSwgbmV3TGlzdC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEdldHMgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgY2xhc3MgbmFtZXMgb24gdGhlIGVsZW1lbnQuIFxuICAgKiBUaGUgbGlzdCBpcyB3cmFwcGVkIHdpdGggYSBzaW5nbGUgc3BhY2Ugb24gZWFjaCBlbmQgdG8gZmFjaWxpdGF0ZSBmaW5kaW5nIFxuICAgKiBtYXRjaGVzIHdpdGhpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKCcgJyArIChlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gTlByb2dyZXNzO1xufSk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nprogress/nprogress.js\n");

/***/ }),

/***/ "./node_modules/uplot/dist/uPlot.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/uplot/dist/uPlot.esm.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n* Copyright (c) 2020, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uPlot.js (μPlot)\n* A small, fast chart for time series, lines, areas, ohlc & bars\n* https://github.com/leeoniya/uPlot (v1.1.2)\n*/\n\nfunction debounce(fn, time) {\n\tlet pending = null;\n\n\tfunction run() {\n\t\tpending = null;\n\t\tfn();\n\t}\n\n\treturn function() {\n\t\tclearTimeout(pending);\n\t\tpending = setTimeout(run, time);\n\t}\n}\n\n// binary search for index of closest value\nfunction closestIdx(num, arr, lo, hi) {\n\tlet mid;\n\tlo = lo || 0;\n\thi = hi || arr.length - 1;\n\tlet bitwise = hi <= 2147483647;\n\n\twhile (hi - lo > 1) {\n\t\tmid = bitwise ? (lo + hi) >> 1 : floor((lo + hi) / 2);\n\n\t\tif (arr[mid] < num)\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\n\tif (num - arr[lo] <= arr[hi] - num)\n\t\treturn lo;\n\n\treturn hi;\n}\n\nfunction getMinMax(data, _i0, _i1, sorted) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tif (sorted == 1) {\n\t\t_min = data[_i0];\n\t\t_max = data[_i1];\n\t}\n\telse if (sorted == -1) {\n\t\t_min = data[_i1];\n\t\t_max = data[_i0];\n\t}\n\telse {\n\t\tfor (let i = _i0; i <= _i1; i++) {\n\t\t\tif (data[i] != null) {\n\t\t\t\t_min = min(_min, data[i]);\n\t\t\t\t_max = max(_max, data[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [_min, _max];\n}\n\nfunction rangeLog(min, max, fullMags) {\n\tif (min == max) {\n\t\tmin /= 10;\n\t\tmax *= 10;\n\t}\n\n\tlet minIncr, maxIncr;\n\n\tif (fullMags) {\n\t\tmin = minIncr = pow(10, floor(log10(min)));\n\t\tmax = maxIncr = pow(10,  ceil(log10(max)));\n\t}\n\telse {\n\t\tminIncr       = pow(10, floor(log10(min)));\n\t\tmaxIncr       = pow(10, floor(log10(max)));\n\n\t\tmin           = incrRoundDn(min, minIncr);\n\t\tmax           = incrRoundUp(max, maxIncr);\n\t}\n\n\treturn [\n\t\t+min.toFixed(fixedDec.get(minIncr)),\n\t\t+max.toFixed(fixedDec.get(maxIncr)),\n\t];\n}\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction rangeNum(min, max, mult, extra) {\n\t// auto-scale Y\n\tconst delta = max - min;\n\tconst nonZeroDelta = delta || abs(max) || 1e3;\n\tconst mag = log10(nonZeroDelta);\n\tconst base = pow(10, floor(mag));\n\n\tconst padding = nonZeroDelta * mult;\n\tconst newMin = min - padding;\n\tconst newMax = max + padding;\n\n\tlet snappedMin = round6(incrRoundDn(newMin, base/100));\n\tlet snappedMax = round6(incrRoundUp(newMax, base/100));\n\n\tif (extra) {\n\t\t// for flat data, always use 0 as one chart extreme & place data in center\n\t\tif (delta == 0) {\n\t\t\tif (max > 0)\n\t\t\t\tsnappedMin = 0;\n\t\t\telse if (max < 0)\n\t\t\t\tsnappedMax = 0;\n\t\t}\n\t\telse {\n\t\t\t// if original data never crosses 0, use 0 as one chart extreme\n\t\t\tif (min >= 0 && snappedMin < 0)\n\t\t\t\tsnappedMin = 0;\n\n\t\t\tif (max <= 0 && snappedMax > 0)\n\t\t\t\tsnappedMax = 0;\n\t\t}\n\t}\n\n\treturn [snappedMin, snappedMax];\n}\n\n// alternative: https://stackoverflow.com/a/2254896\nconst fmtNum = new Intl.NumberFormat(navigator.language).format;\n\nconst M = Math;\n\nconst abs = M.abs;\nconst floor = M.floor;\nconst round = M.round;\nconst ceil = M.ceil;\nconst min = M.min;\nconst max = M.max;\nconst pow = M.pow;\nconst log10 = M.log10;\nconst PI = M.PI;\n\nconst inf = Infinity;\n\nfunction incrRound(num, incr) {\n\treturn round(num/incr)*incr;\n}\n\nfunction clamp(num, _min, _max) {\n\treturn min(max(num, _min), _max);\n}\n\nfunction fnOrSelf(v) {\n\treturn typeof v == \"function\" ? v : () => v;\n}\n\nfunction incrRoundUp(num, incr) {\n\treturn ceil(num/incr)*incr;\n}\n\nfunction incrRoundDn(num, incr) {\n\treturn floor(num/incr)*incr;\n}\n\nfunction round3(val) {\n\treturn round(val * 1e3) / 1e3;\n}\n\nfunction round6(val) {\n\treturn round(val * 1e6) / 1e6;\n}\n\nconst fixedDec = new Map();\n\nfunction genIncrs(minExp, maxExp, mults) {\n\tlet incrs = [];\n\n\tfor (let exp = minExp; exp < maxExp; exp++) {\n\t\tlet mag = pow(10, exp);\n\t\tlet expa = abs(exp);\n\n\t\tfor (let i = 0; i < mults.length; i++) {\n\t\t\tlet incr = +(mults[i] * mag).toFixed(expa);\n\t\t\tincrs.push(incr);\n\t\t\tfixedDec.set(incr, incr < 1 ? expa : 0);\n\t\t}\n\t}\n\n\treturn incrs;\n}\n\n//export const assign = Object.assign;\n\nconst isArr = Array.isArray;\n\nfunction isStr(v) {\n\treturn typeof v === 'string';\n}\n\nfunction isObj(v) {\n\treturn typeof v === 'object' && v !== null;\n}\n\nfunction copy(o) {\n\tlet out;\n\n\tif (isArr(o))\n\t\tout = o.map(copy);\n\telse if (isObj(o)) {\n\t\tout = {};\n\t\tfor (var k in o)\n\t\t\tout[k] = copy(o[k]);\n\t}\n\telse\n\t\tout = o;\n\n\treturn out;\n}\n\nfunction assign(targ) {\n\tlet args = arguments;\n\n\tfor (let i = 1; i < args.length; i++) {\n\t\tlet src = args[i];\n\n\t\tfor (let key in src) {\n\t\t\tif (isObj(targ[key]))\n\t\t\t\tassign(targ[key], copy(src[key]));\n\t\t\telse\n\t\t\t\ttarg[key] = copy(src[key]);\n\t\t}\n\t}\n\n\treturn targ;\n}\n\nconst WIDTH = \"width\";\nconst HEIGHT = \"height\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst LEFT = \"left\";\nconst RIGHT = \"right\";\nconst firstChild = \"firstChild\";\nconst createElement = \"createElement\";\nconst hexBlack = \"#000\";\nconst classList = \"classList\";\n\nconst mousemove = \"mousemove\";\nconst mousedown = \"mousedown\";\nconst mouseup = \"mouseup\";\nconst mouseenter = \"mouseenter\";\nconst mouseleave = \"mouseleave\";\nconst dblclick = \"dblclick\";\nconst resize = \"resize\";\nconst scroll = \"scroll\";\n\nconst pre = \"u-\";\n\nconst UPLOT          =       \"uplot\";\nconst TITLE          = pre + \"title\";\nconst WRAP           = pre + \"wrap\";\nconst UNDER          = pre + \"under\";\nconst OVER           = pre + \"over\";\nconst OFF            = pre + \"off\";\nconst SELECT         = pre + \"select\";\nconst CURSOR_X       = pre + \"cursor-x\";\nconst CURSOR_Y       = pre + \"cursor-y\";\nconst CURSOR_PT      = pre + \"cursor-pt\";\nconst LEGEND         = pre + \"legend\";\nconst LEGEND_LIVE    = pre + \"live\";\nconst LEGEND_INLINE  = pre + \"inline\";\nconst LEGEND_THEAD   = pre + \"thead\";\nconst LEGEND_SERIES  = pre + \"series\";\nconst LEGEND_MARKER  = pre + \"marker\";\nconst LEGEND_LABEL   = pre + \"label\";\nconst LEGEND_VALUE   = pre + \"value\";\n\nconst rAF = requestAnimationFrame;\nconst doc = document;\nconst win = window;\nconst pxRatio = devicePixelRatio;\n\nfunction addClass(el, c) {\n\tc != null && el[classList].add(c);\n}\n\nfunction remClass(el, c) {\n\tel[classList].remove(c);\n}\n\nfunction setStylePx(el, name, value) {\n\tel.style[name] = value + \"px\";\n}\n\nfunction placeTag(tag, cls, targ, refEl) {\n\tlet el = doc[createElement](tag);\n\n\tif (cls != null)\n\t\taddClass(el, cls);\n\n\tif (targ != null)\n\t\ttarg.insertBefore(el, refEl);\n\n\treturn el;\n}\n\nfunction placeDiv(cls, targ) {\n\treturn placeTag(\"div\", cls, targ);\n}\n\nfunction trans(el, xPos, yPos) {\n\tel.style.transform = \"translate(\" + xPos + \"px,\" + yPos + \"px)\";\n}\n\nconst evOpts = {passive: true};\n\nfunction on(ev, el, cb) {\n\tel.addEventListener(ev, cb, evOpts);\n}\n\nfunction off(ev, el, cb) {\n\tel.removeEventListener(ev, cb, evOpts);\n}\n\nconst months = [\n\t\"January\",\n\t\"February\",\n\t\"March\",\n\t\"April\",\n\t\"May\",\n\t\"June\",\n\t\"July\",\n\t\"August\",\n\t\"September\",\n\t\"October\",\n\t\"November\",\n\t\"December\",\n];\n\nconst days = [\n\t\"Sunday\",\n\t\"Monday\",\n\t\"Tuesday\",\n\t\"Wednesday\",\n\t\"Thursday\",\n\t\"Friday\",\n\t\"Saturday\",\n];\n\nfunction slice3(str) {\n\treturn str.slice(0, 3);\n}\n\nconst days3 =  days.map(slice3);\n\nconst months3 =  months.map(slice3);\n\nconst engNames = {\n\tMMMM: months,\n\tMMM:  months3,\n\tWWWW: days,\n\tWWW:  days3,\n};\n\nfunction zeroPad2(int) {\n\treturn (int < 10 ? '0' : '') + int;\n}\n\nfunction zeroPad3(int) {\n\treturn (int < 10 ? '00' : int < 100 ? '0' : '') + int;\n}\n\n/*\nfunction suffix(int) {\n\tlet mod10 = int % 10;\n\n\treturn int + (\n\t\tmod10 == 1 && int != 11 ? \"st\" :\n\t\tmod10 == 2 && int != 12 ? \"nd\" :\n\t\tmod10 == 3 && int != 13 ? \"rd\" : \"th\"\n\t);\n}\n*/\n\nconst getFullYear = 'getFullYear';\nconst getMonth = 'getMonth';\nconst getDate = 'getDate';\nconst getDay = 'getDay';\nconst getHours = 'getHours';\nconst getMinutes = 'getMinutes';\nconst getSeconds = 'getSeconds';\nconst getMilliseconds = 'getMilliseconds';\n\nconst subs = {\n\t// 2019\n\tYYYY:\td => d[getFullYear](),\n\t// 19\n\tYY:\t\td => (d[getFullYear]()+'').slice(2),\n\t// July\n\tMMMM:\t(d, names) => names.MMMM[d[getMonth]()],\n\t// Jul\n\tMMM:\t(d, names) => names.MMM[d[getMonth]()],\n\t// 07\n\tMM:\t\td => zeroPad2(d[getMonth]()+1),\n\t// 7\n\tM:\t\td => d[getMonth]()+1,\n\t// 09\n\tDD:\t\td => zeroPad2(d[getDate]()),\n\t// 9\n\tD:\t\td => d[getDate](),\n\t// Monday\n\tWWWW:\t(d, names) => names.WWWW[d[getDay]()],\n\t// Mon\n\tWWW:\t(d, names) => names.WWW[d[getDay]()],\n\t// 03\n\tHH:\t\td => zeroPad2(d[getHours]()),\n\t// 3\n\tH:\t\td => d[getHours](),\n\t// 9 (12hr, unpadded)\n\th:\t\td => {let h = d[getHours](); return h == 0 ? 12 : h > 12 ? h - 12 : h;},\n\t// AM\n\tAA:\t\td => d[getHours]() >= 12 ? 'PM' : 'AM',\n\t// am\n\taa:\t\td => d[getHours]() >= 12 ? 'pm' : 'am',\n\t// a\n\ta:\t\td => d[getHours]() >= 12 ? 'p' : 'a',\n\t// 09\n\tmm:\t\td => zeroPad2(d[getMinutes]()),\n\t// 9\n\tm:\t\td => d[getMinutes](),\n\t// 09\n\tss:\t\td => zeroPad2(d[getSeconds]()),\n\t// 9\n\ts:\t\td => d[getSeconds](),\n\t// 374\n\tfff:\td => zeroPad3(d[getMilliseconds]()),\n};\n\nfunction fmtDate(tpl, names) {\n\tnames = names || engNames;\n\tlet parts = [];\n\n\tlet R = /\\{([a-z]+)\\}|[^{]+/gi, m;\n\n\twhile (m = R.exec(tpl))\n\t\tparts.push(m[0][0] == '{' ? subs[m[1]] : m[0]);\n\n\treturn d => {\n\t\tlet out = '';\n\n\t\tfor (let i = 0; i < parts.length; i++)\n\t\t\tout += typeof parts[i] == \"string\" ? parts[i] : parts[i](d, names);\n\n\t\treturn out;\n\t}\n}\n\nconst localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n// https://stackoverflow.com/questions/15141762/how-to-initialize-a-javascript-date-to-a-particular-time-zone/53652131#53652131\nfunction tzDate(date, tz) {\n\tlet date2;\n\n\t// perf optimization\n\tif (tz == 'Etc/UTC')\n\t\tdate2 = new Date(+date + date.getTimezoneOffset() * 6e4);\n\telse if (tz == localTz)\n\t\tdate2 = date;\n\telse {\n\t\tdate2 = new Date(date.toLocaleString('en-US', {timeZone: tz}));\n\t\tdate2.setMilliseconds(date[getMilliseconds]());\n\t}\n\n\treturn date2;\n}\n\n//export const series = [];\n\n// default formatters:\n\nconst incrMults = [1,2,5];\n\nconst decIncrs = genIncrs(-16, 0, incrMults);\n\nconst intIncrs = genIncrs(0, 16, incrMults);\n\nconst numIncrs = decIncrs.concat(intIncrs);\n\nlet s = 1,\n\tm = 60,\n\th = m * m,\n\td = h * 24,\n\tmo = d * 30,\n\ty = d * 365;\n\n// starting below 1e-3 is a hack to allow the incr finder to choose & bail out at incr < 1ms\nconst timeIncrs =  [5e-4].concat(genIncrs(-3, 0, incrMults), [\n\t// minute divisors (# of secs)\n\t1,\n\t5,\n\t10,\n\t15,\n\t30,\n\t// hour divisors (# of mins)\n\tm,\n\tm * 5,\n\tm * 10,\n\tm * 15,\n\tm * 30,\n\t// day divisors (# of hrs)\n\th,\n\th * 2,\n\th * 3,\n\th * 4,\n\th * 6,\n\th * 8,\n\th * 12,\n\t// month divisors TODO: need more?\n\td,\n\td * 2,\n\td * 3,\n\td * 4,\n\td * 5,\n\td * 6,\n\td * 7,\n\td * 8,\n\td * 9,\n\td * 10,\n\td * 15,\n\t// year divisors (# months, approx)\n\tmo,\n\tmo * 2,\n\tmo * 3,\n\tmo * 4,\n\tmo * 6,\n\t// century divisors\n\ty,\n\ty * 2,\n\ty * 5,\n\ty * 10,\n\ty * 25,\n\ty * 50,\n\ty * 100,\n]);\n\nfunction timeAxisStamps(stampCfg, fmtDate) {\n\treturn stampCfg.map(s => [\n\t\ts[0],\n\t\tfmtDate(s[1]),\n\t\ts[2],\n\t\tfmtDate(s[4] ? s[1] + s[3] : s[3]),\n\t]);\n}\n\nconst yyyy = \"{YYYY}\";\nconst NLyyyy = \"\\n\" + yyyy;\nconst md = \"{M}/{D}\";\nconst NLmd = \"\\n\" + md;\n\nconst aa = \"{aa}\";\nconst hmm = \"{h}:{mm}\";\nconst hmmaa = hmm + aa;\nconst ss = \":{ss}\";\n\n// [0]: minimum num secs in the tick incr\n// [1]: normal tick format\n// [2]: when a differing <x> is encountered - 1: sec, 2: min, 3: hour, 4: day, 5: week, 6: month, 7: year\n// [3]: use a longer more contextual format\n// [4]: modes: 0: replace [1] -> [3], 1: concat [1] + [3]\nconst _timeAxisStamps = [\n\t[y,        yyyy,            7,   \"\",                    1],\n\t[d * 28,   \"{MMM}\",         7,   NLyyyy,                1],\n\t[d,        md,              7,   NLyyyy,                1],\n\t[h,        \"{h}\" + aa,      4,   NLmd,                  1],\n\t[m,        hmmaa,           4,   NLmd,                  1],\n\t[s,        ss,              2,   NLmd  + \" \" + hmmaa,   1],\n\t[1e-3,     ss + \".{fff}\",   2,   NLmd  + \" \" + hmmaa,   1],\n];\n\n// TODO: will need to accept spaces[] and pull incr into the loop when grid will be non-uniform, eg for log scales.\n// currently we ignore this for months since they're *nearly* uniform and the added complexity is not worth it\nfunction timeAxisVals(tzDate, stamps) {\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => {\n\t\tlet s = stamps.find(e => foundIncr >= e[0]) || stamps[stamps.length - 1];\n\n\t\t// these track boundaries when a full label is needed again\n\t\tlet prevYear = null;\n\t\tlet prevDate = null;\n\t\tlet prevMinu = null;\n\n\t\treturn splits.map((split, i) => {\n\t\t\tlet date = tzDate(split);\n\n\t\t\tlet newYear = date[getFullYear]();\n\t\t\tlet newDate = date[getDate]();\n\t\t\tlet newMinu = date[getMinutes]();\n\n\t\t\tlet diffYear = newYear != prevYear;\n\t\t\tlet diffDate = newDate != prevDate;\n\t\t\tlet diffMinu = newMinu != prevMinu;\n\n\t\t\tlet stamp = s[2] == 7 && diffYear || s[2] == 4 && diffDate || s[2] == 2 && diffMinu ? s[3] : s[1];\n\n\t\t\tprevYear = newYear;\n\t\t\tprevDate = newDate;\n\t\t\tprevMinu = newMinu;\n\n\t\t\treturn stamp(date);\n\t\t});\n\t}\n}\n\nfunction mkDate(y, m, d) {\n\treturn new Date(y, m, d);\n}\n\n// the ensures that axis ticks, values & grid are aligned to logical temporal breakpoints and not an arbitrary timestamp\n// https://www.timeanddate.com/time/dst/\n// https://www.timeanddate.com/time/dst/2019.html\n// https://www.epochconverter.com/timezones\nfunction timeAxisSplits(tzDate) {\n\treturn (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n\t\tlet splits = [];\n\t\tlet isMo = foundIncr >= mo && foundIncr < y;\n\n\t\t// get the timezone-adjusted date\n\t\tlet minDate = tzDate(scaleMin);\n\t\tlet minDateTs = minDate / 1e3;\n\n\t\t// get ts of 12am (this lands us at or before the original scaleMin)\n\t\tlet minMin = mkDate(minDate[getFullYear](), minDate[getMonth](), isMo ? 1 : minDate[getDate]());\n\t\tlet minMinTs = minMin / 1e3;\n\n\t\tif (isMo) {\n\t\t\tlet moIncr = foundIncr / mo;\n\t\t//\tlet tzOffset = scaleMin - minDateTs;\t\t// needed?\n\t\t\tlet split = minDateTs == minMinTs ? minDateTs : mkDate(minMin[getFullYear](), minMin[getMonth]() + moIncr, 1) / 1e3;\n\t\t\tlet splitDate = new Date(split * 1e3);\n\t\t\tlet baseYear = splitDate[getFullYear]();\n\t\t\tlet baseMonth = splitDate[getMonth]();\n\n\t\t\tfor (let i = 0; split <= scaleMax; i++) {\n\t\t\t\tlet next = mkDate(baseYear, baseMonth + moIncr * i, 1);\n\t\t\t\tlet offs = next - tzDate(next / 1e3);\n\n\t\t\t\tsplit = (+next + offs) / 1e3;\n\n\t\t\t\tif (split <= scaleMax)\n\t\t\t\t\tsplits.push(split);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlet incr0 = foundIncr >= d ? d : foundIncr;\n\t\t\tlet tzOffset = floor(scaleMin) - floor(minDateTs);\n\t\t\tlet split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);\n\t\t\tsplits.push(split);\n\n\t\t\tlet date0 = tzDate(split);\n\n\t\t\tlet prevHour = date0[getHours]() + (date0[getMinutes]() / m) + (date0[getSeconds]() / h);\n\t\t\tlet incrHours = foundIncr / h;\n\n\t\t\tlet minSpace = self.axes[axisIdx].space();\t\t// TOFIX: only works for static space:\n\t\t\tlet pctSpace = foundSpace / minSpace;\n\n\t\t\twhile (1) {\n\t\t\t\tsplit = round3(split + foundIncr);\n\n\t\t\t\tif (split > scaleMax)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (incrHours > 1) {\n\t\t\t\t\tlet expectedHour = floor(round6(prevHour + incrHours)) % 24;\n\t\t\t\t\tlet splitDate = tzDate(split);\n\t\t\t\t\tlet actualHour = splitDate.getHours();\n\n\t\t\t\t\tlet dstShift = actualHour - expectedHour;\n\n\t\t\t\t\tif (dstShift > 1)\n\t\t\t\t\t\tdstShift = -1;\n\n\t\t\t\t\tsplit -= dstShift * h;\n\n\t\t\t\t\tprevHour = (prevHour + incrHours) % 24;\n\n\t\t\t\t\t// add a tick only if it's further than 70% of the min allowed label spacing\n\t\t\t\t\tlet prevSplit = splits[splits.length - 1];\n\t\t\t\t\tlet pctIncr = round3((split - prevSplit) / foundIncr);\n\n\t\t\t\t\tif (pctIncr * pctSpace >= .7)\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsplits.push(split);\n\t\t\t}\n\t\t}\n\n\t\treturn splits;\n\t}\n}\n\nfunction timeSeriesStamp(stampCfg, fmtDate) {\n\treturn fmtDate(stampCfg);\n}\nconst _timeSeriesStamp = '{YYYY}-{MM}-{DD} {h}:{mm}{aa}';\n\nfunction timeSeriesVal(tzDate, stamp) {\n\treturn (self, val) => stamp(tzDate(val));\n}\n\nfunction cursorPoint(self, si) {\n\tlet s = self.series[si];\n\n\tlet pt = placeDiv();\n\n\tpt.style.background = s.stroke || hexBlack;\n\n\tlet dia = ptDia(s.width, 1);\n\tlet mar = (dia - 1) / -2;\n\n\tsetStylePx(pt, WIDTH, dia);\n\tsetStylePx(pt, HEIGHT, dia);\n\tsetStylePx(pt, \"marginLeft\", mar);\n\tsetStylePx(pt, \"marginTop\", mar);\n\n\treturn pt;\n}\n\nfunction dataIdx(self, seriesIdx, cursorIdx) {\n\treturn cursorIdx;\n}\n\nconst moveTuple = [0,0];\n\nfunction cursorMove(self, mouseLeft1, mouseTop1) {\n\tmoveTuple[0] = mouseLeft1;\n\tmoveTuple[1] = mouseTop1;\n\treturn moveTuple;\n}\n\nconst cursorOpts = {\n\tshow: true,\n\tx: true,\n\ty: true,\n\tlock: false,\n\tmove: cursorMove,\n\tpoints: {\n\t\tshow: cursorPoint,\n\t},\n\n\tdrag: {\n\t\tsetScale: true,\n\t\tx: true,\n\t\ty: false,\n\t\tdist: 0,\n\t\tuni: null,\n\t\t_x: false,\n\t\t_y: false,\n\t},\n\n\tfocus: {\n\t\tprox: -1,\n\t},\n\n\tlocked: false,\n\tleft: -10,\n\ttop: -10,\n\tidx: null,\n\tdataIdx,\n};\n\nconst grid = {\n\tshow: true,\n\tstroke: \"rgba(0,0,0,0.07)\",\n\twidth: 2,\n//\tdash: [],\n};\n\nconst ticks = assign({}, grid, {size: 10});\n\nconst font      = '12px system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"';\nconst labelFont = \"bold \" + font;\nconst lineMult = 1.5;\t\t// font-size multiplier\n\nconst xAxisOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tspace: 50,\n\tgap: 5,\n\tsize: 50,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 2,\n//\tclass: \"x-vals\",\n//\tincrs: timeIncrs,\n//\tvalues: timeVals,\n\tgrid,\n\tticks,\n\tfont,\n\trotate: 0,\n};\n\nconst numSeriesLabel = \"Value\";\nconst timeSeriesLabel = \"Time\";\n\nconst xSeriesOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tsorted: 1,\n//\tlabel: \"Time\",\n//\tvalue: v => stamp(new Date(v * 1e3)),\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n};\n\nfunction numAxisVals(self, splits, axisIdx, foundSpace, foundIncr) {\n\treturn splits.map(fmtNum);\n}\n\nfunction numAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet splits = [];\n\n\tlet numDec = fixedDec.get(foundIncr);\n\n\tscaleMin = forceMin ? scaleMin : +incrRoundUp(scaleMin, foundIncr).toFixed(numDec);\n\n\tfor (let val = scaleMin; val <= scaleMax; val = +(val + foundIncr).toFixed(numDec))\n\t\tsplits.push(val);\n\n\treturn splits;\n}\n\nfunction logAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tconst splits = [];\n\n\tfoundIncr = pow(10, floor(log10(scaleMin)));\n\n\tlet split = scaleMin;\n\n\tdo {\n\t\tsplits.push(split);\n\t\tsplit = +(split + foundIncr).toFixed(fixedDec.get(foundIncr));\n\t\tif (split >= foundIncr * 10)\n\t\t\tfoundIncr = split;\n\t} while (split <= scaleMax);\n\n\treturn splits;\n}\n\nconst RE_ALL   = /./;\nconst RE_12357 = /[12357]/;\nconst RE_125   = /[125]/;\nconst RE_1     = /1/;\n\nfunction logAxisVals(self, splits, axisIdx, foundSpace, foundIncr) {\n\tlet axis = self.axes[axisIdx];\n\tlet scaleKey = axis.scale;\n\tlet valToPos = self.valToPos;\n\n\tlet minSpace = axis.space();\t\t\t// TOFIX: only works for static space:\n\n\tlet _10 = valToPos(10, scaleKey);\n\n\tlet re = (\n\t\tvalToPos(9,  scaleKey) - _10 >= minSpace ? RE_ALL :\n\t\tvalToPos(7,  scaleKey) - _10 >= minSpace ? RE_12357 :\n\t\tvalToPos(5,  scaleKey) - _10 >= minSpace ? RE_125 :\n\t\tRE_1\n\t);\n\n\treturn splits.map(v => re.test(v) ? fmtNum(v) : \"\");\n}\n\nfunction numSeriesVal(self, val) {\n\treturn fmtNum(val);\n}\n\nconst yAxisOpts = {\n\tshow: true,\n\tscale: \"y\",\n\tspace: 40,\n\tgap: 5,\n\tsize: 50,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 3,\n//\tclass: \"y-vals\",\n//\tincrs: numIncrs,\n//\tvalues: (vals, space) => vals,\n\tgrid,\n\tticks,\n\tfont,\n\trotate: 0,\n};\n\n// takes stroke width\nfunction ptDia(width, mult) {\n\tlet dia = 3 + (width || 1) * 2;\n\treturn round3(dia * mult);\n}\n\nfunction seriesPoints(self, si) {\n\tconst dia = ptDia(self.series[si].width, pxRatio);\n\tlet maxPts = self.bbox.width / dia / 2;\n\tlet idxs = self.series[0].idxs;\n\treturn idxs[1] - idxs[0] <= maxPts;\n}\n\nconst ySeriesOpts = {\n\tscale: \"y\",\n\tsorted: 0,\n\tshow: true,\n\tband: false,\n\tspanGaps: false,\n\talpha: 1,\n\tpoints: {\n\t\tshow: seriesPoints,\n\t//\tstroke: \"#000\",\n\t//\tfill: \"#fff\",\n\t//\twidth: 1,\n\t//\tsize: 10,\n\t},\n//\tlabel: \"Value\",\n//\tvalue: v => v,\n\tvalues: null,\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n\n\tpath: null,\n\tclip: null,\n};\n\nconst xScaleOpts = {\n\ttime: true,\n\tauto: true,\n\tdistr: 1,\n\tmin: null,\n\tmax: null,\n};\n\nconst yScaleOpts = assign({}, xScaleOpts, {\n\ttime: false,\n});\n\nconst syncs = {};\n\nfunction _sync(opts) {\n\tlet clients = [];\n\n\treturn {\n\t\tsub(client) {\n\t\t\tclients.push(client);\n\t\t},\n\t\tunsub(client) {\n\t\t\tclients = clients.filter(c => c != client);\n\t\t},\n\t\tpub(type, self, x, y, w, h, i) {\n\t\t\tif (clients.length > 1) {\n\t\t\t\tclients.forEach(client => {\n\t\t\t\t\tclient != self && client.pub(type, self, x, y, w, h, i);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction setDefaults(d, xo, yo, initY) {\n\tlet d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));\n\treturn d2.map((o, i) => setDefault(o, i, xo, yo));\n}\n\nfunction setDefault(o, i, xo, yo) {\n\treturn assign({}, (i == 0 || o && o.side % 2 == 0 ? xo : yo), o);\n}\n\nfunction getValPct(val, scale) {\n\treturn (\n\t\tscale.distr == 3\n\t\t? log10(val / scale.min) / log10(scale.max / scale.min)\n\t\t: (val - scale.min) / (scale.max - scale.min)\n\t);\n}\n\nfunction getYPos(val, scale, hgt, top) {\n\tlet pctY = getValPct(val, scale);\n\treturn top + (1 - pctY) * hgt;\n}\n\nfunction getXPos(val, scale, wid, lft) {\n\tlet pctX = getValPct(val, scale);\n\treturn lft + pctX * wid;\n}\n\nfunction snapTimeX(self, dataMin, dataMax) {\n\treturn [dataMin, dataMax > dataMin ? dataMax : dataMax + 86400];\n}\n\nfunction snapNumX(self, dataMin, dataMax) {\n\tconst delta = dataMax - dataMin;\n\n\tif (delta == 0) {\n\t\tconst mag = log10(delta || abs(dataMax) || 1);\n\t\tconst exp = floor(mag) + 1;\n\t\treturn [dataMin, incrRoundUp(dataMax, pow(10, exp))];\n\t}\n\telse\n\t\treturn [dataMin, dataMax];\n}\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction snapNumY(self, dataMin, dataMax) {\n\treturn rangeNum(dataMin, dataMax, 0.1, true);\n}\n\nfunction snapLogX(self, dataMin, dataMax) {\n\treturn rangeLog(dataMin, dataMax);\n}\n\nfunction snapLogY(self, dataMin, dataMax) {\n\treturn rangeLog(dataMin, dataMax);\n}\n\n// dim is logical (getClientBoundingRect) pixels, not canvas pixels\nfunction findIncr(min, max, incrs, dim, minSpace) {\n\tlet pxPerUnit = dim / (max - min);\n\n\tfor (var i = 0; i < incrs.length; i++) {\n\t\tlet space = incrs[i] * pxPerUnit;\n\n\t\tif (space >= minSpace && min + incrs[i] > min)\n\t\t\treturn [incrs[i], space];\n\t}\n}\n\nfunction filtMouse(e) {\n\treturn e.button == 0;\n}\n\nfunction pxRatioFont(font) {\n\tlet fontSize;\n\tfont = font.replace(/\\d+/, m => (fontSize = round(m * pxRatio)));\n\treturn [font, fontSize];\n}\n\nfunction uPlot(opts, data, then) {\n\tconst self = {};\n\n\tconst root = self.root = placeDiv(UPLOT);\n\n\tif (opts.id != null)\n\t\troot.id = opts.id;\n\n\taddClass(root, opts.class);\n\n\tif (opts.title) {\n\t\tlet title = placeDiv(TITLE, root);\n\t\ttitle.textContent = opts.title;\n\t}\n\n\tconst can = placeTag(\"canvas\");\n\tconst ctx = self.ctx = can.getContext(\"2d\");\n\n\tconst wrap = placeDiv(WRAP, root);\n\tconst under = placeDiv(UNDER, wrap);\n\twrap.appendChild(can);\n\tconst over = placeDiv(OVER, wrap);\n\n\topts = copy(opts);\n\n\t(opts.plugins || []).forEach(p => {\n\t\tif (p.opts)\n\t\t\topts = p.opts(self, opts) || opts;\n\t});\n\n\tlet ready = false;\n\n\tconst series  = self.series = setDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false);\n\tconst axes    = self.axes   = setDefaults(opts.axes   || [], xAxisOpts,   yAxisOpts,    true);\n\tconst scales  = self.scales = assign({}, {x: xScaleOpts, y: yScaleOpts}, opts.scales);\n\n\tconst gutters = assign({\n\t\tx: round(yAxisOpts.size / 2),\n\t\ty: round(xAxisOpts.size / 3),\n\t}, opts.gutters);\n\n//\tself.tz = opts.tz || Intl.DateTimeFormat().resolvedOptions().timeZone;\n\tconst _tzDate  =  (opts.tzDate || (ts => new Date(ts * 1e3)));\n\tconst _fmtDate =  (opts.fmtDate || fmtDate);\n\n\tconst _timeAxisSplits =  timeAxisSplits(_tzDate);\n\tconst _timeAxisVals   =  timeAxisVals(_tzDate, timeAxisStamps(_timeAxisStamps, _fmtDate));\n\tconst _timeSeriesVal  =  timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));\n\n\tconst pendScales = {};\n\n\t// explicitly-set initial scales\n\tfor (let k in scales) {\n\t\tlet sc = scales[k];\n\n\t\tif (sc.min != null || sc.max != null)\n\t\t\tpendScales[k] = {min: sc.min, max: sc.max};\n\t}\n\n\tconst legend     =  assign({show: true, live: true}, opts.legend);\n\tconst showLegend =  legend.show;\n\n\tlet legendEl;\n\tlet legendRows = [];\n\tlet legendCols;\n\tlet multiValLegend = false;\n\n\tif (showLegend) {\n\t\tlegendEl = placeTag(\"table\", LEGEND, root);\n\n\t\tconst getMultiVals = series[1] ? series[1].values : null;\n\t\tmultiValLegend = getMultiVals != null;\n\n\t\tif (multiValLegend) {\n\t\t\tlet head = placeTag(\"tr\", LEGEND_THEAD, legendEl);\n\t\t\tplaceTag(\"th\", null, head);\n\t\t\tlegendCols = getMultiVals(self, 1, 0);\n\n\t\t\tfor (var key in legendCols)\n\t\t\t\tplaceTag(\"th\", LEGEND_LABEL, head).textContent = key;\n\t\t}\n\t\telse {\n\t\t\tlegendCols = {_: 0};\n\t\t\taddClass(legendEl, LEGEND_INLINE);\n\t\t\tlegend.live && addClass(legendEl, LEGEND_LIVE);\n\t\t}\n\t}\n\n\tfunction initLegendRow(s, i) {\n\t\tif (i == 0 && (multiValLegend || !legend.live))\n\t\t\treturn null;\n\n\t\tlet _row = [];\n\n\t\tlet row = placeTag(\"tr\", LEGEND_SERIES, legendEl, legendEl.childNodes[i]);\n\n\t\taddClass(row, s.class);\n\n\t\tif (!s.show)\n\t\t\taddClass(row, OFF);\n\n\t\tlet label = placeTag(\"th\", null, row);\n\n\t\tlet indic = placeDiv(LEGEND_MARKER, label);\n\t\ts.width && (indic.style.borderColor = s.stroke);\n\t\tindic.style.backgroundColor = s.fill;\n\n\t\tlet text = placeDiv(LEGEND_LABEL, label);\n\t\ttext.textContent = s.label;\n\n\t\tif (i > 0) {\n\t\t\ton(\"click\", label, e => {\n\t\t\t\tif ( cursor.locked)\n\t\t\t\t\treturn;\n\n\t\t\t\tfiltMouse(e) && setSeries(series.indexOf(s), {show: !s.show},  syncOpts.setSeries);\n\t\t\t});\n\n\t\t\tif (cursorFocus) {\n\t\t\t\ton(mouseenter, label, e => {\n\t\t\t\t\tif (cursor.locked)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tsetSeries(series.indexOf(s), {focus: true}, syncOpts.setSeries);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in legendCols) {\n\t\t\tlet v = placeTag(\"td\", LEGEND_VALUE, row);\n\t\t\tv.textContent = \"--\";\n\t\t\t_row.push(v);\n\t\t}\n\n\t\treturn _row;\n\t}\n\n\tconst cursor =  (self.cursor = assign({}, cursorOpts, opts.cursor));\n\n\t (cursor.points.show = fnOrSelf(cursor.points.show));\n\n\tconst focus = self.focus = assign({}, opts.focus || {alpha: 0.3},  cursor.focus);\n\tconst cursorFocus =  focus.prox >= 0;\n\n\t// series-intersection markers\n\tlet cursorPts = [null];\n\n\tfunction initCursorPt(s, si) {\n\t\tif (si > 0) {\n\t\t\tlet pt = cursor.points.show(self, si);\n\n\t\t\tif (pt) {\n\t\t\t\taddClass(pt, CURSOR_PT);\n\t\t\t\taddClass(pt, s.class);\n\t\t\t\ttrans(pt, -10, -10);\n\t\t\t\tover.insertBefore(pt, cursorPts[si]);\n\n\t\t\t\treturn pt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initSeries(s, i) {\n\t\t// init scales & defaults\n\t\tconst scKey = s.scale;\n\n\t\tconst sc = scales[scKey] = assign({}, (i == 0 ? xScaleOpts : yScaleOpts), scales[scKey]);\n\n\t\tlet isTime =  sc.time;\n\t\tlet isLog  = sc.distr == 3;\n\n\t\tsc.range = fnOrSelf(sc.range || (isTime ? snapTimeX : i == 0 ? (isLog ? snapLogX : snapNumX) : (isLog ? snapLogY : snapNumY)));\n\n\t\tlet sv = s.value;\n\t\ts.value = isTime ? (isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal) : sv || numSeriesVal;\n\t\ts.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);\n\n\t\tif (i > 0) {\n\t\t\ts.width = s.width == null ? 1 : s.width;\n\t\t\ts.paths = s.paths || ( buildPaths);\n\t\t\ts.fillTo = fnOrSelf(s.fillTo || 0);\n\t\t\tlet _ptDia = ptDia(s.width, 1);\n\t\t\ts.points = assign({}, {\n\t\t\t\tsize: _ptDia,\n\t\t\t\twidth: max(1, _ptDia * .2),\n\t\t\t}, s.points);\n\t\t\ts.points.show = fnOrSelf(s.points.show);\n\t\t\ts._paths = null;\n\t\t}\n\n\t\tif (showLegend)\n\t\t\tlegendRows.splice(i, 0, initLegendRow(s, i));\n\n\t\tif ( cursor.show) {\n\t\t\tlet pt = initCursorPt(s, i);\n\t\t\tpt && cursorPts.splice(i, 0, pt);\n\t\t}\n\t}\n\n\tfunction addSeries(opts, si) {\n\t\tsi = si == null ? series.length : si;\n\n\t\topts = setDefault(opts, si, xSeriesOpts, ySeriesOpts);\n\t\tseries.splice(si, 0, opts);\n\t\tinitSeries(series[si], si);\n\t}\n\n\tself.addSeries = addSeries;\n\n\tfunction delSeries(i) {\n\t\tseries.splice(i, 1);\n\t\t showLegend && legendRows.splice(i, 1)[0][0].parentNode.remove();\n\t\t cursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();\n\n\t\t// TODO: de-init no-longer-needed scales?\n\t}\n\n\tself.delSeries = delSeries;\n\n\tseries.forEach(initSeries);\n\n\tconst xScaleKey = series[0].scale;\n\tconst xScaleDistr = scales[xScaleKey].distr;\n\n\t// dependent scales inherit\n\tfor (let k in scales) {\n\t\tlet sc = scales[k];\n\n\t\tif (sc.from != null)\n\t\t\tscales[k] = assign({}, scales[sc.from], sc);\n\t}\n\n\tfunction initAxis(axis, i) {\n\t\tif (axis.show) {\n\t\t\tlet isVt = axis.side % 2;\n\n\t\t\tlet sc = scales[axis.scale];\n\n\t\t\t// this can occur if all series specify non-default scales\n\t\t\tif (sc == null) {\n\t\t\t\taxis.scale = isVt ? series[1].scale : xScaleKey;\n\t\t\t\tsc = scales[axis.scale];\n\t\t\t}\n\n\t\t\t// also set defaults for incrs & values based on axis distr\n\t\t\tlet isTime =  sc.time;\n\n\t\t\taxis.space = fnOrSelf(axis.space);\n\t\t\taxis.rotate = fnOrSelf(axis.rotate);\n\t\t\taxis.incrs  = fnOrSelf(axis.incrs  || (          sc.distr == 2 ? intIncrs : (isTime ? timeIncrs : numIncrs)));\n\t\t\taxis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : numAxisSplits));\n\t\t\tlet av = axis.values;\n\t\t\taxis.values = isTime ? (isArr(av) ? timeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) : av || _timeAxisVals) : av || (sc.distr == 3 ? logAxisVals : numAxisVals);\n\n\t\t\taxis.font      = pxRatioFont(axis.font);\n\t\t\taxis.labelFont = pxRatioFont(axis.labelFont);\n\t\t}\n\t}\n\n\t// set axis defaults\n\taxes.forEach(initAxis);\n\n\tlet dataLen;\n\n\t// rendered data window\n\tlet i0 = null;\n\tlet i1 = null;\n\tconst idxs = series[0].idxs;\n\n\tlet data0 = null;\n\n\tlet forceUpdateLegend = false;\n\n\tfunction setData(_data, _resetScales) {\n\t\t_data = _data || [];\n\t\t_data[0] = _data[0] || [];\n\n\t\tself.data = _data;\n\t\tdata = _data.slice();\n\t\tdata0 = data[0];\n\t\tdataLen = data0.length;\n\n\t\tif (xScaleDistr == 2)\n\t\t\tdata[0] = data0.map((v, i) => i);\n\n\t\tresetYSeries();\n\n\t\tfire(\"setData\");\n\n\t\tforceUpdateLegend = true;\n\n\t\tif (_resetScales !== false) {\n\t\t\tlet xsc = scales[xScaleKey];\n\n\t\t\tif (xsc.auto)\n\t\t\t\tautoScaleX();\n\t\t\telse\n\t\t\t\t_setScale(xScaleKey, xsc.min, xsc.max);\n\t\t}\n\t}\n\n\tself.setData = setData;\n\n\tfunction autoScaleX() {\n\t\ti0 = idxs[0] = 0;\n\t\ti1 = idxs[1] = dataLen - 1;\n\n\t\tlet _min = xScaleDistr == 2 ? i0 : data[0][i0],\n\t\t\t_max = xScaleDistr == 2 ? i1 : data[0][i1];\n\n\t\t_min != null && _max != null && _setScale(xScaleKey, _min, _max);\n\t}\n\n\tfunction setCtxStyle(stroke, width, dash, fill) {\n\t\tctx.strokeStyle = stroke || hexBlack;\n\t\tctx.lineWidth = width;\n\t\tctx.lineJoin = \"round\";\n\t\tctx.setLineDash(dash || []);\n\t\tctx.fillStyle = fill || hexBlack;\n\t}\n\n\tlet fullWidCss;\n\tlet fullHgtCss;\n\n\tlet plotWidCss;\n\tlet plotHgtCss;\n\n\t// plot margins to account for axes\n\tlet plotLftCss;\n\tlet plotTopCss;\n\n\tlet plotLft;\n\tlet plotTop;\n\tlet plotWid;\n\tlet plotHgt;\n\n\tself.bbox = {};\n\n\tfunction _setSize(width, height) {\n\t\tself.width  = fullWidCss = plotWidCss = width;\n\t\tself.height = fullHgtCss = plotHgtCss = height;\n\t\tplotLftCss  = plotTopCss = 0;\n\n\t\tcalcPlotRect();\n\t\tcalcAxesRects();\n\n\t\tlet bb = self.bbox;\n\n\t\tplotLft = bb[LEFT]   = incrRound(plotLftCss * pxRatio, 0.5);\n\t\tplotTop = bb[TOP]    = incrRound(plotTopCss * pxRatio, 0.5);\n\t\tplotWid = bb[WIDTH]  = incrRound(plotWidCss * pxRatio, 0.5);\n\t\tplotHgt = bb[HEIGHT] = incrRound(plotHgtCss * pxRatio, 0.5);\n\n\t\tsetStylePx(under, LEFT,   plotLftCss);\n\t\tsetStylePx(under, TOP,    plotTopCss);\n\t\tsetStylePx(under, WIDTH,  plotWidCss);\n\t\tsetStylePx(under, HEIGHT, plotHgtCss);\n\n\t\tsetStylePx(over, LEFT,    plotLftCss);\n\t\tsetStylePx(over, TOP,     plotTopCss);\n\t\tsetStylePx(over, WIDTH,   plotWidCss);\n\t\tsetStylePx(over, HEIGHT,  plotHgtCss);\n\n\t\tsetStylePx(wrap, WIDTH,   fullWidCss);\n\t\tsetStylePx(wrap, HEIGHT,  fullHgtCss);\n\n\t\tcan[WIDTH]  = round(fullWidCss * pxRatio);\n\t\tcan[HEIGHT] = round(fullHgtCss * pxRatio);\n\n\t\tsyncRect();\n\n\t\tready && _setScale(xScaleKey, scales[xScaleKey].min, scales[xScaleKey].max);\n\n\t\tready && fire(\"setSize\");\n\t}\n\n\tfunction setSize({width, height}) {\n\t\t_setSize(width, height);\n\t}\n\n\tself.setSize = setSize;\n\n\t// accumulate axis offsets, reduce canvas width\n\tfunction calcPlotRect() {\n\t\t// easements for edge labels\n\t\tlet hasTopAxis = false;\n\t\tlet hasBtmAxis = false;\n\t\tlet hasRgtAxis = false;\n\t\tlet hasLftAxis = false;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show) {\n\t\t\t\tlet {side, size} = axis;\n\t\t\t\tlet isVt = side % 2;\n\t\t\t\tlet labelSize = axis.labelSize = (axis.label != null ? (axis.labelSize || 30) : 0);\n\n\t\t\t\tlet fullSize = size + labelSize;\n\n\t\t\t\tif (fullSize > 0) {\n\t\t\t\t\tif (isVt) {\n\t\t\t\t\t\tplotWidCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 3) {\n\t\t\t\t\t\t\tplotLftCss += fullSize;\n\t\t\t\t\t\t\thasLftAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasRgtAxis = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tplotHgtCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 0) {\n\t\t\t\t\t\t\tplotTopCss += fullSize;\n\t\t\t\t\t\t\thasTopAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasBtmAxis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// hz gutters\n\t\tif (hasTopAxis || hasBtmAxis) {\n\t\t\tif (!hasRgtAxis)\n\t\t\t\tplotWidCss -= gutters.x;\n\t\t\tif (!hasLftAxis) {\n\t\t\t\tplotWidCss -= gutters.x;\n\t\t\t\tplotLftCss += gutters.x;\n\t\t\t}\n\t\t}\n\n\t\t// vt gutters\n\t\tif (hasLftAxis || hasRgtAxis) {\n\t\t\tif (!hasBtmAxis)\n\t\t\t\tplotHgtCss -= gutters.y;\n\t\t\tif (!hasTopAxis) {\n\t\t\t\tplotHgtCss -= gutters.y;\n\t\t\t\tplotTopCss += gutters.y;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calcAxesRects() {\n\t\t// will accum +\n\t\tlet off1 = plotLftCss + plotWidCss;\n\t\tlet off2 = plotTopCss + plotHgtCss;\n\t\t// will accum -\n\t\tlet off3 = plotLftCss;\n\t\tlet off0 = plotTopCss;\n\n\t\tfunction incrOffset(side, size) {\n\n\t\t\tswitch (side) {\n\t\t\t\tcase 1: off1 += size; return off1 - size;\n\t\t\t\tcase 2: off2 += size; return off2 - size;\n\t\t\t\tcase 3: off3 -= size; return off3 + size;\n\t\t\t\tcase 0: off0 -= size; return off0 + size;\n\t\t\t}\n\t\t}\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tlet side = axis.side;\n\n\t\t\taxis._pos = incrOffset(side, axis.size);\n\n\t\t\tif (axis.label != null)\n\t\t\t\taxis._lpos = incrOffset(side, axis.labelSize);\n\t\t});\n\t}\n\n\tfunction setScales() {\n\t\tif (inBatch) {\n\t\t\tshouldSetScales = true;\n\t\t\treturn;\n\t\t}\n\n\t//\tlog(\"setScales()\", arguments);\n\n\t\tif (dataLen > 0) {\n\t\t\t// wip scales\n\t\t\tlet wipScales = copy(scales);\n\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\tif (psc != null) {\n\t\t\t\t\tassign(wsc, psc);\n\n\t\t\t\t\t// explicitly setting the x-scale invalidates everything (acts as redraw)\n\t\t\t\t\tif (k == xScaleKey)\n\t\t\t\t\t\tresetYSeries();\n\t\t\t\t}\n\t\t\t\telse if (k != xScaleKey) {\n\t\t\t\t\twsc.min = inf;\n\t\t\t\t\twsc.max = -inf;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// pre-range y-scales from y series' data values\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tlet k = s.scale;\n\t\t\t\tlet wsc = wipScales[k];\n\n\t\t\t\t// setting the x scale invalidates everything\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tlet minMax = wsc.range(self, wsc.min, wsc.max, k);\n\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\n\t\t\t\t\ti0 = closestIdx(wsc.min, data[0]);\n\t\t\t\t\ti1 = closestIdx(wsc.max, data[0]);\n\n\t\t\t\t\t// closest indices can be outside of view\n\t\t\t\t\tif (data[0][i0] < wsc.min)\n\t\t\t\t\t\ti0++;\n\t\t\t\t\tif (data[0][i1] > wsc.max)\n\t\t\t\t\t\ti1--;\n\n\t\t\t\t\ts.min = data0[i0];\n\t\t\t\t\ts.max = data0[i1];\n\t\t\t\t}\n\t\t\t\telse if (s.show && pendScales[k] == null) {\n\t\t\t\t\t// only run getMinMax() for invalidated series data, else reuse\n\t\t\t\t\tlet minMax = s.min == inf ? (wsc.auto ? getMinMax(data[i], i0, i1, s.sorted) : [0,100]) : [s.min, s.max];\n\n\t\t\t\t\t// initial min/max\n\t\t\t\t\twsc.min = min(wsc.min, s.min = minMax[0]);\n\t\t\t\t\twsc.max = max(wsc.max, s.max = minMax[1]);\n\t\t\t\t}\n\n\t\t\t\ts.idxs[0] = i0;\n\t\t\t\ts.idxs[1] = i1;\n\t\t\t});\n\n\t\t\t// range independent scales\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\n\t\t\t\tif (wsc.from == null && wsc.min != inf && pendScales[k] == null) {\n\t\t\t\t\tlet minMax = wsc.range(self, wsc.min, wsc.max, k);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// range dependent scales\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\n\t\t\t\tif (wsc.from != null) {\n\t\t\t\t\tlet base = wipScales[wsc.from];\n\n\t\t\t\t\tif (base.min != inf) {\n\t\t\t\t\t\tlet minMax = wsc.range(self, base.min, base.max, k);\n\t\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet changed = {};\n\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\tlet sc = scales[k];\n\n\t\t\t\tif (sc.min != wsc.min || sc.max != wsc.max) {\n\t\t\t\t\tsc.min = wsc.min;\n\t\t\t\t\tsc.max = wsc.max;\n\t\t\t\t\tchanged[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// invalidate paths of all series on changed scales\n\t\t\tseries.forEach(s => {\n\t\t\t\tif (changed[s.scale])\n\t\t\t\t\ts._paths = null;\n\t\t\t});\n\n\t\t\tfor (let k in changed)\n\t\t\t\tfire(\"setScale\", k);\n\t\t}\n\n\t\tfor (let k in pendScales)\n\t\t\tpendScales[k] = null;\n\n\t\t cursor.show && updateCursor();\n\t}\n\n\t// TODO: drawWrap(si, drawPoints) (save, restore, translate, clip)\n\n\tfunction drawPoints(si) {\n\t//\tlog(\"drawPoints()\", arguments);\n\n\t\tlet s = series[si];\n\t\tlet p = s.points;\n\n\t\tconst width = round3(p.width * pxRatio);\n\t\tconst offset = (width % 2) / 2;\n\t\tconst isStroked = p.width > 0;\n\n\t\tlet rad = (p.size - p.width) / 2 * pxRatio;\n\t\tlet dia = round3(rad * 2);\n\n\t\tctx.translate(offset, offset);\n\n\t\tctx.save();\n\n\t\tctx.beginPath();\n\t\tctx.rect(\n\t\t\tplotLft - dia,\n\t\t\tplotTop - dia,\n\t\t\tplotWid + dia * 2,\n\t\t\tplotHgt + dia * 2,\n\t\t);\n\t\tctx.clip();\n\n\t\tctx.globalAlpha = s.alpha;\n\n\t\tconst path = new Path2D();\n\n\t\tfor (let pi = i0; pi <= i1; pi++) {\n\t\t\tif (data[si][pi] != null) {\n\t\t\t\tlet x = round(getXPos(data[0][pi],  scales[xScaleKey], plotWid, plotLft));\n\t\t\t\tlet y = round(getYPos(data[si][pi], scales[s.scale],   plotHgt, plotTop));\n\n\t\t\t\tpath.moveTo(x + rad, y);\n\t\t\t\tpath.arc(x, y, rad, 0, PI * 2);\n\t\t\t}\n\t\t}\n\n\t\tsetCtxStyle(\n\t\t\tp.stroke || s.stroke || hexBlack,\n\t\t\twidth,\n\t\t\tnull,\n\t\t\tp.fill || (isStroked ? \"#fff\" : s.stroke || hexBlack),\n\t\t);\n\n\t\tctx.fill(path);\n\t\tisStroked && ctx.stroke(path);\n\n\t\tctx.globalAlpha = 1;\n\n\t\tctx.restore();\n\n\t\tctx.translate(-offset, -offset);\n\t}\n\n\t// grabs the nearest indices with y data outside of x-scale limits\n\tfunction getOuterIdxs(ydata) {\n\t\tlet _i0 = clamp(i0 - 1, 0, dataLen - 1);\n\t\tlet _i1 = clamp(i1 + 1, 0, dataLen - 1);\n\n\t\twhile (ydata[_i0] == null && _i0 > 0)\n\t\t\t_i0--;\n\n\t\twhile (ydata[_i1] == null && _i1 < dataLen - 1)\n\t\t\t_i1++;\n\n\t\treturn [_i0, _i1];\n\t}\n\n\tlet dir = 1;\n\n\tfunction drawSeries() {\n\t\t// path building loop must be before draw loop to ensure that all bands are fully constructed\n\t\tseries.forEach((s, i) => {\n\t\t\tif (i > 0 && s.show && dataLen > 0 && s._paths == null) {\n\t\t\t\tlet _idxs = getOuterIdxs(data[i]);\n\t\t\t\ts._paths = s.paths(self, i, _idxs[0], _idxs[1]);\n\t\t\t}\n\t\t});\n\n\t\tseries.forEach((s, i) => {\n\t\t\tif (i > 0 && s.show) {\n\t\t\t\tif (s._paths)\n\t\t\t\t\t drawPath(i);\n\n\t\t\t\tif (s.points.show(self, i, i0, i1))\n\t\t\t\t\t drawPoints(i);\n\n\t\t\t\tfire(\"drawSeries\", i);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction drawPath(si) {\n\t\tconst s = series[si];\n\n\t\tif (dir == 1) {\n\t\t\tconst { stroke, fill, clip } = s._paths;\n\t\t\tconst width = round3(s[WIDTH] * pxRatio);\n\t\t\tconst offset = (width % 2) / 2;\n\n\t\t\tsetCtxStyle(s.stroke, width, s.dash, s.fill);\n\n\t\t\tctx.globalAlpha = s.alpha;\n\n\t\t\tctx.translate(offset, offset);\n\n\t\t\tctx.save();\n\n\t\t\tlet lft = plotLft,\n\t\t\t\ttop = plotTop,\n\t\t\t\twid = plotWid,\n\t\t\t\thgt = plotHgt;\n\n\t\t\tlet halfWid = width * pxRatio / 2;\n\n\t\t\tif (s.min == 0)\n\t\t\t\thgt += halfWid;\n\n\t\t\tif (s.max == 0) {\n\t\t\t\ttop -= halfWid;\n\t\t\t\thgt += halfWid;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(lft, top, wid, hgt);\n\t\t\tctx.clip();\n\n\t\t\tif (clip != null)\n\t\t\t\tctx.clip(clip);\n\n\t\t\tif (s.band) {\n\t\t\t\tctx.fill(stroke);\n\t\t\t\twidth && ctx.stroke(stroke);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twidth && ctx.stroke(stroke);\n\n\t\t\t\tif (s.fill != null)\n\t\t\t\t\tctx.fill(fill);\n\t\t\t}\n\n\t\t\tctx.restore();\n\n\t\t\tctx.translate(-offset, -offset);\n\n\t\t\tctx.globalAlpha = 1;\n\t\t}\n\n\t\tif (s.band)\n\t\t\tdir *= -1;\n\t}\n\n\tfunction buildClip(is, gaps, nullHead, nullTail) {\n\t\tlet s = series[is];\n\n\t\tlet clip = null;\n\n\t\t// create clip path (invert gaps and non-gaps)\n\t\tif (gaps.length > 0) {\n\t\t\tif (s.spanGaps) {\n\t\t\t\tlet headGap = gaps[0];\n\t\t\t\tlet tailGap = gaps[gaps.length - 1];\n\t\t\t\tgaps = [];\n\n\t\t\t\tif (nullHead)\n\t\t\t\t\tgaps.push(headGap);\n\t\t\t\tif (nullTail)\n\t\t\t\t\tgaps.push(tailGap);\n\t\t\t}\n\n\t\t\tclip = new Path2D();\n\n\t\t\tlet prevGapEnd = plotLft;\n\n\t\t\tfor (let i = 0; i < gaps.length; i++) {\n\t\t\t\tlet g = gaps[i];\n\n\t\t\t\tclip.rect(prevGapEnd, plotTop, g[0] - prevGapEnd, plotTop + plotHgt);\n\n\t\t\t\tprevGapEnd = g[1];\n\t\t\t}\n\n\t\t\tclip.rect(prevGapEnd, plotTop, plotLft + plotWid - prevGapEnd, plotTop + plotHgt);\n\t\t}\n\n\t\treturn clip;\n\t}\n\n\tfunction addGap(gaps, outX, x) {\n\t\tlet prevGap = gaps[gaps.length - 1];\n\n\t\tif (prevGap && prevGap[0] == outX)\t\t\t// TODO: gaps must be encoded at stroke widths?\n\t\t\tprevGap[1] = x;\n\t\telse\n\t\t\tgaps.push([outX, x]);\n\t}\n\n\tfunction buildPaths(self, is, _i0, _i1) {\n\t\tconst s = series[is];\n\n\t\tconst xdata  = data[0];\n\t\tconst ydata  = data[is];\n\t\tconst scaleX = scales[xScaleKey];\n\t\tconst scaleY = scales[s.scale];\n\n\t\tconst _paths = dir == 1 ? {stroke: new Path2D(), fill: null, clip: null} : series[is-1]._paths;\n\t\tconst stroke = _paths.stroke;\n\t\tconst width = round3(s[WIDTH] * pxRatio);\n\n\t\tlet minY = inf,\n\t\t\tmaxY = -inf,\n\t\t\toutY, outX;\n\n\t\t// todo: don't build gaps on dir = -1 pass\n\t\tlet gaps = [];\n\n\t\tlet accX = round(getXPos(xdata[dir == 1 ? _i0 : _i1], scaleX, plotWid, plotLft));\n\n\t\t// the moves the shape edge outside the canvas so stroke doesnt bleed in\n\t\tif (s.band && dir == 1 && _i0 == i0) {\n\t\t\tif (width)\n\t\t\t\tstroke.lineTo(-width, round(getYPos(ydata[_i0], scaleY, plotHgt, plotTop)));\n\n\t\t\tif (scaleX.min < xdata[0])\n\t\t\t\tgaps.push([plotLft, accX - 1]);\n\t\t}\n\n\t\tfor (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {\n\t\t\tlet x = round(getXPos(xdata[i], scaleX, plotWid, plotLft));\n\n\t\t\tif (x == accX) {\n\t\t\t\tif (ydata[i] != null) {\n\t\t\t\t\toutY = round(getYPos(ydata[i], scaleY, plotHgt, plotTop));\n\t\t\t\t\tminY = min(outY, minY);\n\t\t\t\t\tmaxY = max(outY, maxY);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet _addGap = false;\n\n\t\t\t\tif (minY != inf) {\n\t\t\t\t\tstroke.lineTo(accX, minY);\n\t\t\t\t\tstroke.lineTo(accX, maxY);\n\t\t\t\t\tstroke.lineTo(accX, outY);\n\t\t\t\t\toutX = accX;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_addGap = true;\n\n\t\t\t\tif (ydata[i] != null) {\n\t\t\t\t\toutY = round(getYPos(ydata[i], scaleY, plotHgt, plotTop));\n\t\t\t\t\tstroke.lineTo(x, outY);\n\t\t\t\t\tminY = maxY = outY;\n\n\t\t\t\t\t// prior pixel can have data but still start a gap if ends with null\n\t\t\t\t\tif (x - accX > 1 && ydata[i-1] == null)\n\t\t\t\t\t\t_addGap = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminY = inf;\n\t\t\t\t\tmaxY = -inf;\n\t\t\t\t}\n\n\t\t\t\t_addGap && addGap(gaps, outX, x);\n\n\t\t\t\taccX = x;\n\t\t\t}\n\t\t}\n\n\t\t// extend or insert rightmost gap if no data exists to the right\n\t\tif (ydata[_i1] == null)\n\t\t\taddGap(gaps, outX, accX);\n\n\t\tif (s.band) {\n\t\t\tlet overShoot = width * 100, _iy, _x;\n\n\t\t\t// the moves the shape edge outside the canvas so stroke doesnt bleed in\n\t\t\tif (dir == -1 && _i0 == i0) {\n\t\t\t\t_x = plotLft - overShoot;\n\t\t\t\t_iy = _i0;\n\t\t\t}\n\n\t\t\tif (dir == 1 && _i1 == i1) {\n\t\t\t\t_x = plotLft + plotWid + overShoot;\n\t\t\t\t_iy = _i1;\n\n\t\t\t\tif (scaleX.max > xdata[dataLen - 1])\n\t\t\t\t\tgaps.push([accX, plotLft + plotWid]);\n\t\t\t}\n\n\t\t\tstroke.lineTo(_x, round(getYPos(ydata[_iy], scaleY, plotHgt, plotTop)));\n\t\t}\n\n\t\tif (dir == 1) {\n\t\t\t_paths.clip = buildClip(is, gaps, ydata[_i0] == null, ydata[_i1] == null);\n\n\t\t\tif (s.fill != null) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = round(getYPos(s.fillTo(self, is, s.min, s.max), scaleY, plotHgt, plotTop));\n\t\t\t\tfill.lineTo(plotLft + plotWid, fillTo);\n\t\t\t\tfill.lineTo(plotLft, fillTo);\n\t\t\t}\n\t\t}\n\n\t\tif (s.band)\n\t\t\tdir *= -1;\n\n\t\treturn _paths;\n\t}\n\n\tfunction getIncrSpace(axisIdx, min, max, fullDim) {\n\t\tlet axis = axes[axisIdx];\n\n\t\tlet incrSpace;\n\n\t\tif (fullDim <= 0)\n\t\t\tincrSpace = [0, 0];\n\t\telse {\n\t\t\tlet minSpace = axis.space(self, axisIdx, min, max, fullDim);\n\t\t\tlet incrs = axis.incrs(self, axisIdx, min, max, fullDim, minSpace);\n\t\t\tincrSpace = findIncr(min, max, incrs, fullDim, minSpace);\n\t\t}\n\n\t\treturn incrSpace;\n\t}\n\n\tfunction drawOrthoLines(offs, ori, side, pos0, len, width, stroke, dash) {\n\t\tlet offset = (width % 2) / 2;\n\n\t\tctx.translate(offset, offset);\n\n\t\tsetCtxStyle(stroke, width, dash);\n\n\t\tctx.beginPath();\n\n\t\tlet x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);\n\n\t\tif (ori == 0) {\n\t\t\ty0 = pos0;\n\t\t\ty1 = pos1;\n\t\t}\n\t\telse {\n\t\t\tx0 = pos0;\n\t\t\tx1 = pos1;\n\t\t}\n\n\t\toffs.forEach((off, i) => {\n\t\t\tif (ori == 0)\n\t\t\t\tx0 = x1 = off;\n\t\t\telse\n\t\t\t\ty0 = y1 = off;\n\n\t\t\tctx.moveTo(x0, y0);\n\t\t\tctx.lineTo(x1, y1);\n\t\t});\n\n\t\tctx.stroke();\n\n\t\tctx.translate(-offset, -offset);\n\t}\n\n\tfunction drawAxesGrid() {\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (!axis.show)\n\t\t\t\treturn;\n\n\t\t\tlet scale = scales[axis.scale];\n\n\t\t\t// this will happen if all series using a specific scale are toggled off\n\t\t\tif (scale.min == inf)\n\t\t\t\treturn;\n\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet {min, max} = scale;\n\n\t\t\tlet [incr, space] = getIncrSpace(i, min, max, ori == 0 ? plotWidCss : plotHgtCss);\n\n\t\t\t// if we're using index positions, force first tick to match passed index\n\t\t\tlet forceMin = scale.distr == 2;\n\n\t\t\tlet splits = axis.splits(self, i, min, max, incr, space, forceMin);\n\n\t\t\tlet getPos  = ori == 0 ? getXPos : getYPos;\n\t\t\tlet plotDim = ori == 0 ? plotWid : plotHgt;\n\t\t\tlet plotOff = ori == 0 ? plotLft : plotTop;\n\n\t\t\tlet canOffs = splits.map(val => round(getPos(val, scale, plotDim, plotOff)));\n\n\t\t\tlet axisGap  = round(axis.gap * pxRatio);\n\n\t\t\tlet ticks = axis.ticks;\n\t\t\tlet tickSize = ticks.show ? round(ticks.size * pxRatio) : 0;\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet values = axis.values(\n\t\t\t\tself,\n\t\t\t\tscale.distr == 2 ? splits.map(i => data0[i]) : splits,\n\t\t\t\ti,\n\t\t\t\tspace,\n\t\t\t\tscale.distr == 2 ? data0[splits[1]] -  data0[splits[0]] : incr,\n\t\t\t);\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\tlet angle = side == 2 ? axis.rotate(self, values, i, space) * -PI/180 : 0;\n\n\t\t\tlet basePos  = round(axis._pos * pxRatio);\n\t\t\tlet shiftAmt = tickSize + axisGap;\n\t\t\tlet shiftDir = ori == 0 && side == 0 || ori == 1 && side == 3 ? -1 : 1;\n\t\t\tlet finalPos = basePos + shiftAmt * shiftDir;\n\t\t\tlet y        = ori == 0 ? finalPos : 0;\n\t\t\tlet x        = ori == 1 ? finalPos : 0;\n\n\t\t\tctx.font         = axis.font[0];\n\t\t\tctx.fillStyle    = axis.stroke || hexBlack;\t\t\t\t\t\t\t\t\t// rgba?\n\t\t\tctx.textAlign    = angle > 0 ? LEFT :\n\t\t\t                   angle < 0 ? RIGHT :\n\t\t\t                   ori == 0 ? \"center\" : side == 3 ? RIGHT : LEFT;\n\t\t\tctx.textBaseline = angle ||\n\t\t\t                   ori == 1 ? \"middle\" : side == 2 ? TOP   : BOTTOM;\n\n\t\t\tlet lineHeight   = axis.font[1] * lineMult;\n\n\t\t\tvalues.forEach((val, i) => {\n\t\t\t\tif (ori == 0)\n\t\t\t\t\tx = canOffs[i];\n\t\t\t\telse\n\t\t\t\t\ty = canOffs[i];\n\n\t\t\t\t(\"\"+val).split(/\\n/gm).forEach((text, j) => {\n\t\t\t\t\tif (angle) {\n\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\tctx.translate(x, y + j * lineHeight);\n\t\t\t\t\t\tctx.rotate(angle);\n\t\t\t\t\t\tctx.fillText(text, 0, 0);\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tctx.fillText(text, x, y + j * lineHeight);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// axis label\n\t\t\tif (axis.label) {\n\t\t\t\tctx.save();\n\n\t\t\t\tlet baseLpos = round(axis._lpos * pxRatio);\n\n\t\t\t\tif (ori == 1) {\n\t\t\t\t\tx = y = 0;\n\n\t\t\t\t\tctx.translate(\n\t\t\t\t\t\tbaseLpos,\n\t\t\t\t\t\tround(plotTop + plotHgt / 2),\n\t\t\t\t\t);\n\t\t\t\t\tctx.rotate((side == 3 ? -PI : PI) / 2);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx = round(plotLft + plotWid / 2);\n\t\t\t\t\ty = baseLpos;\n\t\t\t\t}\n\n\t\t\t\tctx.font         = axis.labelFont[0];\n\t\t\t//\tctx.fillStyle    = axis.labelStroke || hexBlack;\t\t\t\t\t\t// rgba?\n\t\t\t\tctx.textAlign    = \"center\";\n\t\t\t\tctx.textBaseline = side == 2 ? TOP : BOTTOM;\n\n\t\t\t\tctx.fillText(axis.label, x, y);\n\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\t// ticks\n\t\t\tif (ticks.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tori,\n\t\t\t\t\tside,\n\t\t\t\t\tbasePos,\n\t\t\t\t\ttickSize,\n\t\t\t\t\tround3(ticks[WIDTH] * pxRatio),\n\t\t\t\t\tticks.stroke,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// grid\n\t\t\tlet grid = axis.grid;\n\n\t\t\tif (grid.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tori,\n\t\t\t\t\tori == 0 ? 2 : 1,\n\t\t\t\t\tori == 0 ? plotTop : plotLft,\n\t\t\t\t\tori == 0 ? plotHgt : plotWid,\n\t\t\t\t\tround3(grid[WIDTH] * pxRatio),\n\t\t\t\t\tgrid.stroke,\n\t\t\t\t\tgrid.dash,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tfire(\"drawAxes\");\n\t}\n\n\tfunction resetYSeries() {\n\t//\tlog(\"resetYSeries()\", arguments);\n\n\t\tseries.forEach((s, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\ts.min = inf;\n\t\t\t\ts.max = -inf;\n\t\t\t\ts._paths = null;\n\t\t\t}\n\t\t});\n\t}\n\n\tlet didPaint;\n\n\tfunction paint() {\n\t\tif (inBatch) {\n\t\t\tshouldPaint = true;\n\t\t\treturn;\n\t\t}\n\n\t//\tlog(\"paint()\", arguments);\n\n\t\tctx.clearRect(0, 0, can[WIDTH], can[HEIGHT]);\n\t\tfire(\"drawClear\");\n\t\tdrawAxesGrid();\n\t\tdrawSeries();\n\t\tdidPaint = true;\n\t\tfire(\"draw\");\n\t}\n\n\tself.redraw = rebuildPaths => {\n\t\tif (rebuildPaths !== false)\n\t\t\t_setScale(xScaleKey, scales[xScaleKey].min, scales[xScaleKey].max);\n\t\telse\n\t\t\tpaint();\n\t};\n\n\t// redraw() => setScale('x', scales.x.min, scales.x.max);\n\n\t// explicit, never re-ranged (is this actually true? for x and y)\n\tfunction setScale(key, opts) {\n\t\tlet sc = scales[key];\n\n\t\tif (sc.from == null) {\n\t\t\tif (key == xScaleKey) {\n\t\t\t\tif (sc.distr == 2) {\n\t\t\t\t\topts.min = closestIdx(opts.min, data[0]);\n\t\t\t\t\topts.max = closestIdx(opts.max, data[0]);\n\t\t\t\t}\n\n\t\t\t\t// prevent setting a temporal x scale too small since Date objects cannot advance ticks smaller than 1ms\n\t\t\t\tif ( sc.time && axes[0].show && opts.max > opts.min) {\n\t\t\t\t\t// since scales and axes are loosly coupled, we have to make some assumptions here :(\n\t\t\t\t\tlet incr = getIncrSpace(0, opts.min, opts.max, plotWidCss)[0];\n\n\t\t\t\t\tif (incr < 1e-3)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opts.max - opts.min < 1e-16)\n\t\t\t\treturn;\n\n\t\t//\tlog(\"setScale()\", arguments);\n\n\t\t\tpendScales[key] = opts;\n\n\t\t\tdidPaint = false;\n\t\t\tsetScales();\n\t\t\t!didPaint && paint();\n\t\t\tdidPaint = false;\n\t\t}\n\t}\n\n\tself.setScale = setScale;\n\n//\tINTERACTION\n\n\tlet vt;\n\tlet hz;\n\n\t// starting position before cursor.move\n\tlet rawMouseLeft0;\n\tlet rawMouseTop0;\n\n\t// starting position\n\tlet mouseLeft0;\n\tlet mouseTop0;\n\n\t// current position before cursor.move\n\tlet rawMouseLeft1;\n\tlet rawMouseTop1;\n\n\t// current position\n\tlet mouseLeft1;\n\tlet mouseTop1;\n\n\tlet dragging = false;\n\n\tconst drag =  cursor.drag;\n\n\tlet dragX =  drag.x;\n\tlet dragY =  drag.y;\n\n\tif ( cursor.show) {\n\t\tif (cursor.x) {\n\t\t\tmouseLeft1 = cursor.left;\n\t\t\tvt = placeDiv(CURSOR_X, over);\n\t\t}\n\n\t\tif (cursor.y) {\n\t\t\tmouseTop1 = cursor.top;\n\t\t\thz = placeDiv(CURSOR_Y, over);\n\t\t}\n\t}\n\n\tconst select = self.select = assign({\n\t\tshow:   true,\n\t\tleft:\t0,\n\t\twidth:\t0,\n\t\ttop:\t0,\n\t\theight:\t0,\n\t}, opts.select);\n\n\tconst selectDiv = select.show ? placeDiv(SELECT, over) : null;\n\n\tfunction setSelect(opts, _fire) {\n\t\tif (select.show) {\n\t\t\tfor (let prop in opts)\n\t\t\t\tsetStylePx(selectDiv, prop, select[prop] = opts[prop]);\n\n\t\t\t_fire !== false && fire(\"setSelect\");\n\t\t}\n\t}\n\n\tself.setSelect = setSelect;\n\n\tfunction toggleDOM(i, onOff) {\n\t\tlet s = series[i];\n\t\tlet label = showLegend ? legendRows[i][0].parentNode : null;\n\n\t\tif (s.show)\n\t\t\tlabel && remClass(label, OFF);\n\t\telse {\n\t\t\tlabel && addClass(label, OFF);\n\t\t\t cursorPts.length > 1 && trans(cursorPts[i], 0, -10);\n\t\t}\n\t}\n\n\tfunction _setScale(key, min, max) {\n\t\tsetScale(key, {min, max});\n\t}\n\n\tfunction setSeries(i, opts, pub) {\n\t//\tlog(\"setSeries()\", arguments);\n\n\t\tlet s = series[i];\n\n\t//\tbatch(() => {\n\t\t\t// will this cause redundant paint() if both show and focus are set?\n\t\t\tif (opts.focus != null)\n\t\t\t\tsetFocus(i);\n\n\t\t\tif (opts.show != null) {\n\t\t\t\ts.show = opts.show;\n\t\t\t\t toggleDOM(i, opts.show);\n\n\t\t\t\tif (s.band) {\n\t\t\t\t\t// not super robust, will break if two bands are adjacent\n\t\t\t\t\tlet ip = series[i+1] && series[i+1].band ? i+1 : i-1;\n\t\t\t\t\tseries[ip].show = s.show;\n\t\t\t\t\t toggleDOM(ip, opts.show);\n\t\t\t\t}\n\n\t\t\t\t_setScale(xScaleKey, scales[xScaleKey].min, scales[xScaleKey].max);\t\t// redraw\n\t\t\t}\n\t//\t});\n\n\t\t// firing setSeries after setScale seems out of order, but provides access to the updated props\n\t\t// could improve by predefining firing order and building a queue\n\t\tfire(\"setSeries\", i, opts);\n\n\t\t pub && sync.pub(\"setSeries\", self, i, opts);\n\t}\n\n\tself.setSeries = setSeries;\n\n\tfunction _alpha(i, value) {\n\t\tseries[i].alpha = value;\n\n\t\tif ( cursor.show && cursorPts[i])\n\t\t\tcursorPts[i].style.opacity = value;\n\n\t\tif ( showLegend && legendRows[i])\n\t\t\tlegendRows[i][0].parentNode.style.opacity = value;\n\t}\n\n\tfunction _setAlpha(i, value) {\n\t\tlet s = series[i];\n\n\t\t_alpha(i, value);\n\n\t\tif (s.band) {\n\t\t\t// not super robust, will break if two bands are adjacent\n\t\t\tlet ip = series[i+1].band ? i+1 : i-1;\n\t\t\t_alpha(ip, value);\n\t\t}\n\t}\n\n\t// y-distance\n\tlet closestDist;\n\tlet closestSeries;\n\tlet focusedSeries;\n\n\tfunction setFocus(i) {\n\t\tif (i != focusedSeries) {\n\t\t//\tlog(\"setFocus()\", arguments);\n\n\t\t\tseries.forEach((s, i2) => {\n\t\t\t\t_setAlpha(i2, i == null || i2 == 0 || i2 == i ? 1 : focus.alpha);\n\t\t\t});\n\n\t\t\tfocusedSeries = i;\n\t\t\tpaint();\n\t\t}\n\t}\n\n\tif (showLegend && cursorFocus) {\n\t\ton(mouseleave, legendEl, e => {\n\t\t\tif (cursor.locked)\n\t\t\t\treturn;\n\t\t\tsetSeries(null, {focus: false}, syncOpts.setSeries);\n\t\t\tupdateCursor();\n\t\t});\n\t}\n\n\tfunction scaleValueAtPos(pos, scale) {\n\t\tlet dim = plotWidCss;\n\n\t\tif (scale != xScaleKey) {\n\t\t\tdim = plotHgtCss;\n\t\t\tpos = dim - pos;\n\t\t}\n\n\t\tlet pct = pos / dim;\n\n\t\tlet sc = scales[scale],\n\t\t\t_min = sc.min,\n\t\t\t_max = sc.max;\n\n\t\tif (sc.distr == 3) {\n\t\t\t_min = log10(_min);\n\t\t\t_max = log10(_max);\n\t\t\treturn pow(10, _min + (_max - _min) * pct);\n\t\t}\n\t\telse\n\t\t\treturn _min + (_max - _min) * pct;\n\t}\n\n\tfunction closestIdxFromXpos(pos) {\n\t\tlet v = scaleValueAtPos(pos, xScaleKey);\n\t\treturn closestIdx(v, data[0], i0, i1);\n\t}\n\n\tself.valToIdx = val => closestIdx(val, data[0]);\n\tself.posToIdx = closestIdxFromXpos;\n\tself.posToVal = scaleValueAtPos;\n\tself.valToPos = (val, scale, can) => (\n\t\tscale == xScaleKey ?\n\t\tgetXPos(val, scales[scale],\n\t\t\tcan ? plotWid : plotWidCss,\n\t\t\tcan ? plotLft : 0,\n\t\t) :\n\t\tgetYPos(val, scales[scale],\n\t\t\tcan ? plotHgt : plotHgtCss,\n\t\t\tcan ? plotTop : 0,\n\t\t)\n\t);\n\n\tlet inBatch = false;\n\tlet shouldPaint = false;\n\tlet shouldSetScales = false;\n\tlet shouldUpdateCursor = false;\n\n\t// defers calling expensive functions\n\tfunction batch(fn) {\n\t\tinBatch = true;\n\t\tfn(self);\n\t\tinBatch = false;\n\t\tshouldSetScales && setScales();\n\t\t shouldUpdateCursor && updateCursor();\n\t\tshouldPaint && !didPaint && paint();\n\t\tshouldSetScales = shouldUpdateCursor = shouldPaint = didPaint = inBatch;\n\t}\n\n\tself.batch = batch;\n\n\t (self.setCursor = opts => {\n\t\tmouseLeft1 = opts.left;\n\t\tmouseTop1 = opts.top;\n\t//\tassign(cursor, opts);\n\t\tupdateCursor();\n\t});\n\n\tlet cursorRaf = 0;\n\n\tfunction updateCursor(ts, src) {\n\t\tif (inBatch) {\n\t\t\tshouldUpdateCursor = true;\n\t\t\treturn;\n\t\t}\n\n\t//\tts == null && log(\"updateCursor()\", arguments);\n\n\t\tcursorRaf = 0;\n\n\t\trawMouseLeft1 = mouseLeft1;\n\t\trawMouseTop1 = mouseTop1;\n\n\t\t[mouseLeft1, mouseTop1] = cursor.move(self, mouseLeft1, mouseTop1);\n\n\t\tif (cursor.show) {\n\t\t\tcursor.x && trans(vt,round(mouseLeft1),0);\n\t\t\tcursor.y && trans(hz,0,round(mouseTop1));\n\t\t}\n\n\t\tlet idx;\n\n\t\t// when zooming to an x scale range between datapoints the binary search\n\t\t// for nearest min/max indices results in this condition. cheap hack :D\n\t\tlet noDataInRange = i0 > i1;\n\n\t\tclosestDist = inf;\n\n\t\t// if cursor hidden, hide points & clear legend vals\n\t\tif (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {\n\t\t\tidx = null;\n\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\t cursorPts.length > 1 && trans(cursorPts[i], -10, -10);\n\t\t\t\t}\n\n\t\t\t\tif (showLegend && legend.live) {\n\t\t\t\t\tif (i == 0 && multiValLegend)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor (let j = 0; j < legendRows[i].length; j++)\n\t\t\t\t\t\tlegendRows[i][j][firstChild].nodeValue = '--';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cursorFocus)\n\t\t\t\tsetSeries(null, {focus: true}, syncOpts.setSeries);\n\t\t}\n\t\telse {\n\t\t//\tlet pctY = 1 - (y / rect[HEIGHT]);\n\n\t\t\tidx = closestIdxFromXpos(mouseLeft1);\n\n\t\t\tlet scX = scales[xScaleKey];\n\n\t\t\tlet xPos = round3(getXPos(data[0][idx], scX, plotWidCss, 0));\n\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tlet s = series[i];\n\n\t\t\t\tlet idx2 = cursor.dataIdx(self, i, idx);\n\t\t\t\tlet xPos2 = idx2 == idx ? xPos : round3(getXPos(data[0][idx2], scX, plotWidCss, 0));\n\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tlet valAtIdx = data[i][idx2];\n\n\t\t\t\t\tlet yPos = valAtIdx == null ? -10 : round3(getYPos(valAtIdx, scales[s.scale], plotHgtCss, 0));\n\n\t\t\t\t\tif (yPos > 0) {\n\t\t\t\t\t\tlet dist = abs(yPos - mouseTop1);\n\n\t\t\t\t\t\tif (dist <= closestDist) {\n\t\t\t\t\t\t\tclosestDist = dist;\n\t\t\t\t\t\t\tclosestSeries = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t cursorPts.length > 1 && trans(cursorPts[i], xPos2, yPos);\n\t\t\t\t}\n\n\t\t\t\tif (showLegend && legend.live) {\n\t\t\t\t\tif ((idx2 == cursor.idx && !forceUpdateLegend) || i == 0 && multiValLegend)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tlet src = i == 0 && xScaleDistr == 2 ? data0 : data[i];\n\n\t\t\t\t\tlet vals = multiValLegend ? s.values(self, i, idx2) : {_: s.value(self, src[idx2], i, idx2)};\n\n\t\t\t\t\tlet j = 0;\n\n\t\t\t\t\tfor (let k in vals)\n\t\t\t\t\t\tlegendRows[i][j++][firstChild].nodeValue = vals[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforceUpdateLegend = false;\n\t\t}\n\n\t\t// nit: cursor.drag.setSelect is assumed always true\n\t\tif (select.show && dragging) {\n\t\t\tif (src != null) {\n\t\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\n\t\t\t\t// match the dragX/dragY implicitness/explicitness of src\n\t\t\t\tlet sdrag = src.cursor.drag;\n\t\t\t\tdragX = sdrag._x;\n\t\t\t\tdragY = sdrag._y;\n\n\t\t\t\tif (xKey) {\n\t\t\t\t\tlet sc = scales[xKey];\n\t\t\t\t\tlet srcLeft = src.posToVal(src.select[LEFT], xKey);\n\t\t\t\t\tlet srcRight = src.posToVal(src.select[LEFT] + src.select[WIDTH], xKey);\n\n\t\t\t\t\tselect[LEFT] = getXPos(srcLeft, sc, plotWidCss, 0);\n\t\t\t\t\tselect[WIDTH] = abs(select[LEFT] - getXPos(srcRight, sc, plotWidCss, 0));\n\n\t\t\t\t\tsetStylePx(selectDiv, LEFT, select[LEFT]);\n\t\t\t\t\tsetStylePx(selectDiv, WIDTH, select[WIDTH]);\n\n\t\t\t\t\tif (!yKey) {\n\t\t\t\t\t\tsetStylePx(selectDiv, TOP, select[TOP] = 0);\n\t\t\t\t\t\tsetStylePx(selectDiv, HEIGHT, select[HEIGHT] = plotHgtCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (yKey) {\n\t\t\t\t\tlet sc = scales[yKey];\n\t\t\t\t\tlet srcTop = src.posToVal(src.select[TOP], yKey);\n\t\t\t\t\tlet srcBottom = src.posToVal(src.select[TOP] + src.select[HEIGHT], yKey);\n\n\t\t\t\t\tselect[TOP] = getYPos(srcTop, sc, plotHgtCss, 0);\n\t\t\t\t\tselect[HEIGHT] = abs(select[TOP] - getYPos(srcBottom, sc, plotHgtCss, 0));\n\n\t\t\t\t\tsetStylePx(selectDiv, TOP, select[TOP]);\n\t\t\t\t\tsetStylePx(selectDiv, HEIGHT, select[HEIGHT]);\n\n\t\t\t\t\tif (!xKey) {\n\t\t\t\t\t\tsetStylePx(selectDiv, LEFT, select[LEFT] = 0);\n\t\t\t\t\t\tsetStylePx(selectDiv, WIDTH, select[WIDTH] = plotWidCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet rawDX = abs(rawMouseLeft1 - rawMouseLeft0);\n\t\t\t\tlet rawDY = abs(rawMouseTop1 - rawMouseTop0);\n\n\t\t\t\tdragX = drag.x && rawDX >= drag.dist;\n\t\t\t\tdragY = drag.y && rawDY >= drag.dist;\n\n\t\t\t\tlet uni = drag.uni;\n\n\t\t\t\tif (uni != null) {\n\t\t\t\t\t// only calc drag status if they pass the dist thresh\n\t\t\t\t\tif (dragX && dragY) {\n\t\t\t\t\t\tdragX = rawDX >= uni;\n\t\t\t\t\t\tdragY = rawDY >= uni;\n\n\t\t\t\t\t\t// force unidirectionality when both are under uni limit\n\t\t\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\t\t\tif (rawDY > rawDX)\n\t\t\t\t\t\t\t\tdragY = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdragX = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (drag.x && drag.y && (dragX || dragY))\n\t\t\t\t\t// if omni with no uni then both dragX / dragY should be true if either is true\n\t\t\t\t\tdragX = dragY = true;\n\n\t\t\t\tif (dragX) {\n\t\t\t\t\tlet minX = min(mouseLeft0, mouseLeft1);\n\t\t\t\t\tlet dx = abs(mouseLeft1 - mouseLeft0);\n\n\t\t\t\t\tsetStylePx(selectDiv, LEFT,  select[LEFT] = minX);\n\t\t\t\t\tsetStylePx(selectDiv, WIDTH, select[WIDTH] = dx);\n\n\t\t\t\t\tif (!dragY) {\n\t\t\t\t\t\tsetStylePx(selectDiv, TOP, select[TOP] = 0);\n\t\t\t\t\t\tsetStylePx(selectDiv, HEIGHT, select[HEIGHT] = plotHgtCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dragY) {\n\t\t\t\t\tlet minY = min(mouseTop0, mouseTop1);\n\t\t\t\t\tlet dy = abs(mouseTop1 - mouseTop0);\n\n\t\t\t\t\tsetStylePx(selectDiv, TOP,    select[TOP] = minY);\n\t\t\t\t\tsetStylePx(selectDiv, HEIGHT, select[HEIGHT] = dy);\n\n\t\t\t\t\tif (!dragX) {\n\t\t\t\t\t\tsetStylePx(selectDiv, LEFT, select[LEFT] = 0);\n\t\t\t\t\t\tsetStylePx(selectDiv, WIDTH, select[WIDTH] = plotWidCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\t// the drag didn't pass the dist requirement\n\t\t\t\t\tsetStylePx(selectDiv, HEIGHT, select[HEIGHT] = 0);\n\t\t\t\t\tsetStylePx(selectDiv, WIDTH,  select[WIDTH]  = 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcursor.idx = idx;\n\t\tcursor.left = mouseLeft1;\n\t\tcursor.top = mouseTop1;\n\t\tdrag._x = dragX;\n\t\tdrag._y = dragY;\n\n\t\t// if ts is present, means we're implicitly syncing own cursor as a result of debounced rAF\n\t\tif (ts != null) {\n\t\t\t// this is not technically a \"mousemove\" event, since it's debounced, rename to setCursor?\n\t\t\t// since this is internal, we can tweak it later\n\t\t\tsync.pub(mousemove, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tsetSeries(closestDist <= focus.prox ? closestSeries : null, {focus: true}, syncOpts.setSeries);\n\t\t\t}\n\t\t}\n\n\t\tready && fire(\"setCursor\");\n\t}\n\n\tlet rect = null;\n\n\tfunction syncRect() {\n\t\trect = over.getBoundingClientRect();\n\t}\n\n\tfunction mouseMove(e, src, _x, _y, _w, _h, _i) {\n\t\tif (cursor.locked)\n\t\t\treturn;\n\n\t\tcacheMouse(e, src, _x, _y, _w, _h, _i, false, e != null);\n\n\t\tif (e != null) {\n\t\t\tif (cursorRaf == 0)\n\t\t\t\tcursorRaf = rAF(updateCursor);\n\t\t}\n\t\telse\n\t\t\tupdateCursor(null, src);\n\t}\n\n\tfunction cacheMouse(e, src, _x, _y, _w, _h, _i, initial, snap) {\n\t\tif (e != null) {\n\t\t\t_x = e.clientX - rect.left;\n\t\t\t_y = e.clientY - rect.top;\n\t\t}\n\t\telse {\n\t\t\tif (_x < 0 || _y < 0) {\n\t\t\t\tmouseLeft1 = -10;\n\t\t\t\tmouseTop1 = -10;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\n\t\t\tif (xKey != null)\n\t\t\t\t_x = getXPos(src.posToVal(_x, xKey), scales[xKey], plotWidCss, 0);\n\t\t\telse\n\t\t\t\t_x = plotWidCss * (_x/_w);\n\n\t\t\tif (yKey != null)\n\t\t\t\t_y = getYPos(src.posToVal(_y, yKey), scales[yKey], plotHgtCss, 0);\n\t\t\telse\n\t\t\t\t_y = plotHgtCss * (_y/_h);\n\t\t}\n\n\t\tif (snap) {\n\t\t\tif (_x <= 1 || _x >= plotWidCss - 1)\n\t\t\t\t_x = incrRound(_x, plotWidCss);\n\n\t\t\tif (_y <= 1 || _y >= plotHgtCss - 1)\n\t\t\t\t_y = incrRound(_y, plotHgtCss);\n\t\t}\n\n\t\tif (initial) {\n\t\t\trawMouseLeft0 = _x;\n\t\t\trawMouseTop0 = _y;\n\n\t\t\t[mouseLeft0, mouseTop0] = cursor.move(self, _x, _y);\n\t\t}\n\t\telse {\n\t\t\tmouseLeft1 = _x;\n\t\t\tmouseTop1 = _y;\n\t\t}\n\t}\n\n\tfunction hideSelect() {\n\t\tsetSelect({\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t}, false);\n\t}\n\n\tfunction mouseDown(e, src, _x, _y, _w, _h, _i) {\n\t\tif (src != null || filtMouse(e)) {\n\t\t\tdragging = true;\n\t\t\tdragX = dragY = drag._x = drag._y = false;\n\n\t\t\tcacheMouse(e, src, _x, _y, _w, _h, _i, true, false);\n\n\t\t\tif (e != null) {\n\t\t\t\ton(mouseup, doc, mouseUp);\n\t\t\t\tsync.pub(mousedown, self, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction mouseUp(e, src, _x, _y, _w, _h, _i) {\n\t\tif (src != null || filtMouse(e)) {\n\t\t\tdragging = drag._x = drag._y = false;\n\n\t\t\tcacheMouse(e, src, _x, _y, _w, _h, _i, false, true);\n\n\t\t\tlet hasSelect = select[WIDTH] > 0 || select[HEIGHT] > 0;\n\n\t\t\thasSelect && setSelect(select);\n\n\t\t\tif (drag.setScale && hasSelect) {\n\t\t\t//\tif (syncKey != null) {\n\t\t\t//\t\tdragX = drag.x;\n\t\t\t//\t\tdragY = drag.y;\n\t\t\t//\t}\n\n\t\t\t\tbatch(() => {\n\t\t\t\t\tif (dragX) {\n\t\t\t\t\t\t_setScale(xScaleKey,\n\t\t\t\t\t\t\tscaleValueAtPos(select[LEFT], xScaleKey),\n\t\t\t\t\t\t\tscaleValueAtPos(select[LEFT] + select[WIDTH], xScaleKey)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dragY) {\n\t\t\t\t\t\tfor (let k in scales) {\n\t\t\t\t\t\t\tlet sc = scales[k];\n\n\t\t\t\t\t\t\tif (k != xScaleKey && sc.from == null) {\n\t\t\t\t\t\t\t\t_setScale(k,\n\t\t\t\t\t\t\t\t\tscaleValueAtPos(select[TOP] + select[HEIGHT], k),\n\t\t\t\t\t\t\t\t\tscaleValueAtPos(select[TOP], k)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thideSelect();\n\t\t\t}\n\t\t\telse if (cursor.lock) {\n\t\t\t\tcursor.locked = !cursor.locked;\n\n\t\t\t\tif (!cursor.locked)\n\t\t\t\t\tupdateCursor();\n\t\t\t}\n\t\t}\n\n\t\tif (e != null) {\n\t\t\toff(mouseup, doc, mouseUp);\n\t\t\tsync.pub(mouseup, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t\t}\n\t}\n\n\tfunction mouseLeave(e, src, _x, _y, _w, _h, _i) {\n\t\tif (!cursor.locked) {\n\t\t\tlet _dragging = dragging;\n\n\t\t\tif (dragging) {\n\t\t\t\t// handle case when mousemove aren't fired all the way to edges by browser\n\t\t\t\tlet snapX = true;\n\t\t\t\tlet snapY = true;\n\t\t\t\tlet snapProx = 10;\n\n\t\t\t\tif (dragX && dragY) {\n\t\t\t\t\t// maybe omni corner snap\n\t\t\t\t\tsnapX = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;\n\t\t\t\t\tsnapY = mouseTop1  <= snapProx || mouseTop1  >= plotHgtCss - snapProx;\n\t\t\t\t}\n\n\t\t\t\tif (dragX && snapX) {\n\t\t\t\t\tlet dLft = mouseLeft1;\n\t\t\t\t\tlet dRgt = plotWidCss - mouseLeft1;\n\n\t\t\t\t\tlet xMin = min(dLft, dRgt);\n\n\t\t\t\t\tif (xMin == dLft)\n\t\t\t\t\t\tmouseLeft1 = 0;\n\t\t\t\t\tif (xMin == dRgt)\n\t\t\t\t\t\tmouseLeft1 = plotWidCss;\n\t\t\t\t}\n\n\t\t\t\tif (dragY && snapY) {\n\t\t\t\t\tlet dTop = mouseTop1;\n\t\t\t\t\tlet dBtm = plotHgtCss - mouseTop1;\n\n\t\t\t\t\tlet yMin = min(dTop, dBtm);\n\n\t\t\t\t\tif (yMin == dTop)\n\t\t\t\t\t\tmouseTop1 = 0;\n\t\t\t\t\tif (yMin == dBtm)\n\t\t\t\t\t\tmouseTop1 = plotHgtCss;\n\t\t\t\t}\n\n\t\t\t\tupdateCursor(1);\n\n\t\t\t\tdragging = false;\n\t\t\t}\n\n\t\t\tmouseLeft1 = -10;\n\t\t\tmouseTop1 = -10;\n\n\t\t\t// passing a non-null timestamp to force sync/mousemove event\n\t\t\tupdateCursor(1);\n\n\t\t\tif (_dragging)\n\t\t\t\tdragging = _dragging;\n\t\t}\n\t}\n\n\tfunction dblClick(e, src, _x, _y, _w, _h, _i) {\n\t\tautoScaleX();\n\n\t\thideSelect();\n\n\t\tif (e != null)\n\t\t\tsync.pub(dblclick, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t}\n\n\t// internal pub/sub\n\tconst events = {};\n\n\tevents[mousedown] = mouseDown;\n\tevents[mousemove] = mouseMove;\n\tevents[mouseup] = mouseUp;\n\tevents[dblclick] = dblClick;\n\tevents[\"setSeries\"] = (e, src, idx, opts) => {\n\t\tsetSeries(idx, opts);\n\t};\n\n\tlet deb;\n\n\tif ( cursor.show) {\n\t\ton(mousedown, over, mouseDown);\n\t\ton(mousemove, over, mouseMove);\n\t\ton(mouseenter, over, syncRect);\n\t\t// this has to be rAF'd so it always fires after the last queued/rAF'd updateCursor\n\t\ton(mouseleave, over, e => { rAF(mouseLeave); });\n\n\t\ton(dblclick, over, dblClick);\n\n\t\tdeb = debounce(syncRect, 100);\n\n\t\ton(resize, win, deb);\n\t\ton(scroll, win, deb);\n\n\t\tself.syncRect = syncRect;\n\t}\n\n\t// external on/off\n\tconst hooks = self.hooks = opts.hooks || {};\n\n\tfunction fire(evName, a1, a2) {\n\t\tif (evName in hooks) {\n\t\t\thooks[evName].forEach(fn => {\n\t\t\t\tfn.call(null, self, a1, a2);\n\t\t\t});\n\t\t}\n\t}\n\n\t(opts.plugins || []).forEach(p => {\n\t\tfor (let evName in p.hooks)\n\t\t\thooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);\n\t});\n\n\tconst syncOpts =  assign({\n\t\tkey: null,\n\t\tsetSeries: false,\n\t\tscales: [xScaleKey, null]\n\t}, cursor.sync);\n\n\tconst syncKey =  syncOpts.key;\n\n\tconst sync =  (syncKey != null ? (syncs[syncKey] = syncs[syncKey] || _sync()) : _sync());\n\n\t sync.sub(self);\n\n\tfunction pub(type, src, x, y, w, h, i) {\n\t\tevents[type](null, src, x, y, w, h, i);\n\t}\n\n\t (self.pub = pub);\n\n\tfunction destroy() {\n\t\t sync.unsub(self);\n\t\t off(resize, win, deb);\n\t\t off(scroll, win, deb);\n\t\troot.remove();\n\t\tfire(\"destroy\");\n\t}\n\n\tself.destroy = destroy;\n\n\tfunction _init() {\n\t\t_setSize(opts[WIDTH], opts[HEIGHT]);\n\n\t\tfire(\"init\", opts, data);\n\n\t\tsetData(data || opts.data, false);\n\n\t\tif (pendScales[xScaleKey])\n\t\t\tsetScale(xScaleKey, pendScales[xScaleKey]);\n\t\telse\n\t\t\tautoScaleX();\n\n\t\tsetSelect(select, false);\n\n\t\tready = true;\n\n\t\tfire(\"ready\");\n\t}\n\n\tif (then) {\n\t\tif (then instanceof HTMLElement) {\n\t\t\tthen.appendChild(root);\n\t\t\t_init();\n\t\t}\n\t\telse\n\t\t\tthen(self, _init);\n\t}\n\telse\n\t\t_init();\n\n\treturn self;\n}\n\nuPlot.assign = assign;\nuPlot.fmtNum = fmtNum;\nuPlot.rangeNum = rangeNum;\nuPlot.rangeLog = rangeLog;\n\n{\n\tuPlot.fmtDate = fmtDate;\n\tuPlot.tzDate  = tzDate;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (uPlot);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXBsb3QvZGlzdC91UGxvdC5lc20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXBsb3QvZGlzdC91UGxvdC5lc20uanM/YWI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQ29weXJpZ2h0IChjKSAyMDIwLCBMZW9uIFNvcm9raW5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbipcbiogdVBsb3QuanMgKM68UGxvdClcbiogQSBzbWFsbCwgZmFzdCBjaGFydCBmb3IgdGltZSBzZXJpZXMsIGxpbmVzLCBhcmVhcywgb2hsYyAmIGJhcnNcbiogaHR0cHM6Ly9naXRodWIuY29tL2xlZW9uaXlhL3VQbG90ICh2MS4xLjIpXG4qL1xuXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgdGltZSkge1xuXHRsZXQgcGVuZGluZyA9IG51bGw7XG5cblx0ZnVuY3Rpb24gcnVuKCkge1xuXHRcdHBlbmRpbmcgPSBudWxsO1xuXHRcdGZuKCk7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHBlbmRpbmcpO1xuXHRcdHBlbmRpbmcgPSBzZXRUaW1lb3V0KHJ1biwgdGltZSk7XG5cdH1cbn1cblxuLy8gYmluYXJ5IHNlYXJjaCBmb3IgaW5kZXggb2YgY2xvc2VzdCB2YWx1ZVxuZnVuY3Rpb24gY2xvc2VzdElkeChudW0sIGFyciwgbG8sIGhpKSB7XG5cdGxldCBtaWQ7XG5cdGxvID0gbG8gfHwgMDtcblx0aGkgPSBoaSB8fCBhcnIubGVuZ3RoIC0gMTtcblx0bGV0IGJpdHdpc2UgPSBoaSA8PSAyMTQ3NDgzNjQ3O1xuXG5cdHdoaWxlIChoaSAtIGxvID4gMSkge1xuXHRcdG1pZCA9IGJpdHdpc2UgPyAobG8gKyBoaSkgPj4gMSA6IGZsb29yKChsbyArIGhpKSAvIDIpO1xuXG5cdFx0aWYgKGFyclttaWRdIDwgbnVtKVxuXHRcdFx0bG8gPSBtaWQ7XG5cdFx0ZWxzZVxuXHRcdFx0aGkgPSBtaWQ7XG5cdH1cblxuXHRpZiAobnVtIC0gYXJyW2xvXSA8PSBhcnJbaGldIC0gbnVtKVxuXHRcdHJldHVybiBsbztcblxuXHRyZXR1cm4gaGk7XG59XG5cbmZ1bmN0aW9uIGdldE1pbk1heChkYXRhLCBfaTAsIF9pMSwgc29ydGVkKSB7XG4vL1x0Y29uc29sZS5sb2coXCJnZXRNaW5NYXgoKVwiKTtcblxuXHRsZXQgX21pbiA9IGluZjtcblx0bGV0IF9tYXggPSAtaW5mO1xuXG5cdGlmIChzb3J0ZWQgPT0gMSkge1xuXHRcdF9taW4gPSBkYXRhW19pMF07XG5cdFx0X21heCA9IGRhdGFbX2kxXTtcblx0fVxuXHRlbHNlIGlmIChzb3J0ZWQgPT0gLTEpIHtcblx0XHRfbWluID0gZGF0YVtfaTFdO1xuXHRcdF9tYXggPSBkYXRhW19pMF07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Zm9yIChsZXQgaSA9IF9pMDsgaSA8PSBfaTE7IGkrKykge1xuXHRcdFx0aWYgKGRhdGFbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRfbWluID0gbWluKF9taW4sIGRhdGFbaV0pO1xuXHRcdFx0XHRfbWF4ID0gbWF4KF9tYXgsIGRhdGFbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbX21pbiwgX21heF07XG59XG5cbmZ1bmN0aW9uIHJhbmdlTG9nKG1pbiwgbWF4LCBmdWxsTWFncykge1xuXHRpZiAobWluID09IG1heCkge1xuXHRcdG1pbiAvPSAxMDtcblx0XHRtYXggKj0gMTA7XG5cdH1cblxuXHRsZXQgbWluSW5jciwgbWF4SW5jcjtcblxuXHRpZiAoZnVsbE1hZ3MpIHtcblx0XHRtaW4gPSBtaW5JbmNyID0gcG93KDEwLCBmbG9vcihsb2cxMChtaW4pKSk7XG5cdFx0bWF4ID0gbWF4SW5jciA9IHBvdygxMCwgIGNlaWwobG9nMTAobWF4KSkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdG1pbkluY3IgICAgICAgPSBwb3coMTAsIGZsb29yKGxvZzEwKG1pbikpKTtcblx0XHRtYXhJbmNyICAgICAgID0gcG93KDEwLCBmbG9vcihsb2cxMChtYXgpKSk7XG5cblx0XHRtaW4gICAgICAgICAgID0gaW5jclJvdW5kRG4obWluLCBtaW5JbmNyKTtcblx0XHRtYXggICAgICAgICAgID0gaW5jclJvdW5kVXAobWF4LCBtYXhJbmNyKTtcblx0fVxuXG5cdHJldHVybiBbXG5cdFx0K21pbi50b0ZpeGVkKGZpeGVkRGVjLmdldChtaW5JbmNyKSksXG5cdFx0K21heC50b0ZpeGVkKGZpeGVkRGVjLmdldChtYXhJbmNyKSksXG5cdF07XG59XG5cbi8vIHRoaXMgZW5zdXJlcyB0aGF0IG5vbi10ZW1wb3JhbC9udW1lcmljIHktYXhlcyBnZXQgbXVsdGlwbGUtc25hcHBlZCBwYWRkaW5nIGFkZGVkIGFib3ZlL2JlbG93XG4vLyBUT0RPOiBhbHNvIGFjY291bnQgZm9yIGluY3JzIHdoZW4gc25hcHBpbmcgdG8gZW5zdXJlIHRvcCBvZiBheGlzIGdldHMgYSB0aWNrICYgdmFsdWVcbmZ1bmN0aW9uIHJhbmdlTnVtKG1pbiwgbWF4LCBtdWx0LCBleHRyYSkge1xuXHQvLyBhdXRvLXNjYWxlIFlcblx0Y29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG5cdGNvbnN0IG5vblplcm9EZWx0YSA9IGRlbHRhIHx8IGFicyhtYXgpIHx8IDFlMztcblx0Y29uc3QgbWFnID0gbG9nMTAobm9uWmVyb0RlbHRhKTtcblx0Y29uc3QgYmFzZSA9IHBvdygxMCwgZmxvb3IobWFnKSk7XG5cblx0Y29uc3QgcGFkZGluZyA9IG5vblplcm9EZWx0YSAqIG11bHQ7XG5cdGNvbnN0IG5ld01pbiA9IG1pbiAtIHBhZGRpbmc7XG5cdGNvbnN0IG5ld01heCA9IG1heCArIHBhZGRpbmc7XG5cblx0bGV0IHNuYXBwZWRNaW4gPSByb3VuZDYoaW5jclJvdW5kRG4obmV3TWluLCBiYXNlLzEwMCkpO1xuXHRsZXQgc25hcHBlZE1heCA9IHJvdW5kNihpbmNyUm91bmRVcChuZXdNYXgsIGJhc2UvMTAwKSk7XG5cblx0aWYgKGV4dHJhKSB7XG5cdFx0Ly8gZm9yIGZsYXQgZGF0YSwgYWx3YXlzIHVzZSAwIGFzIG9uZSBjaGFydCBleHRyZW1lICYgcGxhY2UgZGF0YSBpbiBjZW50ZXJcblx0XHRpZiAoZGVsdGEgPT0gMCkge1xuXHRcdFx0aWYgKG1heCA+IDApXG5cdFx0XHRcdHNuYXBwZWRNaW4gPSAwO1xuXHRcdFx0ZWxzZSBpZiAobWF4IDwgMClcblx0XHRcdFx0c25hcHBlZE1heCA9IDA7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gaWYgb3JpZ2luYWwgZGF0YSBuZXZlciBjcm9zc2VzIDAsIHVzZSAwIGFzIG9uZSBjaGFydCBleHRyZW1lXG5cdFx0XHRpZiAobWluID49IDAgJiYgc25hcHBlZE1pbiA8IDApXG5cdFx0XHRcdHNuYXBwZWRNaW4gPSAwO1xuXG5cdFx0XHRpZiAobWF4IDw9IDAgJiYgc25hcHBlZE1heCA+IDApXG5cdFx0XHRcdHNuYXBwZWRNYXggPSAwO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbc25hcHBlZE1pbiwgc25hcHBlZE1heF07XG59XG5cbi8vIGFsdGVybmF0aXZlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI1NDg5NlxuY29uc3QgZm10TnVtID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KG5hdmlnYXRvci5sYW5ndWFnZSkuZm9ybWF0O1xuXG5jb25zdCBNID0gTWF0aDtcblxuY29uc3QgYWJzID0gTS5hYnM7XG5jb25zdCBmbG9vciA9IE0uZmxvb3I7XG5jb25zdCByb3VuZCA9IE0ucm91bmQ7XG5jb25zdCBjZWlsID0gTS5jZWlsO1xuY29uc3QgbWluID0gTS5taW47XG5jb25zdCBtYXggPSBNLm1heDtcbmNvbnN0IHBvdyA9IE0ucG93O1xuY29uc3QgbG9nMTAgPSBNLmxvZzEwO1xuY29uc3QgUEkgPSBNLlBJO1xuXG5jb25zdCBpbmYgPSBJbmZpbml0eTtcblxuZnVuY3Rpb24gaW5jclJvdW5kKG51bSwgaW5jcikge1xuXHRyZXR1cm4gcm91bmQobnVtL2luY3IpKmluY3I7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG51bSwgX21pbiwgX21heCkge1xuXHRyZXR1cm4gbWluKG1heChudW0sIF9taW4pLCBfbWF4KTtcbn1cblxuZnVuY3Rpb24gZm5PclNlbGYodikge1xuXHRyZXR1cm4gdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdiA6ICgpID0+IHY7XG59XG5cbmZ1bmN0aW9uIGluY3JSb3VuZFVwKG51bSwgaW5jcikge1xuXHRyZXR1cm4gY2VpbChudW0vaW5jcikqaW5jcjtcbn1cblxuZnVuY3Rpb24gaW5jclJvdW5kRG4obnVtLCBpbmNyKSB7XG5cdHJldHVybiBmbG9vcihudW0vaW5jcikqaW5jcjtcbn1cblxuZnVuY3Rpb24gcm91bmQzKHZhbCkge1xuXHRyZXR1cm4gcm91bmQodmFsICogMWUzKSAvIDFlMztcbn1cblxuZnVuY3Rpb24gcm91bmQ2KHZhbCkge1xuXHRyZXR1cm4gcm91bmQodmFsICogMWU2KSAvIDFlNjtcbn1cblxuY29uc3QgZml4ZWREZWMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGdlbkluY3JzKG1pbkV4cCwgbWF4RXhwLCBtdWx0cykge1xuXHRsZXQgaW5jcnMgPSBbXTtcblxuXHRmb3IgKGxldCBleHAgPSBtaW5FeHA7IGV4cCA8IG1heEV4cDsgZXhwKyspIHtcblx0XHRsZXQgbWFnID0gcG93KDEwLCBleHApO1xuXHRcdGxldCBleHBhID0gYWJzKGV4cCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG11bHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgaW5jciA9ICsobXVsdHNbaV0gKiBtYWcpLnRvRml4ZWQoZXhwYSk7XG5cdFx0XHRpbmNycy5wdXNoKGluY3IpO1xuXHRcdFx0Zml4ZWREZWMuc2V0KGluY3IsIGluY3IgPCAxID8gZXhwYSA6IDApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBpbmNycztcbn1cblxuLy9leHBvcnQgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cih2KSB7XG5cdHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqKHYpIHtcblx0cmV0dXJuIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5KG8pIHtcblx0bGV0IG91dDtcblxuXHRpZiAoaXNBcnIobykpXG5cdFx0b3V0ID0gby5tYXAoY29weSk7XG5cdGVsc2UgaWYgKGlzT2JqKG8pKSB7XG5cdFx0b3V0ID0ge307XG5cdFx0Zm9yICh2YXIgayBpbiBvKVxuXHRcdFx0b3V0W2tdID0gY29weShvW2tdKTtcblx0fVxuXHRlbHNlXG5cdFx0b3V0ID0gbztcblxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZykge1xuXHRsZXQgYXJncyA9IGFyZ3VtZW50cztcblxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgc3JjID0gYXJnc1tpXTtcblxuXHRcdGZvciAobGV0IGtleSBpbiBzcmMpIHtcblx0XHRcdGlmIChpc09iaih0YXJnW2tleV0pKVxuXHRcdFx0XHRhc3NpZ24odGFyZ1trZXldLCBjb3B5KHNyY1trZXldKSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRhcmdba2V5XSA9IGNvcHkoc3JjW2tleV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YXJnO1xufVxuXG5jb25zdCBXSURUSCA9IFwid2lkdGhcIjtcbmNvbnN0IEhFSUdIVCA9IFwiaGVpZ2h0XCI7XG5jb25zdCBUT1AgPSBcInRvcFwiO1xuY29uc3QgQk9UVE9NID0gXCJib3R0b21cIjtcbmNvbnN0IExFRlQgPSBcImxlZnRcIjtcbmNvbnN0IFJJR0hUID0gXCJyaWdodFwiO1xuY29uc3QgZmlyc3RDaGlsZCA9IFwiZmlyc3RDaGlsZFwiO1xuY29uc3QgY3JlYXRlRWxlbWVudCA9IFwiY3JlYXRlRWxlbWVudFwiO1xuY29uc3QgaGV4QmxhY2sgPSBcIiMwMDBcIjtcbmNvbnN0IGNsYXNzTGlzdCA9IFwiY2xhc3NMaXN0XCI7XG5cbmNvbnN0IG1vdXNlbW92ZSA9IFwibW91c2Vtb3ZlXCI7XG5jb25zdCBtb3VzZWRvd24gPSBcIm1vdXNlZG93blwiO1xuY29uc3QgbW91c2V1cCA9IFwibW91c2V1cFwiO1xuY29uc3QgbW91c2VlbnRlciA9IFwibW91c2VlbnRlclwiO1xuY29uc3QgbW91c2VsZWF2ZSA9IFwibW91c2VsZWF2ZVwiO1xuY29uc3QgZGJsY2xpY2sgPSBcImRibGNsaWNrXCI7XG5jb25zdCByZXNpemUgPSBcInJlc2l6ZVwiO1xuY29uc3Qgc2Nyb2xsID0gXCJzY3JvbGxcIjtcblxuY29uc3QgcHJlID0gXCJ1LVwiO1xuXG5jb25zdCBVUExPVCAgICAgICAgICA9ICAgICAgIFwidXBsb3RcIjtcbmNvbnN0IFRJVExFICAgICAgICAgID0gcHJlICsgXCJ0aXRsZVwiO1xuY29uc3QgV1JBUCAgICAgICAgICAgPSBwcmUgKyBcIndyYXBcIjtcbmNvbnN0IFVOREVSICAgICAgICAgID0gcHJlICsgXCJ1bmRlclwiO1xuY29uc3QgT1ZFUiAgICAgICAgICAgPSBwcmUgKyBcIm92ZXJcIjtcbmNvbnN0IE9GRiAgICAgICAgICAgID0gcHJlICsgXCJvZmZcIjtcbmNvbnN0IFNFTEVDVCAgICAgICAgID0gcHJlICsgXCJzZWxlY3RcIjtcbmNvbnN0IENVUlNPUl9YICAgICAgID0gcHJlICsgXCJjdXJzb3IteFwiO1xuY29uc3QgQ1VSU09SX1kgICAgICAgPSBwcmUgKyBcImN1cnNvci15XCI7XG5jb25zdCBDVVJTT1JfUFQgICAgICA9IHByZSArIFwiY3Vyc29yLXB0XCI7XG5jb25zdCBMRUdFTkQgICAgICAgICA9IHByZSArIFwibGVnZW5kXCI7XG5jb25zdCBMRUdFTkRfTElWRSAgICA9IHByZSArIFwibGl2ZVwiO1xuY29uc3QgTEVHRU5EX0lOTElORSAgPSBwcmUgKyBcImlubGluZVwiO1xuY29uc3QgTEVHRU5EX1RIRUFEICAgPSBwcmUgKyBcInRoZWFkXCI7XG5jb25zdCBMRUdFTkRfU0VSSUVTICA9IHByZSArIFwic2VyaWVzXCI7XG5jb25zdCBMRUdFTkRfTUFSS0VSICA9IHByZSArIFwibWFya2VyXCI7XG5jb25zdCBMRUdFTkRfTEFCRUwgICA9IHByZSArIFwibGFiZWxcIjtcbmNvbnN0IExFR0VORF9WQUxVRSAgID0gcHJlICsgXCJ2YWx1ZVwiO1xuXG5jb25zdCByQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5jb25zdCBkb2MgPSBkb2N1bWVudDtcbmNvbnN0IHdpbiA9IHdpbmRvdztcbmNvbnN0IHB4UmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgYykge1xuXHRjICE9IG51bGwgJiYgZWxbY2xhc3NMaXN0XS5hZGQoYyk7XG59XG5cbmZ1bmN0aW9uIHJlbUNsYXNzKGVsLCBjKSB7XG5cdGVsW2NsYXNzTGlzdF0ucmVtb3ZlKGMpO1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVB4KGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRlbC5zdHlsZVtuYW1lXSA9IHZhbHVlICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBwbGFjZVRhZyh0YWcsIGNscywgdGFyZywgcmVmRWwpIHtcblx0bGV0IGVsID0gZG9jW2NyZWF0ZUVsZW1lbnRdKHRhZyk7XG5cblx0aWYgKGNscyAhPSBudWxsKVxuXHRcdGFkZENsYXNzKGVsLCBjbHMpO1xuXG5cdGlmICh0YXJnICE9IG51bGwpXG5cdFx0dGFyZy5pbnNlcnRCZWZvcmUoZWwsIHJlZkVsKTtcblxuXHRyZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIHBsYWNlRGl2KGNscywgdGFyZykge1xuXHRyZXR1cm4gcGxhY2VUYWcoXCJkaXZcIiwgY2xzLCB0YXJnKTtcbn1cblxuZnVuY3Rpb24gdHJhbnMoZWwsIHhQb3MsIHlQb3MpIHtcblx0ZWwuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4UG9zICsgXCJweCxcIiArIHlQb3MgKyBcInB4KVwiO1xufVxuXG5jb25zdCBldk9wdHMgPSB7cGFzc2l2ZTogdHJ1ZX07XG5cbmZ1bmN0aW9uIG9uKGV2LCBlbCwgY2IpIHtcblx0ZWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgY2IsIGV2T3B0cyk7XG59XG5cbmZ1bmN0aW9uIG9mZihldiwgZWwsIGNiKSB7XG5cdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIGNiLCBldk9wdHMpO1xufVxuXG5jb25zdCBtb250aHMgPSBbXG5cdFwiSmFudWFyeVwiLFxuXHRcIkZlYnJ1YXJ5XCIsXG5cdFwiTWFyY2hcIixcblx0XCJBcHJpbFwiLFxuXHRcIk1heVwiLFxuXHRcIkp1bmVcIixcblx0XCJKdWx5XCIsXG5cdFwiQXVndXN0XCIsXG5cdFwiU2VwdGVtYmVyXCIsXG5cdFwiT2N0b2JlclwiLFxuXHRcIk5vdmVtYmVyXCIsXG5cdFwiRGVjZW1iZXJcIixcbl07XG5cbmNvbnN0IGRheXMgPSBbXG5cdFwiU3VuZGF5XCIsXG5cdFwiTW9uZGF5XCIsXG5cdFwiVHVlc2RheVwiLFxuXHRcIldlZG5lc2RheVwiLFxuXHRcIlRodXJzZGF5XCIsXG5cdFwiRnJpZGF5XCIsXG5cdFwiU2F0dXJkYXlcIixcbl07XG5cbmZ1bmN0aW9uIHNsaWNlMyhzdHIpIHtcblx0cmV0dXJuIHN0ci5zbGljZSgwLCAzKTtcbn1cblxuY29uc3QgZGF5czMgPSAgZGF5cy5tYXAoc2xpY2UzKTtcblxuY29uc3QgbW9udGhzMyA9ICBtb250aHMubWFwKHNsaWNlMyk7XG5cbmNvbnN0IGVuZ05hbWVzID0ge1xuXHRNTU1NOiBtb250aHMsXG5cdE1NTTogIG1vbnRoczMsXG5cdFdXV1c6IGRheXMsXG5cdFdXVzogIGRheXMzLFxufTtcblxuZnVuY3Rpb24gemVyb1BhZDIoaW50KSB7XG5cdHJldHVybiAoaW50IDwgMTAgPyAnMCcgOiAnJykgKyBpbnQ7XG59XG5cbmZ1bmN0aW9uIHplcm9QYWQzKGludCkge1xuXHRyZXR1cm4gKGludCA8IDEwID8gJzAwJyA6IGludCA8IDEwMCA/ICcwJyA6ICcnKSArIGludDtcbn1cblxuLypcbmZ1bmN0aW9uIHN1ZmZpeChpbnQpIHtcblx0bGV0IG1vZDEwID0gaW50ICUgMTA7XG5cblx0cmV0dXJuIGludCArIChcblx0XHRtb2QxMCA9PSAxICYmIGludCAhPSAxMSA/IFwic3RcIiA6XG5cdFx0bW9kMTAgPT0gMiAmJiBpbnQgIT0gMTIgPyBcIm5kXCIgOlxuXHRcdG1vZDEwID09IDMgJiYgaW50ICE9IDEzID8gXCJyZFwiIDogXCJ0aFwiXG5cdCk7XG59XG4qL1xuXG5jb25zdCBnZXRGdWxsWWVhciA9ICdnZXRGdWxsWWVhcic7XG5jb25zdCBnZXRNb250aCA9ICdnZXRNb250aCc7XG5jb25zdCBnZXREYXRlID0gJ2dldERhdGUnO1xuY29uc3QgZ2V0RGF5ID0gJ2dldERheSc7XG5jb25zdCBnZXRIb3VycyA9ICdnZXRIb3Vycyc7XG5jb25zdCBnZXRNaW51dGVzID0gJ2dldE1pbnV0ZXMnO1xuY29uc3QgZ2V0U2Vjb25kcyA9ICdnZXRTZWNvbmRzJztcbmNvbnN0IGdldE1pbGxpc2Vjb25kcyA9ICdnZXRNaWxsaXNlY29uZHMnO1xuXG5jb25zdCBzdWJzID0ge1xuXHQvLyAyMDE5XG5cdFlZWVk6XHRkID0+IGRbZ2V0RnVsbFllYXJdKCksXG5cdC8vIDE5XG5cdFlZOlx0XHRkID0+IChkW2dldEZ1bGxZZWFyXSgpKycnKS5zbGljZSgyKSxcblx0Ly8gSnVseVxuXHRNTU1NOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5NTU1NW2RbZ2V0TW9udGhdKCldLFxuXHQvLyBKdWxcblx0TU1NOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5NTU1bZFtnZXRNb250aF0oKV0sXG5cdC8vIDA3XG5cdE1NOlx0XHRkID0+IHplcm9QYWQyKGRbZ2V0TW9udGhdKCkrMSksXG5cdC8vIDdcblx0TTpcdFx0ZCA9PiBkW2dldE1vbnRoXSgpKzEsXG5cdC8vIDA5XG5cdEREOlx0XHRkID0+IHplcm9QYWQyKGRbZ2V0RGF0ZV0oKSksXG5cdC8vIDlcblx0RDpcdFx0ZCA9PiBkW2dldERhdGVdKCksXG5cdC8vIE1vbmRheVxuXHRXV1dXOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5XV1dXW2RbZ2V0RGF5XSgpXSxcblx0Ly8gTW9uXG5cdFdXVzpcdChkLCBuYW1lcykgPT4gbmFtZXMuV1dXW2RbZ2V0RGF5XSgpXSxcblx0Ly8gMDNcblx0SEg6XHRcdGQgPT4gemVyb1BhZDIoZFtnZXRIb3Vyc10oKSksXG5cdC8vIDNcblx0SDpcdFx0ZCA9PiBkW2dldEhvdXJzXSgpLFxuXHQvLyA5ICgxMmhyLCB1bnBhZGRlZClcblx0aDpcdFx0ZCA9PiB7bGV0IGggPSBkW2dldEhvdXJzXSgpOyByZXR1cm4gaCA9PSAwID8gMTIgOiBoID4gMTIgPyBoIC0gMTIgOiBoO30sXG5cdC8vIEFNXG5cdEFBOlx0XHRkID0+IGRbZ2V0SG91cnNdKCkgPj0gMTIgPyAnUE0nIDogJ0FNJyxcblx0Ly8gYW1cblx0YWE6XHRcdGQgPT4gZFtnZXRIb3Vyc10oKSA+PSAxMiA/ICdwbScgOiAnYW0nLFxuXHQvLyBhXG5cdGE6XHRcdGQgPT4gZFtnZXRIb3Vyc10oKSA+PSAxMiA/ICdwJyA6ICdhJyxcblx0Ly8gMDlcblx0bW06XHRcdGQgPT4gemVyb1BhZDIoZFtnZXRNaW51dGVzXSgpKSxcblx0Ly8gOVxuXHRtOlx0XHRkID0+IGRbZ2V0TWludXRlc10oKSxcblx0Ly8gMDlcblx0c3M6XHRcdGQgPT4gemVyb1BhZDIoZFtnZXRTZWNvbmRzXSgpKSxcblx0Ly8gOVxuXHRzOlx0XHRkID0+IGRbZ2V0U2Vjb25kc10oKSxcblx0Ly8gMzc0XG5cdGZmZjpcdGQgPT4gemVyb1BhZDMoZFtnZXRNaWxsaXNlY29uZHNdKCkpLFxufTtcblxuZnVuY3Rpb24gZm10RGF0ZSh0cGwsIG5hbWVzKSB7XG5cdG5hbWVzID0gbmFtZXMgfHwgZW5nTmFtZXM7XG5cdGxldCBwYXJ0cyA9IFtdO1xuXG5cdGxldCBSID0gL1xceyhbYS16XSspXFx9fFtee10rL2dpLCBtO1xuXG5cdHdoaWxlIChtID0gUi5leGVjKHRwbCkpXG5cdFx0cGFydHMucHVzaChtWzBdWzBdID09ICd7JyA/IHN1YnNbbVsxXV0gOiBtWzBdKTtcblxuXHRyZXR1cm4gZCA9PiB7XG5cdFx0bGV0IG91dCA9ICcnO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKylcblx0XHRcdG91dCArPSB0eXBlb2YgcGFydHNbaV0gPT0gXCJzdHJpbmdcIiA/IHBhcnRzW2ldIDogcGFydHNbaV0oZCwgbmFtZXMpO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxufVxuXG5jb25zdCBsb2NhbFR6ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTUxNDE3NjIvaG93LXRvLWluaXRpYWxpemUtYS1qYXZhc2NyaXB0LWRhdGUtdG8tYS1wYXJ0aWN1bGFyLXRpbWUtem9uZS81MzY1MjEzMSM1MzY1MjEzMVxuZnVuY3Rpb24gdHpEYXRlKGRhdGUsIHR6KSB7XG5cdGxldCBkYXRlMjtcblxuXHQvLyBwZXJmIG9wdGltaXphdGlvblxuXHRpZiAodHogPT0gJ0V0Yy9VVEMnKVxuXHRcdGRhdGUyID0gbmV3IERhdGUoK2RhdGUgKyBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2ZTQpO1xuXHRlbHNlIGlmICh0eiA9PSBsb2NhbFR6KVxuXHRcdGRhdGUyID0gZGF0ZTtcblx0ZWxzZSB7XG5cdFx0ZGF0ZTIgPSBuZXcgRGF0ZShkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHt0aW1lWm9uZTogdHp9KSk7XG5cdFx0ZGF0ZTIuc2V0TWlsbGlzZWNvbmRzKGRhdGVbZ2V0TWlsbGlzZWNvbmRzXSgpKTtcblx0fVxuXG5cdHJldHVybiBkYXRlMjtcbn1cblxuLy9leHBvcnQgY29uc3Qgc2VyaWVzID0gW107XG5cbi8vIGRlZmF1bHQgZm9ybWF0dGVyczpcblxuY29uc3QgaW5jck11bHRzID0gWzEsMiw1XTtcblxuY29uc3QgZGVjSW5jcnMgPSBnZW5JbmNycygtMTYsIDAsIGluY3JNdWx0cyk7XG5cbmNvbnN0IGludEluY3JzID0gZ2VuSW5jcnMoMCwgMTYsIGluY3JNdWx0cyk7XG5cbmNvbnN0IG51bUluY3JzID0gZGVjSW5jcnMuY29uY2F0KGludEluY3JzKTtcblxubGV0IHMgPSAxLFxuXHRtID0gNjAsXG5cdGggPSBtICogbSxcblx0ZCA9IGggKiAyNCxcblx0bW8gPSBkICogMzAsXG5cdHkgPSBkICogMzY1O1xuXG4vLyBzdGFydGluZyBiZWxvdyAxZS0zIGlzIGEgaGFjayB0byBhbGxvdyB0aGUgaW5jciBmaW5kZXIgdG8gY2hvb3NlICYgYmFpbCBvdXQgYXQgaW5jciA8IDFtc1xuY29uc3QgdGltZUluY3JzID0gIFs1ZS00XS5jb25jYXQoZ2VuSW5jcnMoLTMsIDAsIGluY3JNdWx0cyksIFtcblx0Ly8gbWludXRlIGRpdmlzb3JzICgjIG9mIHNlY3MpXG5cdDEsXG5cdDUsXG5cdDEwLFxuXHQxNSxcblx0MzAsXG5cdC8vIGhvdXIgZGl2aXNvcnMgKCMgb2YgbWlucylcblx0bSxcblx0bSAqIDUsXG5cdG0gKiAxMCxcblx0bSAqIDE1LFxuXHRtICogMzAsXG5cdC8vIGRheSBkaXZpc29ycyAoIyBvZiBocnMpXG5cdGgsXG5cdGggKiAyLFxuXHRoICogMyxcblx0aCAqIDQsXG5cdGggKiA2LFxuXHRoICogOCxcblx0aCAqIDEyLFxuXHQvLyBtb250aCBkaXZpc29ycyBUT0RPOiBuZWVkIG1vcmU/XG5cdGQsXG5cdGQgKiAyLFxuXHRkICogMyxcblx0ZCAqIDQsXG5cdGQgKiA1LFxuXHRkICogNixcblx0ZCAqIDcsXG5cdGQgKiA4LFxuXHRkICogOSxcblx0ZCAqIDEwLFxuXHRkICogMTUsXG5cdC8vIHllYXIgZGl2aXNvcnMgKCMgbW9udGhzLCBhcHByb3gpXG5cdG1vLFxuXHRtbyAqIDIsXG5cdG1vICogMyxcblx0bW8gKiA0LFxuXHRtbyAqIDYsXG5cdC8vIGNlbnR1cnkgZGl2aXNvcnNcblx0eSxcblx0eSAqIDIsXG5cdHkgKiA1LFxuXHR5ICogMTAsXG5cdHkgKiAyNSxcblx0eSAqIDUwLFxuXHR5ICogMTAwLFxuXSk7XG5cbmZ1bmN0aW9uIHRpbWVBeGlzU3RhbXBzKHN0YW1wQ2ZnLCBmbXREYXRlKSB7XG5cdHJldHVybiBzdGFtcENmZy5tYXAocyA9PiBbXG5cdFx0c1swXSxcblx0XHRmbXREYXRlKHNbMV0pLFxuXHRcdHNbMl0sXG5cdFx0Zm10RGF0ZShzWzRdID8gc1sxXSArIHNbM10gOiBzWzNdKSxcblx0XSk7XG59XG5cbmNvbnN0IHl5eXkgPSBcIntZWVlZfVwiO1xuY29uc3QgTkx5eXl5ID0gXCJcXG5cIiArIHl5eXk7XG5jb25zdCBtZCA9IFwie019L3tEfVwiO1xuY29uc3QgTkxtZCA9IFwiXFxuXCIgKyBtZDtcblxuY29uc3QgYWEgPSBcInthYX1cIjtcbmNvbnN0IGhtbSA9IFwie2h9OnttbX1cIjtcbmNvbnN0IGhtbWFhID0gaG1tICsgYWE7XG5jb25zdCBzcyA9IFwiOntzc31cIjtcblxuLy8gWzBdOiBtaW5pbXVtIG51bSBzZWNzIGluIHRoZSB0aWNrIGluY3Jcbi8vIFsxXTogbm9ybWFsIHRpY2sgZm9ybWF0XG4vLyBbMl06IHdoZW4gYSBkaWZmZXJpbmcgPHg+IGlzIGVuY291bnRlcmVkIC0gMTogc2VjLCAyOiBtaW4sIDM6IGhvdXIsIDQ6IGRheSwgNTogd2VlaywgNjogbW9udGgsIDc6IHllYXJcbi8vIFszXTogdXNlIGEgbG9uZ2VyIG1vcmUgY29udGV4dHVhbCBmb3JtYXRcbi8vIFs0XTogbW9kZXM6IDA6IHJlcGxhY2UgWzFdIC0+IFszXSwgMTogY29uY2F0IFsxXSArIFszXVxuY29uc3QgX3RpbWVBeGlzU3RhbXBzID0gW1xuXHRbeSwgICAgICAgIHl5eXksICAgICAgICAgICAgNywgICBcIlwiLCAgICAgICAgICAgICAgICAgICAgMV0sXG5cdFtkICogMjgsICAgXCJ7TU1NfVwiLCAgICAgICAgIDcsICAgTkx5eXl5LCAgICAgICAgICAgICAgICAxXSxcblx0W2QsICAgICAgICBtZCwgICAgICAgICAgICAgIDcsICAgTkx5eXl5LCAgICAgICAgICAgICAgICAxXSxcblx0W2gsICAgICAgICBcIntofVwiICsgYWEsICAgICAgNCwgICBOTG1kLCAgICAgICAgICAgICAgICAgIDFdLFxuXHRbbSwgICAgICAgIGhtbWFhLCAgICAgICAgICAgNCwgICBOTG1kLCAgICAgICAgICAgICAgICAgIDFdLFxuXHRbcywgICAgICAgIHNzLCAgICAgICAgICAgICAgMiwgICBOTG1kICArIFwiIFwiICsgaG1tYWEsICAgMV0sXG5cdFsxZS0zLCAgICAgc3MgKyBcIi57ZmZmfVwiLCAgIDIsICAgTkxtZCAgKyBcIiBcIiArIGhtbWFhLCAgIDFdLFxuXTtcblxuLy8gVE9ETzogd2lsbCBuZWVkIHRvIGFjY2VwdCBzcGFjZXNbXSBhbmQgcHVsbCBpbmNyIGludG8gdGhlIGxvb3Agd2hlbiBncmlkIHdpbGwgYmUgbm9uLXVuaWZvcm0sIGVnIGZvciBsb2cgc2NhbGVzLlxuLy8gY3VycmVudGx5IHdlIGlnbm9yZSB0aGlzIGZvciBtb250aHMgc2luY2UgdGhleSdyZSAqbmVhcmx5KiB1bmlmb3JtIGFuZCB0aGUgYWRkZWQgY29tcGxleGl0eSBpcyBub3Qgd29ydGggaXRcbmZ1bmN0aW9uIHRpbWVBeGlzVmFscyh0ekRhdGUsIHN0YW1wcykge1xuXHRyZXR1cm4gKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSA9PiB7XG5cdFx0bGV0IHMgPSBzdGFtcHMuZmluZChlID0+IGZvdW5kSW5jciA+PSBlWzBdKSB8fCBzdGFtcHNbc3RhbXBzLmxlbmd0aCAtIDFdO1xuXG5cdFx0Ly8gdGhlc2UgdHJhY2sgYm91bmRhcmllcyB3aGVuIGEgZnVsbCBsYWJlbCBpcyBuZWVkZWQgYWdhaW5cblx0XHRsZXQgcHJldlllYXIgPSBudWxsO1xuXHRcdGxldCBwcmV2RGF0ZSA9IG51bGw7XG5cdFx0bGV0IHByZXZNaW51ID0gbnVsbDtcblxuXHRcdHJldHVybiBzcGxpdHMubWFwKChzcGxpdCwgaSkgPT4ge1xuXHRcdFx0bGV0IGRhdGUgPSB0ekRhdGUoc3BsaXQpO1xuXG5cdFx0XHRsZXQgbmV3WWVhciA9IGRhdGVbZ2V0RnVsbFllYXJdKCk7XG5cdFx0XHRsZXQgbmV3RGF0ZSA9IGRhdGVbZ2V0RGF0ZV0oKTtcblx0XHRcdGxldCBuZXdNaW51ID0gZGF0ZVtnZXRNaW51dGVzXSgpO1xuXG5cdFx0XHRsZXQgZGlmZlllYXIgPSBuZXdZZWFyICE9IHByZXZZZWFyO1xuXHRcdFx0bGV0IGRpZmZEYXRlID0gbmV3RGF0ZSAhPSBwcmV2RGF0ZTtcblx0XHRcdGxldCBkaWZmTWludSA9IG5ld01pbnUgIT0gcHJldk1pbnU7XG5cblx0XHRcdGxldCBzdGFtcCA9IHNbMl0gPT0gNyAmJiBkaWZmWWVhciB8fCBzWzJdID09IDQgJiYgZGlmZkRhdGUgfHwgc1syXSA9PSAyICYmIGRpZmZNaW51ID8gc1szXSA6IHNbMV07XG5cblx0XHRcdHByZXZZZWFyID0gbmV3WWVhcjtcblx0XHRcdHByZXZEYXRlID0gbmV3RGF0ZTtcblx0XHRcdHByZXZNaW51ID0gbmV3TWludTtcblxuXHRcdFx0cmV0dXJuIHN0YW1wKGRhdGUpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG1rRGF0ZSh5LCBtLCBkKSB7XG5cdHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKTtcbn1cblxuLy8gdGhlIGVuc3VyZXMgdGhhdCBheGlzIHRpY2tzLCB2YWx1ZXMgJiBncmlkIGFyZSBhbGlnbmVkIHRvIGxvZ2ljYWwgdGVtcG9yYWwgYnJlYWtwb2ludHMgYW5kIG5vdCBhbiBhcmJpdHJhcnkgdGltZXN0YW1wXG4vLyBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS9kc3QvXG4vLyBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS9kc3QvMjAxOS5odG1sXG4vLyBodHRwczovL3d3dy5lcG9jaGNvbnZlcnRlci5jb20vdGltZXpvbmVzXG5mdW5jdGlvbiB0aW1lQXhpc1NwbGl0cyh0ekRhdGUpIHtcblx0cmV0dXJuIChzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSkgPT4ge1xuXHRcdGxldCBzcGxpdHMgPSBbXTtcblx0XHRsZXQgaXNNbyA9IGZvdW5kSW5jciA+PSBtbyAmJiBmb3VuZEluY3IgPCB5O1xuXG5cdFx0Ly8gZ2V0IHRoZSB0aW1lem9uZS1hZGp1c3RlZCBkYXRlXG5cdFx0bGV0IG1pbkRhdGUgPSB0ekRhdGUoc2NhbGVNaW4pO1xuXHRcdGxldCBtaW5EYXRlVHMgPSBtaW5EYXRlIC8gMWUzO1xuXG5cdFx0Ly8gZ2V0IHRzIG9mIDEyYW0gKHRoaXMgbGFuZHMgdXMgYXQgb3IgYmVmb3JlIHRoZSBvcmlnaW5hbCBzY2FsZU1pbilcblx0XHRsZXQgbWluTWluID0gbWtEYXRlKG1pbkRhdGVbZ2V0RnVsbFllYXJdKCksIG1pbkRhdGVbZ2V0TW9udGhdKCksIGlzTW8gPyAxIDogbWluRGF0ZVtnZXREYXRlXSgpKTtcblx0XHRsZXQgbWluTWluVHMgPSBtaW5NaW4gLyAxZTM7XG5cblx0XHRpZiAoaXNNbykge1xuXHRcdFx0bGV0IG1vSW5jciA9IGZvdW5kSW5jciAvIG1vO1xuXHRcdC8vXHRsZXQgdHpPZmZzZXQgPSBzY2FsZU1pbiAtIG1pbkRhdGVUcztcdFx0Ly8gbmVlZGVkP1xuXHRcdFx0bGV0IHNwbGl0ID0gbWluRGF0ZVRzID09IG1pbk1pblRzID8gbWluRGF0ZVRzIDogbWtEYXRlKG1pbk1pbltnZXRGdWxsWWVhcl0oKSwgbWluTWluW2dldE1vbnRoXSgpICsgbW9JbmNyLCAxKSAvIDFlMztcblx0XHRcdGxldCBzcGxpdERhdGUgPSBuZXcgRGF0ZShzcGxpdCAqIDFlMyk7XG5cdFx0XHRsZXQgYmFzZVllYXIgPSBzcGxpdERhdGVbZ2V0RnVsbFllYXJdKCk7XG5cdFx0XHRsZXQgYmFzZU1vbnRoID0gc3BsaXREYXRlW2dldE1vbnRoXSgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgc3BsaXQgPD0gc2NhbGVNYXg7IGkrKykge1xuXHRcdFx0XHRsZXQgbmV4dCA9IG1rRGF0ZShiYXNlWWVhciwgYmFzZU1vbnRoICsgbW9JbmNyICogaSwgMSk7XG5cdFx0XHRcdGxldCBvZmZzID0gbmV4dCAtIHR6RGF0ZShuZXh0IC8gMWUzKTtcblxuXHRcdFx0XHRzcGxpdCA9ICgrbmV4dCArIG9mZnMpIC8gMWUzO1xuXG5cdFx0XHRcdGlmIChzcGxpdCA8PSBzY2FsZU1heClcblx0XHRcdFx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IGluY3IwID0gZm91bmRJbmNyID49IGQgPyBkIDogZm91bmRJbmNyO1xuXHRcdFx0bGV0IHR6T2Zmc2V0ID0gZmxvb3Ioc2NhbGVNaW4pIC0gZmxvb3IobWluRGF0ZVRzKTtcblx0XHRcdGxldCBzcGxpdCA9IG1pbk1pblRzICsgdHpPZmZzZXQgKyBpbmNyUm91bmRVcChtaW5EYXRlVHMgLSBtaW5NaW5UcywgaW5jcjApO1xuXHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXG5cdFx0XHRsZXQgZGF0ZTAgPSB0ekRhdGUoc3BsaXQpO1xuXG5cdFx0XHRsZXQgcHJldkhvdXIgPSBkYXRlMFtnZXRIb3Vyc10oKSArIChkYXRlMFtnZXRNaW51dGVzXSgpIC8gbSkgKyAoZGF0ZTBbZ2V0U2Vjb25kc10oKSAvIGgpO1xuXHRcdFx0bGV0IGluY3JIb3VycyA9IGZvdW5kSW5jciAvIGg7XG5cblx0XHRcdGxldCBtaW5TcGFjZSA9IHNlbGYuYXhlc1theGlzSWR4XS5zcGFjZSgpO1x0XHQvLyBUT0ZJWDogb25seSB3b3JrcyBmb3Igc3RhdGljIHNwYWNlOlxuXHRcdFx0bGV0IHBjdFNwYWNlID0gZm91bmRTcGFjZSAvIG1pblNwYWNlO1xuXG5cdFx0XHR3aGlsZSAoMSkge1xuXHRcdFx0XHRzcGxpdCA9IHJvdW5kMyhzcGxpdCArIGZvdW5kSW5jcik7XG5cblx0XHRcdFx0aWYgKHNwbGl0ID4gc2NhbGVNYXgpXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0aWYgKGluY3JIb3VycyA+IDEpIHtcblx0XHRcdFx0XHRsZXQgZXhwZWN0ZWRIb3VyID0gZmxvb3Iocm91bmQ2KHByZXZIb3VyICsgaW5jckhvdXJzKSkgJSAyNDtcblx0XHRcdFx0XHRsZXQgc3BsaXREYXRlID0gdHpEYXRlKHNwbGl0KTtcblx0XHRcdFx0XHRsZXQgYWN0dWFsSG91ciA9IHNwbGl0RGF0ZS5nZXRIb3VycygpO1xuXG5cdFx0XHRcdFx0bGV0IGRzdFNoaWZ0ID0gYWN0dWFsSG91ciAtIGV4cGVjdGVkSG91cjtcblxuXHRcdFx0XHRcdGlmIChkc3RTaGlmdCA+IDEpXG5cdFx0XHRcdFx0XHRkc3RTaGlmdCA9IC0xO1xuXG5cdFx0XHRcdFx0c3BsaXQgLT0gZHN0U2hpZnQgKiBoO1xuXG5cdFx0XHRcdFx0cHJldkhvdXIgPSAocHJldkhvdXIgKyBpbmNySG91cnMpICUgMjQ7XG5cblx0XHRcdFx0XHQvLyBhZGQgYSB0aWNrIG9ubHkgaWYgaXQncyBmdXJ0aGVyIHRoYW4gNzAlIG9mIHRoZSBtaW4gYWxsb3dlZCBsYWJlbCBzcGFjaW5nXG5cdFx0XHRcdFx0bGV0IHByZXZTcGxpdCA9IHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0bGV0IHBjdEluY3IgPSByb3VuZDMoKHNwbGl0IC0gcHJldlNwbGl0KSAvIGZvdW5kSW5jcik7XG5cblx0XHRcdFx0XHRpZiAocGN0SW5jciAqIHBjdFNwYWNlID49IC43KVxuXHRcdFx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwbGl0cztcblx0fVxufVxuXG5mdW5jdGlvbiB0aW1lU2VyaWVzU3RhbXAoc3RhbXBDZmcsIGZtdERhdGUpIHtcblx0cmV0dXJuIGZtdERhdGUoc3RhbXBDZmcpO1xufVxuY29uc3QgX3RpbWVTZXJpZXNTdGFtcCA9ICd7WVlZWX0te01NfS17RER9IHtofTp7bW19e2FhfSc7XG5cbmZ1bmN0aW9uIHRpbWVTZXJpZXNWYWwodHpEYXRlLCBzdGFtcCkge1xuXHRyZXR1cm4gKHNlbGYsIHZhbCkgPT4gc3RhbXAodHpEYXRlKHZhbCkpO1xufVxuXG5mdW5jdGlvbiBjdXJzb3JQb2ludChzZWxmLCBzaSkge1xuXHRsZXQgcyA9IHNlbGYuc2VyaWVzW3NpXTtcblxuXHRsZXQgcHQgPSBwbGFjZURpdigpO1xuXG5cdHB0LnN0eWxlLmJhY2tncm91bmQgPSBzLnN0cm9rZSB8fCBoZXhCbGFjaztcblxuXHRsZXQgZGlhID0gcHREaWEocy53aWR0aCwgMSk7XG5cdGxldCBtYXIgPSAoZGlhIC0gMSkgLyAtMjtcblxuXHRzZXRTdHlsZVB4KHB0LCBXSURUSCwgZGlhKTtcblx0c2V0U3R5bGVQeChwdCwgSEVJR0hULCBkaWEpO1xuXHRzZXRTdHlsZVB4KHB0LCBcIm1hcmdpbkxlZnRcIiwgbWFyKTtcblx0c2V0U3R5bGVQeChwdCwgXCJtYXJnaW5Ub3BcIiwgbWFyKTtcblxuXHRyZXR1cm4gcHQ7XG59XG5cbmZ1bmN0aW9uIGRhdGFJZHgoc2VsZiwgc2VyaWVzSWR4LCBjdXJzb3JJZHgpIHtcblx0cmV0dXJuIGN1cnNvcklkeDtcbn1cblxuY29uc3QgbW92ZVR1cGxlID0gWzAsMF07XG5cbmZ1bmN0aW9uIGN1cnNvck1vdmUoc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxKSB7XG5cdG1vdmVUdXBsZVswXSA9IG1vdXNlTGVmdDE7XG5cdG1vdmVUdXBsZVsxXSA9IG1vdXNlVG9wMTtcblx0cmV0dXJuIG1vdmVUdXBsZTtcbn1cblxuY29uc3QgY3Vyc29yT3B0cyA9IHtcblx0c2hvdzogdHJ1ZSxcblx0eDogdHJ1ZSxcblx0eTogdHJ1ZSxcblx0bG9jazogZmFsc2UsXG5cdG1vdmU6IGN1cnNvck1vdmUsXG5cdHBvaW50czoge1xuXHRcdHNob3c6IGN1cnNvclBvaW50LFxuXHR9LFxuXG5cdGRyYWc6IHtcblx0XHRzZXRTY2FsZTogdHJ1ZSxcblx0XHR4OiB0cnVlLFxuXHRcdHk6IGZhbHNlLFxuXHRcdGRpc3Q6IDAsXG5cdFx0dW5pOiBudWxsLFxuXHRcdF94OiBmYWxzZSxcblx0XHRfeTogZmFsc2UsXG5cdH0sXG5cblx0Zm9jdXM6IHtcblx0XHRwcm94OiAtMSxcblx0fSxcblxuXHRsb2NrZWQ6IGZhbHNlLFxuXHRsZWZ0OiAtMTAsXG5cdHRvcDogLTEwLFxuXHRpZHg6IG51bGwsXG5cdGRhdGFJZHgsXG59O1xuXG5jb25zdCBncmlkID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzdHJva2U6IFwicmdiYSgwLDAsMCwwLjA3KVwiLFxuXHR3aWR0aDogMixcbi8vXHRkYXNoOiBbXSxcbn07XG5cbmNvbnN0IHRpY2tzID0gYXNzaWduKHt9LCBncmlkLCB7c2l6ZTogMTB9KTtcblxuY29uc3QgZm9udCAgICAgID0gJzEycHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBcIlNlZ29lIFVJXCIsIFJvYm90bywgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBBcmlhbCwgXCJOb3RvIFNhbnNcIiwgc2Fucy1zZXJpZiwgXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiJztcbmNvbnN0IGxhYmVsRm9udCA9IFwiYm9sZCBcIiArIGZvbnQ7XG5jb25zdCBsaW5lTXVsdCA9IDEuNTtcdFx0Ly8gZm9udC1zaXplIG11bHRpcGxpZXJcblxuY29uc3QgeEF4aXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ4XCIsXG5cdHNwYWNlOiA1MCxcblx0Z2FwOiA1LFxuXHRzaXplOiA1MCxcblx0bGFiZWxTaXplOiAzMCxcblx0bGFiZWxGb250LFxuXHRzaWRlOiAyLFxuLy9cdGNsYXNzOiBcIngtdmFsc1wiLFxuLy9cdGluY3JzOiB0aW1lSW5jcnMsXG4vL1x0dmFsdWVzOiB0aW1lVmFscyxcblx0Z3JpZCxcblx0dGlja3MsXG5cdGZvbnQsXG5cdHJvdGF0ZTogMCxcbn07XG5cbmNvbnN0IG51bVNlcmllc0xhYmVsID0gXCJWYWx1ZVwiO1xuY29uc3QgdGltZVNlcmllc0xhYmVsID0gXCJUaW1lXCI7XG5cbmNvbnN0IHhTZXJpZXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ4XCIsXG5cdHNvcnRlZDogMSxcbi8vXHRsYWJlbDogXCJUaW1lXCIsXG4vL1x0dmFsdWU6IHYgPT4gc3RhbXAobmV3IERhdGUodiAqIDFlMykpLFxuXG5cdC8vIGludGVybmFsIGNhY2hlc1xuXHRtaW46IGluZixcblx0bWF4OiAtaW5mLFxuXHRpZHhzOiBbXSxcbn07XG5cbmZ1bmN0aW9uIG51bUF4aXNWYWxzKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSB7XG5cdHJldHVybiBzcGxpdHMubWFwKGZtdE51bSk7XG59XG5cbmZ1bmN0aW9uIG51bUF4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UsIGZvcmNlTWluKSB7XG5cdGxldCBzcGxpdHMgPSBbXTtcblxuXHRsZXQgbnVtRGVjID0gZml4ZWREZWMuZ2V0KGZvdW5kSW5jcik7XG5cblx0c2NhbGVNaW4gPSBmb3JjZU1pbiA/IHNjYWxlTWluIDogK2luY3JSb3VuZFVwKHNjYWxlTWluLCBmb3VuZEluY3IpLnRvRml4ZWQobnVtRGVjKTtcblxuXHRmb3IgKGxldCB2YWwgPSBzY2FsZU1pbjsgdmFsIDw9IHNjYWxlTWF4OyB2YWwgPSArKHZhbCArIGZvdW5kSW5jcikudG9GaXhlZChudW1EZWMpKVxuXHRcdHNwbGl0cy5wdXNoKHZhbCk7XG5cblx0cmV0dXJuIHNwbGl0cztcbn1cblxuZnVuY3Rpb24gbG9nQXhpc1NwbGl0cyhzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSwgZm9yY2VNaW4pIHtcblx0Y29uc3Qgc3BsaXRzID0gW107XG5cblx0Zm91bmRJbmNyID0gcG93KDEwLCBmbG9vcihsb2cxMChzY2FsZU1pbikpKTtcblxuXHRsZXQgc3BsaXQgPSBzY2FsZU1pbjtcblxuXHRkbyB7XG5cdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXHRcdHNwbGl0ID0gKyhzcGxpdCArIGZvdW5kSW5jcikudG9GaXhlZChmaXhlZERlYy5nZXQoZm91bmRJbmNyKSk7XG5cdFx0aWYgKHNwbGl0ID49IGZvdW5kSW5jciAqIDEwKVxuXHRcdFx0Zm91bmRJbmNyID0gc3BsaXQ7XG5cdH0gd2hpbGUgKHNwbGl0IDw9IHNjYWxlTWF4KTtcblxuXHRyZXR1cm4gc3BsaXRzO1xufVxuXG5jb25zdCBSRV9BTEwgICA9IC8uLztcbmNvbnN0IFJFXzEyMzU3ID0gL1sxMjM1N10vO1xuY29uc3QgUkVfMTI1ICAgPSAvWzEyNV0vO1xuY29uc3QgUkVfMSAgICAgPSAvMS87XG5cbmZ1bmN0aW9uIGxvZ0F4aXNWYWxzKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSB7XG5cdGxldCBheGlzID0gc2VsZi5heGVzW2F4aXNJZHhdO1xuXHRsZXQgc2NhbGVLZXkgPSBheGlzLnNjYWxlO1xuXHRsZXQgdmFsVG9Qb3MgPSBzZWxmLnZhbFRvUG9zO1xuXG5cdGxldCBtaW5TcGFjZSA9IGF4aXMuc3BhY2UoKTtcdFx0XHQvLyBUT0ZJWDogb25seSB3b3JrcyBmb3Igc3RhdGljIHNwYWNlOlxuXG5cdGxldCBfMTAgPSB2YWxUb1BvcygxMCwgc2NhbGVLZXkpO1xuXG5cdGxldCByZSA9IChcblx0XHR2YWxUb1Bvcyg5LCAgc2NhbGVLZXkpIC0gXzEwID49IG1pblNwYWNlID8gUkVfQUxMIDpcblx0XHR2YWxUb1Bvcyg3LCAgc2NhbGVLZXkpIC0gXzEwID49IG1pblNwYWNlID8gUkVfMTIzNTcgOlxuXHRcdHZhbFRvUG9zKDUsICBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV8xMjUgOlxuXHRcdFJFXzFcblx0KTtcblxuXHRyZXR1cm4gc3BsaXRzLm1hcCh2ID0+IHJlLnRlc3QodikgPyBmbXROdW0odikgOiBcIlwiKTtcbn1cblxuZnVuY3Rpb24gbnVtU2VyaWVzVmFsKHNlbGYsIHZhbCkge1xuXHRyZXR1cm4gZm10TnVtKHZhbCk7XG59XG5cbmNvbnN0IHlBeGlzT3B0cyA9IHtcblx0c2hvdzogdHJ1ZSxcblx0c2NhbGU6IFwieVwiLFxuXHRzcGFjZTogNDAsXG5cdGdhcDogNSxcblx0c2l6ZTogNTAsXG5cdGxhYmVsU2l6ZTogMzAsXG5cdGxhYmVsRm9udCxcblx0c2lkZTogMyxcbi8vXHRjbGFzczogXCJ5LXZhbHNcIixcbi8vXHRpbmNyczogbnVtSW5jcnMsXG4vL1x0dmFsdWVzOiAodmFscywgc3BhY2UpID0+IHZhbHMsXG5cdGdyaWQsXG5cdHRpY2tzLFxuXHRmb250LFxuXHRyb3RhdGU6IDAsXG59O1xuXG4vLyB0YWtlcyBzdHJva2Ugd2lkdGhcbmZ1bmN0aW9uIHB0RGlhKHdpZHRoLCBtdWx0KSB7XG5cdGxldCBkaWEgPSAzICsgKHdpZHRoIHx8IDEpICogMjtcblx0cmV0dXJuIHJvdW5kMyhkaWEgKiBtdWx0KTtcbn1cblxuZnVuY3Rpb24gc2VyaWVzUG9pbnRzKHNlbGYsIHNpKSB7XG5cdGNvbnN0IGRpYSA9IHB0RGlhKHNlbGYuc2VyaWVzW3NpXS53aWR0aCwgcHhSYXRpbyk7XG5cdGxldCBtYXhQdHMgPSBzZWxmLmJib3gud2lkdGggLyBkaWEgLyAyO1xuXHRsZXQgaWR4cyA9IHNlbGYuc2VyaWVzWzBdLmlkeHM7XG5cdHJldHVybiBpZHhzWzFdIC0gaWR4c1swXSA8PSBtYXhQdHM7XG59XG5cbmNvbnN0IHlTZXJpZXNPcHRzID0ge1xuXHRzY2FsZTogXCJ5XCIsXG5cdHNvcnRlZDogMCxcblx0c2hvdzogdHJ1ZSxcblx0YmFuZDogZmFsc2UsXG5cdHNwYW5HYXBzOiBmYWxzZSxcblx0YWxwaGE6IDEsXG5cdHBvaW50czoge1xuXHRcdHNob3c6IHNlcmllc1BvaW50cyxcblx0Ly9cdHN0cm9rZTogXCIjMDAwXCIsXG5cdC8vXHRmaWxsOiBcIiNmZmZcIixcblx0Ly9cdHdpZHRoOiAxLFxuXHQvL1x0c2l6ZTogMTAsXG5cdH0sXG4vL1x0bGFiZWw6IFwiVmFsdWVcIixcbi8vXHR2YWx1ZTogdiA9PiB2LFxuXHR2YWx1ZXM6IG51bGwsXG5cblx0Ly8gaW50ZXJuYWwgY2FjaGVzXG5cdG1pbjogaW5mLFxuXHRtYXg6IC1pbmYsXG5cdGlkeHM6IFtdLFxuXG5cdHBhdGg6IG51bGwsXG5cdGNsaXA6IG51bGwsXG59O1xuXG5jb25zdCB4U2NhbGVPcHRzID0ge1xuXHR0aW1lOiB0cnVlLFxuXHRhdXRvOiB0cnVlLFxuXHRkaXN0cjogMSxcblx0bWluOiBudWxsLFxuXHRtYXg6IG51bGwsXG59O1xuXG5jb25zdCB5U2NhbGVPcHRzID0gYXNzaWduKHt9LCB4U2NhbGVPcHRzLCB7XG5cdHRpbWU6IGZhbHNlLFxufSk7XG5cbmNvbnN0IHN5bmNzID0ge307XG5cbmZ1bmN0aW9uIF9zeW5jKG9wdHMpIHtcblx0bGV0IGNsaWVudHMgPSBbXTtcblxuXHRyZXR1cm4ge1xuXHRcdHN1YihjbGllbnQpIHtcblx0XHRcdGNsaWVudHMucHVzaChjbGllbnQpO1xuXHRcdH0sXG5cdFx0dW5zdWIoY2xpZW50KSB7XG5cdFx0XHRjbGllbnRzID0gY2xpZW50cy5maWx0ZXIoYyA9PiBjICE9IGNsaWVudCk7XG5cdFx0fSxcblx0XHRwdWIodHlwZSwgc2VsZiwgeCwgeSwgdywgaCwgaSkge1xuXHRcdFx0aWYgKGNsaWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRjbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHtcblx0XHRcdFx0XHRjbGllbnQgIT0gc2VsZiAmJiBjbGllbnQucHViKHR5cGUsIHNlbGYsIHgsIHksIHcsIGgsIGkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKGQsIHhvLCB5bywgaW5pdFkpIHtcblx0bGV0IGQyID0gaW5pdFkgPyBbZFswXSwgZFsxXV0uY29uY2F0KGQuc2xpY2UoMikpIDogW2RbMF1dLmNvbmNhdChkLnNsaWNlKDEpKTtcblx0cmV0dXJuIGQyLm1hcCgobywgaSkgPT4gc2V0RGVmYXVsdChvLCBpLCB4bywgeW8pKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdChvLCBpLCB4bywgeW8pIHtcblx0cmV0dXJuIGFzc2lnbih7fSwgKGkgPT0gMCB8fCBvICYmIG8uc2lkZSAlIDIgPT0gMCA/IHhvIDogeW8pLCBvKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpIHtcblx0cmV0dXJuIChcblx0XHRzY2FsZS5kaXN0ciA9PSAzXG5cdFx0PyBsb2cxMCh2YWwgLyBzY2FsZS5taW4pIC8gbG9nMTAoc2NhbGUubWF4IC8gc2NhbGUubWluKVxuXHRcdDogKHZhbCAtIHNjYWxlLm1pbikgLyAoc2NhbGUubWF4IC0gc2NhbGUubWluKVxuXHQpO1xufVxuXG5mdW5jdGlvbiBnZXRZUG9zKHZhbCwgc2NhbGUsIGhndCwgdG9wKSB7XG5cdGxldCBwY3RZID0gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpO1xuXHRyZXR1cm4gdG9wICsgKDEgLSBwY3RZKSAqIGhndDtcbn1cblxuZnVuY3Rpb24gZ2V0WFBvcyh2YWwsIHNjYWxlLCB3aWQsIGxmdCkge1xuXHRsZXQgcGN0WCA9IGdldFZhbFBjdCh2YWwsIHNjYWxlKTtcblx0cmV0dXJuIGxmdCArIHBjdFggKiB3aWQ7XG59XG5cbmZ1bmN0aW9uIHNuYXBUaW1lWChzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSB7XG5cdHJldHVybiBbZGF0YU1pbiwgZGF0YU1heCA+IGRhdGFNaW4gPyBkYXRhTWF4IDogZGF0YU1heCArIDg2NDAwXTtcbn1cblxuZnVuY3Rpb24gc25hcE51bVgoc2VsZiwgZGF0YU1pbiwgZGF0YU1heCkge1xuXHRjb25zdCBkZWx0YSA9IGRhdGFNYXggLSBkYXRhTWluO1xuXG5cdGlmIChkZWx0YSA9PSAwKSB7XG5cdFx0Y29uc3QgbWFnID0gbG9nMTAoZGVsdGEgfHwgYWJzKGRhdGFNYXgpIHx8IDEpO1xuXHRcdGNvbnN0IGV4cCA9IGZsb29yKG1hZykgKyAxO1xuXHRcdHJldHVybiBbZGF0YU1pbiwgaW5jclJvdW5kVXAoZGF0YU1heCwgcG93KDEwLCBleHApKV07XG5cdH1cblx0ZWxzZVxuXHRcdHJldHVybiBbZGF0YU1pbiwgZGF0YU1heF07XG59XG5cbi8vIHRoaXMgZW5zdXJlcyB0aGF0IG5vbi10ZW1wb3JhbC9udW1lcmljIHktYXhlcyBnZXQgbXVsdGlwbGUtc25hcHBlZCBwYWRkaW5nIGFkZGVkIGFib3ZlL2JlbG93XG4vLyBUT0RPOiBhbHNvIGFjY291bnQgZm9yIGluY3JzIHdoZW4gc25hcHBpbmcgdG8gZW5zdXJlIHRvcCBvZiBheGlzIGdldHMgYSB0aWNrICYgdmFsdWVcbmZ1bmN0aW9uIHNuYXBOdW1ZKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgpIHtcblx0cmV0dXJuIHJhbmdlTnVtKGRhdGFNaW4sIGRhdGFNYXgsIDAuMSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNuYXBMb2dYKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgpIHtcblx0cmV0dXJuIHJhbmdlTG9nKGRhdGFNaW4sIGRhdGFNYXgpO1xufVxuXG5mdW5jdGlvbiBzbmFwTG9nWShzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSB7XG5cdHJldHVybiByYW5nZUxvZyhkYXRhTWluLCBkYXRhTWF4KTtcbn1cblxuLy8gZGltIGlzIGxvZ2ljYWwgKGdldENsaWVudEJvdW5kaW5nUmVjdCkgcGl4ZWxzLCBub3QgY2FudmFzIHBpeGVsc1xuZnVuY3Rpb24gZmluZEluY3IobWluLCBtYXgsIGluY3JzLCBkaW0sIG1pblNwYWNlKSB7XG5cdGxldCBweFBlclVuaXQgPSBkaW0gLyAobWF4IC0gbWluKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY3JzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IHNwYWNlID0gaW5jcnNbaV0gKiBweFBlclVuaXQ7XG5cblx0XHRpZiAoc3BhY2UgPj0gbWluU3BhY2UgJiYgbWluICsgaW5jcnNbaV0gPiBtaW4pXG5cdFx0XHRyZXR1cm4gW2luY3JzW2ldLCBzcGFjZV07XG5cdH1cbn1cblxuZnVuY3Rpb24gZmlsdE1vdXNlKGUpIHtcblx0cmV0dXJuIGUuYnV0dG9uID09IDA7XG59XG5cbmZ1bmN0aW9uIHB4UmF0aW9Gb250KGZvbnQpIHtcblx0bGV0IGZvbnRTaXplO1xuXHRmb250ID0gZm9udC5yZXBsYWNlKC9cXGQrLywgbSA9PiAoZm9udFNpemUgPSByb3VuZChtICogcHhSYXRpbykpKTtcblx0cmV0dXJuIFtmb250LCBmb250U2l6ZV07XG59XG5cbmZ1bmN0aW9uIHVQbG90KG9wdHMsIGRhdGEsIHRoZW4pIHtcblx0Y29uc3Qgc2VsZiA9IHt9O1xuXG5cdGNvbnN0IHJvb3QgPSBzZWxmLnJvb3QgPSBwbGFjZURpdihVUExPVCk7XG5cblx0aWYgKG9wdHMuaWQgIT0gbnVsbClcblx0XHRyb290LmlkID0gb3B0cy5pZDtcblxuXHRhZGRDbGFzcyhyb290LCBvcHRzLmNsYXNzKTtcblxuXHRpZiAob3B0cy50aXRsZSkge1xuXHRcdGxldCB0aXRsZSA9IHBsYWNlRGl2KFRJVExFLCByb290KTtcblx0XHR0aXRsZS50ZXh0Q29udGVudCA9IG9wdHMudGl0bGU7XG5cdH1cblxuXHRjb25zdCBjYW4gPSBwbGFjZVRhZyhcImNhbnZhc1wiKTtcblx0Y29uc3QgY3R4ID0gc2VsZi5jdHggPSBjYW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdGNvbnN0IHdyYXAgPSBwbGFjZURpdihXUkFQLCByb290KTtcblx0Y29uc3QgdW5kZXIgPSBwbGFjZURpdihVTkRFUiwgd3JhcCk7XG5cdHdyYXAuYXBwZW5kQ2hpbGQoY2FuKTtcblx0Y29uc3Qgb3ZlciA9IHBsYWNlRGl2KE9WRVIsIHdyYXApO1xuXG5cdG9wdHMgPSBjb3B5KG9wdHMpO1xuXG5cdChvcHRzLnBsdWdpbnMgfHwgW10pLmZvckVhY2gocCA9PiB7XG5cdFx0aWYgKHAub3B0cylcblx0XHRcdG9wdHMgPSBwLm9wdHMoc2VsZiwgb3B0cykgfHwgb3B0cztcblx0fSk7XG5cblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cblx0Y29uc3Qgc2VyaWVzICA9IHNlbGYuc2VyaWVzID0gc2V0RGVmYXVsdHMob3B0cy5zZXJpZXMgfHwgW10sIHhTZXJpZXNPcHRzLCB5U2VyaWVzT3B0cywgZmFsc2UpO1xuXHRjb25zdCBheGVzICAgID0gc2VsZi5heGVzICAgPSBzZXREZWZhdWx0cyhvcHRzLmF4ZXMgICB8fCBbXSwgeEF4aXNPcHRzLCAgIHlBeGlzT3B0cywgICAgdHJ1ZSk7XG5cdGNvbnN0IHNjYWxlcyAgPSBzZWxmLnNjYWxlcyA9IGFzc2lnbih7fSwge3g6IHhTY2FsZU9wdHMsIHk6IHlTY2FsZU9wdHN9LCBvcHRzLnNjYWxlcyk7XG5cblx0Y29uc3QgZ3V0dGVycyA9IGFzc2lnbih7XG5cdFx0eDogcm91bmQoeUF4aXNPcHRzLnNpemUgLyAyKSxcblx0XHR5OiByb3VuZCh4QXhpc09wdHMuc2l6ZSAvIDMpLFxuXHR9LCBvcHRzLmd1dHRlcnMpO1xuXG4vL1x0c2VsZi50eiA9IG9wdHMudHogfHwgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuXHRjb25zdCBfdHpEYXRlICA9ICAob3B0cy50ekRhdGUgfHwgKHRzID0+IG5ldyBEYXRlKHRzICogMWUzKSkpO1xuXHRjb25zdCBfZm10RGF0ZSA9ICAob3B0cy5mbXREYXRlIHx8IGZtdERhdGUpO1xuXG5cdGNvbnN0IF90aW1lQXhpc1NwbGl0cyA9ICB0aW1lQXhpc1NwbGl0cyhfdHpEYXRlKTtcblx0Y29uc3QgX3RpbWVBeGlzVmFscyAgID0gIHRpbWVBeGlzVmFscyhfdHpEYXRlLCB0aW1lQXhpc1N0YW1wcyhfdGltZUF4aXNTdGFtcHMsIF9mbXREYXRlKSk7XG5cdGNvbnN0IF90aW1lU2VyaWVzVmFsICA9ICB0aW1lU2VyaWVzVmFsKF90ekRhdGUsIHRpbWVTZXJpZXNTdGFtcChfdGltZVNlcmllc1N0YW1wLCBfZm10RGF0ZSkpO1xuXG5cdGNvbnN0IHBlbmRTY2FsZXMgPSB7fTtcblxuXHQvLyBleHBsaWNpdGx5LXNldCBpbml0aWFsIHNjYWxlc1xuXHRmb3IgKGxldCBrIGluIHNjYWxlcykge1xuXHRcdGxldCBzYyA9IHNjYWxlc1trXTtcblxuXHRcdGlmIChzYy5taW4gIT0gbnVsbCB8fCBzYy5tYXggIT0gbnVsbClcblx0XHRcdHBlbmRTY2FsZXNba10gPSB7bWluOiBzYy5taW4sIG1heDogc2MubWF4fTtcblx0fVxuXG5cdGNvbnN0IGxlZ2VuZCAgICAgPSAgYXNzaWduKHtzaG93OiB0cnVlLCBsaXZlOiB0cnVlfSwgb3B0cy5sZWdlbmQpO1xuXHRjb25zdCBzaG93TGVnZW5kID0gIGxlZ2VuZC5zaG93O1xuXG5cdGxldCBsZWdlbmRFbDtcblx0bGV0IGxlZ2VuZFJvd3MgPSBbXTtcblx0bGV0IGxlZ2VuZENvbHM7XG5cdGxldCBtdWx0aVZhbExlZ2VuZCA9IGZhbHNlO1xuXG5cdGlmIChzaG93TGVnZW5kKSB7XG5cdFx0bGVnZW5kRWwgPSBwbGFjZVRhZyhcInRhYmxlXCIsIExFR0VORCwgcm9vdCk7XG5cblx0XHRjb25zdCBnZXRNdWx0aVZhbHMgPSBzZXJpZXNbMV0gPyBzZXJpZXNbMV0udmFsdWVzIDogbnVsbDtcblx0XHRtdWx0aVZhbExlZ2VuZCA9IGdldE11bHRpVmFscyAhPSBudWxsO1xuXG5cdFx0aWYgKG11bHRpVmFsTGVnZW5kKSB7XG5cdFx0XHRsZXQgaGVhZCA9IHBsYWNlVGFnKFwidHJcIiwgTEVHRU5EX1RIRUFELCBsZWdlbmRFbCk7XG5cdFx0XHRwbGFjZVRhZyhcInRoXCIsIG51bGwsIGhlYWQpO1xuXHRcdFx0bGVnZW5kQ29scyA9IGdldE11bHRpVmFscyhzZWxmLCAxLCAwKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGxlZ2VuZENvbHMpXG5cdFx0XHRcdHBsYWNlVGFnKFwidGhcIiwgTEVHRU5EX0xBQkVMLCBoZWFkKS50ZXh0Q29udGVudCA9IGtleTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZWdlbmRDb2xzID0ge186IDB9O1xuXHRcdFx0YWRkQ2xhc3MobGVnZW5kRWwsIExFR0VORF9JTkxJTkUpO1xuXHRcdFx0bGVnZW5kLmxpdmUgJiYgYWRkQ2xhc3MobGVnZW5kRWwsIExFR0VORF9MSVZFKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0TGVnZW5kUm93KHMsIGkpIHtcblx0XHRpZiAoaSA9PSAwICYmIChtdWx0aVZhbExlZ2VuZCB8fCAhbGVnZW5kLmxpdmUpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRsZXQgX3JvdyA9IFtdO1xuXG5cdFx0bGV0IHJvdyA9IHBsYWNlVGFnKFwidHJcIiwgTEVHRU5EX1NFUklFUywgbGVnZW5kRWwsIGxlZ2VuZEVsLmNoaWxkTm9kZXNbaV0pO1xuXG5cdFx0YWRkQ2xhc3Mocm93LCBzLmNsYXNzKTtcblxuXHRcdGlmICghcy5zaG93KVxuXHRcdFx0YWRkQ2xhc3Mocm93LCBPRkYpO1xuXG5cdFx0bGV0IGxhYmVsID0gcGxhY2VUYWcoXCJ0aFwiLCBudWxsLCByb3cpO1xuXG5cdFx0bGV0IGluZGljID0gcGxhY2VEaXYoTEVHRU5EX01BUktFUiwgbGFiZWwpO1xuXHRcdHMud2lkdGggJiYgKGluZGljLnN0eWxlLmJvcmRlckNvbG9yID0gcy5zdHJva2UpO1xuXHRcdGluZGljLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHMuZmlsbDtcblxuXHRcdGxldCB0ZXh0ID0gcGxhY2VEaXYoTEVHRU5EX0xBQkVMLCBsYWJlbCk7XG5cdFx0dGV4dC50ZXh0Q29udGVudCA9IHMubGFiZWw7XG5cblx0XHRpZiAoaSA+IDApIHtcblx0XHRcdG9uKFwiY2xpY2tcIiwgbGFiZWwsIGUgPT4ge1xuXHRcdFx0XHRpZiAoIGN1cnNvci5sb2NrZWQpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGZpbHRNb3VzZShlKSAmJiBzZXRTZXJpZXMoc2VyaWVzLmluZGV4T2YocyksIHtzaG93OiAhcy5zaG93fSwgIHN5bmNPcHRzLnNldFNlcmllcyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGN1cnNvckZvY3VzKSB7XG5cdFx0XHRcdG9uKG1vdXNlZW50ZXIsIGxhYmVsLCBlID0+IHtcblx0XHRcdFx0XHRpZiAoY3Vyc29yLmxvY2tlZClcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdHNldFNlcmllcyhzZXJpZXMuaW5kZXhPZihzKSwge2ZvY3VzOiB0cnVlfSwgc3luY09wdHMuc2V0U2VyaWVzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIga2V5IGluIGxlZ2VuZENvbHMpIHtcblx0XHRcdGxldCB2ID0gcGxhY2VUYWcoXCJ0ZFwiLCBMRUdFTkRfVkFMVUUsIHJvdyk7XG5cdFx0XHR2LnRleHRDb250ZW50ID0gXCItLVwiO1xuXHRcdFx0X3Jvdy5wdXNoKHYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBfcm93O1xuXHR9XG5cblx0Y29uc3QgY3Vyc29yID0gIChzZWxmLmN1cnNvciA9IGFzc2lnbih7fSwgY3Vyc29yT3B0cywgb3B0cy5jdXJzb3IpKTtcblxuXHQgKGN1cnNvci5wb2ludHMuc2hvdyA9IGZuT3JTZWxmKGN1cnNvci5wb2ludHMuc2hvdykpO1xuXG5cdGNvbnN0IGZvY3VzID0gc2VsZi5mb2N1cyA9IGFzc2lnbih7fSwgb3B0cy5mb2N1cyB8fCB7YWxwaGE6IDAuM30sICBjdXJzb3IuZm9jdXMpO1xuXHRjb25zdCBjdXJzb3JGb2N1cyA9ICBmb2N1cy5wcm94ID49IDA7XG5cblx0Ly8gc2VyaWVzLWludGVyc2VjdGlvbiBtYXJrZXJzXG5cdGxldCBjdXJzb3JQdHMgPSBbbnVsbF07XG5cblx0ZnVuY3Rpb24gaW5pdEN1cnNvclB0KHMsIHNpKSB7XG5cdFx0aWYgKHNpID4gMCkge1xuXHRcdFx0bGV0IHB0ID0gY3Vyc29yLnBvaW50cy5zaG93KHNlbGYsIHNpKTtcblxuXHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdGFkZENsYXNzKHB0LCBDVVJTT1JfUFQpO1xuXHRcdFx0XHRhZGRDbGFzcyhwdCwgcy5jbGFzcyk7XG5cdFx0XHRcdHRyYW5zKHB0LCAtMTAsIC0xMCk7XG5cdFx0XHRcdG92ZXIuaW5zZXJ0QmVmb3JlKHB0LCBjdXJzb3JQdHNbc2ldKTtcblxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFNlcmllcyhzLCBpKSB7XG5cdFx0Ly8gaW5pdCBzY2FsZXMgJiBkZWZhdWx0c1xuXHRcdGNvbnN0IHNjS2V5ID0gcy5zY2FsZTtcblxuXHRcdGNvbnN0IHNjID0gc2NhbGVzW3NjS2V5XSA9IGFzc2lnbih7fSwgKGkgPT0gMCA/IHhTY2FsZU9wdHMgOiB5U2NhbGVPcHRzKSwgc2NhbGVzW3NjS2V5XSk7XG5cblx0XHRsZXQgaXNUaW1lID0gIHNjLnRpbWU7XG5cdFx0bGV0IGlzTG9nICA9IHNjLmRpc3RyID09IDM7XG5cblx0XHRzYy5yYW5nZSA9IGZuT3JTZWxmKHNjLnJhbmdlIHx8IChpc1RpbWUgPyBzbmFwVGltZVggOiBpID09IDAgPyAoaXNMb2cgPyBzbmFwTG9nWCA6IHNuYXBOdW1YKSA6IChpc0xvZyA/IHNuYXBMb2dZIDogc25hcE51bVkpKSk7XG5cblx0XHRsZXQgc3YgPSBzLnZhbHVlO1xuXHRcdHMudmFsdWUgPSBpc1RpbWUgPyAoaXNTdHIoc3YpID8gdGltZVNlcmllc1ZhbChfdHpEYXRlLCB0aW1lU2VyaWVzU3RhbXAoc3YsIF9mbXREYXRlKSkgOiBzdiB8fCBfdGltZVNlcmllc1ZhbCkgOiBzdiB8fCBudW1TZXJpZXNWYWw7XG5cdFx0cy5sYWJlbCA9IHMubGFiZWwgfHwgKGlzVGltZSA/IHRpbWVTZXJpZXNMYWJlbCA6IG51bVNlcmllc0xhYmVsKTtcblxuXHRcdGlmIChpID4gMCkge1xuXHRcdFx0cy53aWR0aCA9IHMud2lkdGggPT0gbnVsbCA/IDEgOiBzLndpZHRoO1xuXHRcdFx0cy5wYXRocyA9IHMucGF0aHMgfHwgKCBidWlsZFBhdGhzKTtcblx0XHRcdHMuZmlsbFRvID0gZm5PclNlbGYocy5maWxsVG8gfHwgMCk7XG5cdFx0XHRsZXQgX3B0RGlhID0gcHREaWEocy53aWR0aCwgMSk7XG5cdFx0XHRzLnBvaW50cyA9IGFzc2lnbih7fSwge1xuXHRcdFx0XHRzaXplOiBfcHREaWEsXG5cdFx0XHRcdHdpZHRoOiBtYXgoMSwgX3B0RGlhICogLjIpLFxuXHRcdFx0fSwgcy5wb2ludHMpO1xuXHRcdFx0cy5wb2ludHMuc2hvdyA9IGZuT3JTZWxmKHMucG9pbnRzLnNob3cpO1xuXHRcdFx0cy5fcGF0aHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGVnZW5kKVxuXHRcdFx0bGVnZW5kUm93cy5zcGxpY2UoaSwgMCwgaW5pdExlZ2VuZFJvdyhzLCBpKSk7XG5cblx0XHRpZiAoIGN1cnNvci5zaG93KSB7XG5cdFx0XHRsZXQgcHQgPSBpbml0Q3Vyc29yUHQocywgaSk7XG5cdFx0XHRwdCAmJiBjdXJzb3JQdHMuc3BsaWNlKGksIDAsIHB0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRTZXJpZXMob3B0cywgc2kpIHtcblx0XHRzaSA9IHNpID09IG51bGwgPyBzZXJpZXMubGVuZ3RoIDogc2k7XG5cblx0XHRvcHRzID0gc2V0RGVmYXVsdChvcHRzLCBzaSwgeFNlcmllc09wdHMsIHlTZXJpZXNPcHRzKTtcblx0XHRzZXJpZXMuc3BsaWNlKHNpLCAwLCBvcHRzKTtcblx0XHRpbml0U2VyaWVzKHNlcmllc1tzaV0sIHNpKTtcblx0fVxuXG5cdHNlbGYuYWRkU2VyaWVzID0gYWRkU2VyaWVzO1xuXG5cdGZ1bmN0aW9uIGRlbFNlcmllcyhpKSB7XG5cdFx0c2VyaWVzLnNwbGljZShpLCAxKTtcblx0XHQgc2hvd0xlZ2VuZCAmJiBsZWdlbmRSb3dzLnNwbGljZShpLCAxKVswXVswXS5wYXJlbnROb2RlLnJlbW92ZSgpO1xuXHRcdCBjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiBjdXJzb3JQdHMuc3BsaWNlKGksIDEpWzBdLnJlbW92ZSgpO1xuXG5cdFx0Ly8gVE9ETzogZGUtaW5pdCBuby1sb25nZXItbmVlZGVkIHNjYWxlcz9cblx0fVxuXG5cdHNlbGYuZGVsU2VyaWVzID0gZGVsU2VyaWVzO1xuXG5cdHNlcmllcy5mb3JFYWNoKGluaXRTZXJpZXMpO1xuXG5cdGNvbnN0IHhTY2FsZUtleSA9IHNlcmllc1swXS5zY2FsZTtcblx0Y29uc3QgeFNjYWxlRGlzdHIgPSBzY2FsZXNbeFNjYWxlS2V5XS5kaXN0cjtcblxuXHQvLyBkZXBlbmRlbnQgc2NhbGVzIGluaGVyaXRcblx0Zm9yIChsZXQgayBpbiBzY2FsZXMpIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNba107XG5cblx0XHRpZiAoc2MuZnJvbSAhPSBudWxsKVxuXHRcdFx0c2NhbGVzW2tdID0gYXNzaWduKHt9LCBzY2FsZXNbc2MuZnJvbV0sIHNjKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRBeGlzKGF4aXMsIGkpIHtcblx0XHRpZiAoYXhpcy5zaG93KSB7XG5cdFx0XHRsZXQgaXNWdCA9IGF4aXMuc2lkZSAlIDI7XG5cblx0XHRcdGxldCBzYyA9IHNjYWxlc1theGlzLnNjYWxlXTtcblxuXHRcdFx0Ly8gdGhpcyBjYW4gb2NjdXIgaWYgYWxsIHNlcmllcyBzcGVjaWZ5IG5vbi1kZWZhdWx0IHNjYWxlc1xuXHRcdFx0aWYgKHNjID09IG51bGwpIHtcblx0XHRcdFx0YXhpcy5zY2FsZSA9IGlzVnQgPyBzZXJpZXNbMV0uc2NhbGUgOiB4U2NhbGVLZXk7XG5cdFx0XHRcdHNjID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhbHNvIHNldCBkZWZhdWx0cyBmb3IgaW5jcnMgJiB2YWx1ZXMgYmFzZWQgb24gYXhpcyBkaXN0clxuXHRcdFx0bGV0IGlzVGltZSA9ICBzYy50aW1lO1xuXG5cdFx0XHRheGlzLnNwYWNlID0gZm5PclNlbGYoYXhpcy5zcGFjZSk7XG5cdFx0XHRheGlzLnJvdGF0ZSA9IGZuT3JTZWxmKGF4aXMucm90YXRlKTtcblx0XHRcdGF4aXMuaW5jcnMgID0gZm5PclNlbGYoYXhpcy5pbmNycyAgfHwgKCAgICAgICAgICBzYy5kaXN0ciA9PSAyID8gaW50SW5jcnMgOiAoaXNUaW1lID8gdGltZUluY3JzIDogbnVtSW5jcnMpKSk7XG5cdFx0XHRheGlzLnNwbGl0cyA9IGZuT3JTZWxmKGF4aXMuc3BsaXRzIHx8IChpc1RpbWUgJiYgc2MuZGlzdHIgPT0gMSA/IF90aW1lQXhpc1NwbGl0cyA6IHNjLmRpc3RyID09IDMgPyBsb2dBeGlzU3BsaXRzIDogbnVtQXhpc1NwbGl0cykpO1xuXHRcdFx0bGV0IGF2ID0gYXhpcy52YWx1ZXM7XG5cdFx0XHRheGlzLnZhbHVlcyA9IGlzVGltZSA/IChpc0FycihhdikgPyB0aW1lQXhpc1ZhbHMoX3R6RGF0ZSwgdGltZUF4aXNTdGFtcHMoYXYsIF9mbXREYXRlKSkgOiBhdiB8fCBfdGltZUF4aXNWYWxzKSA6IGF2IHx8IChzYy5kaXN0ciA9PSAzID8gbG9nQXhpc1ZhbHMgOiBudW1BeGlzVmFscyk7XG5cblx0XHRcdGF4aXMuZm9udCAgICAgID0gcHhSYXRpb0ZvbnQoYXhpcy5mb250KTtcblx0XHRcdGF4aXMubGFiZWxGb250ID0gcHhSYXRpb0ZvbnQoYXhpcy5sYWJlbEZvbnQpO1xuXHRcdH1cblx0fVxuXG5cdC8vIHNldCBheGlzIGRlZmF1bHRzXG5cdGF4ZXMuZm9yRWFjaChpbml0QXhpcyk7XG5cblx0bGV0IGRhdGFMZW47XG5cblx0Ly8gcmVuZGVyZWQgZGF0YSB3aW5kb3dcblx0bGV0IGkwID0gbnVsbDtcblx0bGV0IGkxID0gbnVsbDtcblx0Y29uc3QgaWR4cyA9IHNlcmllc1swXS5pZHhzO1xuXG5cdGxldCBkYXRhMCA9IG51bGw7XG5cblx0bGV0IGZvcmNlVXBkYXRlTGVnZW5kID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gc2V0RGF0YShfZGF0YSwgX3Jlc2V0U2NhbGVzKSB7XG5cdFx0X2RhdGEgPSBfZGF0YSB8fCBbXTtcblx0XHRfZGF0YVswXSA9IF9kYXRhWzBdIHx8IFtdO1xuXG5cdFx0c2VsZi5kYXRhID0gX2RhdGE7XG5cdFx0ZGF0YSA9IF9kYXRhLnNsaWNlKCk7XG5cdFx0ZGF0YTAgPSBkYXRhWzBdO1xuXHRcdGRhdGFMZW4gPSBkYXRhMC5sZW5ndGg7XG5cblx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMilcblx0XHRcdGRhdGFbMF0gPSBkYXRhMC5tYXAoKHYsIGkpID0+IGkpO1xuXG5cdFx0cmVzZXRZU2VyaWVzKCk7XG5cblx0XHRmaXJlKFwic2V0RGF0YVwiKTtcblxuXHRcdGZvcmNlVXBkYXRlTGVnZW5kID0gdHJ1ZTtcblxuXHRcdGlmIChfcmVzZXRTY2FsZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRsZXQgeHNjID0gc2NhbGVzW3hTY2FsZUtleV07XG5cblx0XHRcdGlmICh4c2MuYXV0bylcblx0XHRcdFx0YXV0b1NjYWxlWCgpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LCB4c2MubWluLCB4c2MubWF4KTtcblx0XHR9XG5cdH1cblxuXHRzZWxmLnNldERhdGEgPSBzZXREYXRhO1xuXG5cdGZ1bmN0aW9uIGF1dG9TY2FsZVgoKSB7XG5cdFx0aTAgPSBpZHhzWzBdID0gMDtcblx0XHRpMSA9IGlkeHNbMV0gPSBkYXRhTGVuIC0gMTtcblxuXHRcdGxldCBfbWluID0geFNjYWxlRGlzdHIgPT0gMiA/IGkwIDogZGF0YVswXVtpMF0sXG5cdFx0XHRfbWF4ID0geFNjYWxlRGlzdHIgPT0gMiA/IGkxIDogZGF0YVswXVtpMV07XG5cblx0XHRfbWluICE9IG51bGwgJiYgX21heCAhPSBudWxsICYmIF9zZXRTY2FsZSh4U2NhbGVLZXksIF9taW4sIF9tYXgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0Q3R4U3R5bGUoc3Ryb2tlLCB3aWR0aCwgZGFzaCwgZmlsbCkge1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZSB8fCBoZXhCbGFjaztcblx0XHRjdHgubGluZVdpZHRoID0gd2lkdGg7XG5cdFx0Y3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuXHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoIHx8IFtdKTtcblx0XHRjdHguZmlsbFN0eWxlID0gZmlsbCB8fCBoZXhCbGFjaztcblx0fVxuXG5cdGxldCBmdWxsV2lkQ3NzO1xuXHRsZXQgZnVsbEhndENzcztcblxuXHRsZXQgcGxvdFdpZENzcztcblx0bGV0IHBsb3RIZ3RDc3M7XG5cblx0Ly8gcGxvdCBtYXJnaW5zIHRvIGFjY291bnQgZm9yIGF4ZXNcblx0bGV0IHBsb3RMZnRDc3M7XG5cdGxldCBwbG90VG9wQ3NzO1xuXG5cdGxldCBwbG90TGZ0O1xuXHRsZXQgcGxvdFRvcDtcblx0bGV0IHBsb3RXaWQ7XG5cdGxldCBwbG90SGd0O1xuXG5cdHNlbGYuYmJveCA9IHt9O1xuXG5cdGZ1bmN0aW9uIF9zZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRzZWxmLndpZHRoICA9IGZ1bGxXaWRDc3MgPSBwbG90V2lkQ3NzID0gd2lkdGg7XG5cdFx0c2VsZi5oZWlnaHQgPSBmdWxsSGd0Q3NzID0gcGxvdEhndENzcyA9IGhlaWdodDtcblx0XHRwbG90TGZ0Q3NzICA9IHBsb3RUb3BDc3MgPSAwO1xuXG5cdFx0Y2FsY1Bsb3RSZWN0KCk7XG5cdFx0Y2FsY0F4ZXNSZWN0cygpO1xuXG5cdFx0bGV0IGJiID0gc2VsZi5iYm94O1xuXG5cdFx0cGxvdExmdCA9IGJiW0xFRlRdICAgPSBpbmNyUm91bmQocGxvdExmdENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cdFx0cGxvdFRvcCA9IGJiW1RPUF0gICAgPSBpbmNyUm91bmQocGxvdFRvcENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cdFx0cGxvdFdpZCA9IGJiW1dJRFRIXSAgPSBpbmNyUm91bmQocGxvdFdpZENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cdFx0cGxvdEhndCA9IGJiW0hFSUdIVF0gPSBpbmNyUm91bmQocGxvdEhndENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cblx0XHRzZXRTdHlsZVB4KHVuZGVyLCBMRUZULCAgIHBsb3RMZnRDc3MpO1xuXHRcdHNldFN0eWxlUHgodW5kZXIsIFRPUCwgICAgcGxvdFRvcENzcyk7XG5cdFx0c2V0U3R5bGVQeCh1bmRlciwgV0lEVEgsICBwbG90V2lkQ3NzKTtcblx0XHRzZXRTdHlsZVB4KHVuZGVyLCBIRUlHSFQsIHBsb3RIZ3RDc3MpO1xuXG5cdFx0c2V0U3R5bGVQeChvdmVyLCBMRUZULCAgICBwbG90TGZ0Q3NzKTtcblx0XHRzZXRTdHlsZVB4KG92ZXIsIFRPUCwgICAgIHBsb3RUb3BDc3MpO1xuXHRcdHNldFN0eWxlUHgob3ZlciwgV0lEVEgsICAgcGxvdFdpZENzcyk7XG5cdFx0c2V0U3R5bGVQeChvdmVyLCBIRUlHSFQsICBwbG90SGd0Q3NzKTtcblxuXHRcdHNldFN0eWxlUHgod3JhcCwgV0lEVEgsICAgZnVsbFdpZENzcyk7XG5cdFx0c2V0U3R5bGVQeCh3cmFwLCBIRUlHSFQsICBmdWxsSGd0Q3NzKTtcblxuXHRcdGNhbltXSURUSF0gID0gcm91bmQoZnVsbFdpZENzcyAqIHB4UmF0aW8pO1xuXHRcdGNhbltIRUlHSFRdID0gcm91bmQoZnVsbEhndENzcyAqIHB4UmF0aW8pO1xuXG5cdFx0c3luY1JlY3QoKTtcblxuXHRcdHJlYWR5ICYmIF9zZXRTY2FsZSh4U2NhbGVLZXksIHNjYWxlc1t4U2NhbGVLZXldLm1pbiwgc2NhbGVzW3hTY2FsZUtleV0ubWF4KTtcblxuXHRcdHJlYWR5ICYmIGZpcmUoXCJzZXRTaXplXCIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2l6ZSh7d2lkdGgsIGhlaWdodH0pIHtcblx0XHRfc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblx0fVxuXG5cdHNlbGYuc2V0U2l6ZSA9IHNldFNpemU7XG5cblx0Ly8gYWNjdW11bGF0ZSBheGlzIG9mZnNldHMsIHJlZHVjZSBjYW52YXMgd2lkdGhcblx0ZnVuY3Rpb24gY2FsY1Bsb3RSZWN0KCkge1xuXHRcdC8vIGVhc2VtZW50cyBmb3IgZWRnZSBsYWJlbHNcblx0XHRsZXQgaGFzVG9wQXhpcyA9IGZhbHNlO1xuXHRcdGxldCBoYXNCdG1BeGlzID0gZmFsc2U7XG5cdFx0bGV0IGhhc1JndEF4aXMgPSBmYWxzZTtcblx0XHRsZXQgaGFzTGZ0QXhpcyA9IGZhbHNlO1xuXG5cdFx0YXhlcy5mb3JFYWNoKChheGlzLCBpKSA9PiB7XG5cdFx0XHRpZiAoYXhpcy5zaG93KSB7XG5cdFx0XHRcdGxldCB7c2lkZSwgc2l6ZX0gPSBheGlzO1xuXHRcdFx0XHRsZXQgaXNWdCA9IHNpZGUgJSAyO1xuXHRcdFx0XHRsZXQgbGFiZWxTaXplID0gYXhpcy5sYWJlbFNpemUgPSAoYXhpcy5sYWJlbCAhPSBudWxsID8gKGF4aXMubGFiZWxTaXplIHx8IDMwKSA6IDApO1xuXG5cdFx0XHRcdGxldCBmdWxsU2l6ZSA9IHNpemUgKyBsYWJlbFNpemU7XG5cblx0XHRcdFx0aWYgKGZ1bGxTaXplID4gMCkge1xuXHRcdFx0XHRcdGlmIChpc1Z0KSB7XG5cdFx0XHRcdFx0XHRwbG90V2lkQ3NzIC09IGZ1bGxTaXplO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2lkZSA9PSAzKSB7XG5cdFx0XHRcdFx0XHRcdHBsb3RMZnRDc3MgKz0gZnVsbFNpemU7XG5cdFx0XHRcdFx0XHRcdGhhc0xmdEF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRoYXNSZ3RBeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRwbG90SGd0Q3NzIC09IGZ1bGxTaXplO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2lkZSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHBsb3RUb3BDc3MgKz0gZnVsbFNpemU7XG5cdFx0XHRcdFx0XHRcdGhhc1RvcEF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRoYXNCdG1BeGlzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGh6IGd1dHRlcnNcblx0XHRpZiAoaGFzVG9wQXhpcyB8fCBoYXNCdG1BeGlzKSB7XG5cdFx0XHRpZiAoIWhhc1JndEF4aXMpXG5cdFx0XHRcdHBsb3RXaWRDc3MgLT0gZ3V0dGVycy54O1xuXHRcdFx0aWYgKCFoYXNMZnRBeGlzKSB7XG5cdFx0XHRcdHBsb3RXaWRDc3MgLT0gZ3V0dGVycy54O1xuXHRcdFx0XHRwbG90TGZ0Q3NzICs9IGd1dHRlcnMueDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB2dCBndXR0ZXJzXG5cdFx0aWYgKGhhc0xmdEF4aXMgfHwgaGFzUmd0QXhpcykge1xuXHRcdFx0aWYgKCFoYXNCdG1BeGlzKVxuXHRcdFx0XHRwbG90SGd0Q3NzIC09IGd1dHRlcnMueTtcblx0XHRcdGlmICghaGFzVG9wQXhpcykge1xuXHRcdFx0XHRwbG90SGd0Q3NzIC09IGd1dHRlcnMueTtcblx0XHRcdFx0cGxvdFRvcENzcyArPSBndXR0ZXJzLnk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY0F4ZXNSZWN0cygpIHtcblx0XHQvLyB3aWxsIGFjY3VtICtcblx0XHRsZXQgb2ZmMSA9IHBsb3RMZnRDc3MgKyBwbG90V2lkQ3NzO1xuXHRcdGxldCBvZmYyID0gcGxvdFRvcENzcyArIHBsb3RIZ3RDc3M7XG5cdFx0Ly8gd2lsbCBhY2N1bSAtXG5cdFx0bGV0IG9mZjMgPSBwbG90TGZ0Q3NzO1xuXHRcdGxldCBvZmYwID0gcGxvdFRvcENzcztcblxuXHRcdGZ1bmN0aW9uIGluY3JPZmZzZXQoc2lkZSwgc2l6ZSkge1xuXG5cdFx0XHRzd2l0Y2ggKHNpZGUpIHtcblx0XHRcdFx0Y2FzZSAxOiBvZmYxICs9IHNpemU7IHJldHVybiBvZmYxIC0gc2l6ZTtcblx0XHRcdFx0Y2FzZSAyOiBvZmYyICs9IHNpemU7IHJldHVybiBvZmYyIC0gc2l6ZTtcblx0XHRcdFx0Y2FzZSAzOiBvZmYzIC09IHNpemU7IHJldHVybiBvZmYzICsgc2l6ZTtcblx0XHRcdFx0Y2FzZSAwOiBvZmYwIC09IHNpemU7IHJldHVybiBvZmYwICsgc2l6ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRheGVzLmZvckVhY2goKGF4aXMsIGkpID0+IHtcblx0XHRcdGxldCBzaWRlID0gYXhpcy5zaWRlO1xuXG5cdFx0XHRheGlzLl9wb3MgPSBpbmNyT2Zmc2V0KHNpZGUsIGF4aXMuc2l6ZSk7XG5cblx0XHRcdGlmIChheGlzLmxhYmVsICE9IG51bGwpXG5cdFx0XHRcdGF4aXMuX2xwb3MgPSBpbmNyT2Zmc2V0KHNpZGUsIGF4aXMubGFiZWxTaXplKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNjYWxlcygpIHtcblx0XHRpZiAoaW5CYXRjaCkge1xuXHRcdFx0c2hvdWxkU2V0U2NhbGVzID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0Ly9cdGxvZyhcInNldFNjYWxlcygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRpZiAoZGF0YUxlbiA+IDApIHtcblx0XHRcdC8vIHdpcCBzY2FsZXNcblx0XHRcdGxldCB3aXBTY2FsZXMgPSBjb3B5KHNjYWxlcyk7XG5cblx0XHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cdFx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xuXG5cdFx0XHRcdGlmIChwc2MgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGFzc2lnbih3c2MsIHBzYyk7XG5cblx0XHRcdFx0XHQvLyBleHBsaWNpdGx5IHNldHRpbmcgdGhlIHgtc2NhbGUgaW52YWxpZGF0ZXMgZXZlcnl0aGluZyAoYWN0cyBhcyByZWRyYXcpXG5cdFx0XHRcdFx0aWYgKGsgPT0geFNjYWxlS2V5KVxuXHRcdFx0XHRcdFx0cmVzZXRZU2VyaWVzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoayAhPSB4U2NhbGVLZXkpIHtcblx0XHRcdFx0XHR3c2MubWluID0gaW5mO1xuXHRcdFx0XHRcdHdzYy5tYXggPSAtaW5mO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZS1yYW5nZSB5LXNjYWxlcyBmcm9tIHkgc2VyaWVzJyBkYXRhIHZhbHVlc1xuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdFx0bGV0IGsgPSBzLnNjYWxlO1xuXHRcdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXG5cdFx0XHRcdC8vIHNldHRpbmcgdGhlIHggc2NhbGUgaW52YWxpZGF0ZXMgZXZlcnl0aGluZ1xuXHRcdFx0XHRpZiAoaSA9PSAwKSB7XG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCB3c2MubWluLCB3c2MubWF4LCBrKTtcblxuXHRcdFx0XHRcdHdzYy5taW4gPSBtaW5NYXhbMF07XG5cdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcblxuXHRcdFx0XHRcdGkwID0gY2xvc2VzdElkeCh3c2MubWluLCBkYXRhWzBdKTtcblx0XHRcdFx0XHRpMSA9IGNsb3Nlc3RJZHgod3NjLm1heCwgZGF0YVswXSk7XG5cblx0XHRcdFx0XHQvLyBjbG9zZXN0IGluZGljZXMgY2FuIGJlIG91dHNpZGUgb2Ygdmlld1xuXHRcdFx0XHRcdGlmIChkYXRhWzBdW2kwXSA8IHdzYy5taW4pXG5cdFx0XHRcdFx0XHRpMCsrO1xuXHRcdFx0XHRcdGlmIChkYXRhWzBdW2kxXSA+IHdzYy5tYXgpXG5cdFx0XHRcdFx0XHRpMS0tO1xuXG5cdFx0XHRcdFx0cy5taW4gPSBkYXRhMFtpMF07XG5cdFx0XHRcdFx0cy5tYXggPSBkYXRhMFtpMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAocy5zaG93ICYmIHBlbmRTY2FsZXNba10gPT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIG9ubHkgcnVuIGdldE1pbk1heCgpIGZvciBpbnZhbGlkYXRlZCBzZXJpZXMgZGF0YSwgZWxzZSByZXVzZVxuXHRcdFx0XHRcdGxldCBtaW5NYXggPSBzLm1pbiA9PSBpbmYgPyAod3NjLmF1dG8gPyBnZXRNaW5NYXgoZGF0YVtpXSwgaTAsIGkxLCBzLnNvcnRlZCkgOiBbMCwxMDBdKSA6IFtzLm1pbiwgcy5tYXhdO1xuXG5cdFx0XHRcdFx0Ly8gaW5pdGlhbCBtaW4vbWF4XG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbih3c2MubWluLCBzLm1pbiA9IG1pbk1heFswXSk7XG5cdFx0XHRcdFx0d3NjLm1heCA9IG1heCh3c2MubWF4LCBzLm1heCA9IG1pbk1heFsxXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzLmlkeHNbMF0gPSBpMDtcblx0XHRcdFx0cy5pZHhzWzFdID0gaTE7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmFuZ2UgaW5kZXBlbmRlbnQgc2NhbGVzXG5cdFx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xuXHRcdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXG5cdFx0XHRcdGlmICh3c2MuZnJvbSA9PSBudWxsICYmIHdzYy5taW4gIT0gaW5mICYmIHBlbmRTY2FsZXNba10gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxldCBtaW5NYXggPSB3c2MucmFuZ2Uoc2VsZiwgd3NjLm1pbiwgd3NjLm1heCwgayk7XG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcblx0XHRcdFx0XHR3c2MubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJhbmdlIGRlcGVuZGVudCBzY2FsZXNcblx0XHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cblx0XHRcdFx0aWYgKHdzYy5mcm9tICE9IG51bGwpIHtcblx0XHRcdFx0XHRsZXQgYmFzZSA9IHdpcFNjYWxlc1t3c2MuZnJvbV07XG5cblx0XHRcdFx0XHRpZiAoYmFzZS5taW4gIT0gaW5mKSB7XG5cdFx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKHNlbGYsIGJhc2UubWluLCBiYXNlLm1heCwgayk7XG5cdFx0XHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IGNoYW5nZWQgPSB7fTtcblxuXHRcdFx0Zm9yIChsZXQgayBpbiB3aXBTY2FsZXMpIHtcblx0XHRcdFx0bGV0IHdzYyA9IHdpcFNjYWxlc1trXTtcblx0XHRcdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xuXG5cdFx0XHRcdGlmIChzYy5taW4gIT0gd3NjLm1pbiB8fCBzYy5tYXggIT0gd3NjLm1heCkge1xuXHRcdFx0XHRcdHNjLm1pbiA9IHdzYy5taW47XG5cdFx0XHRcdFx0c2MubWF4ID0gd3NjLm1heDtcblx0XHRcdFx0XHRjaGFuZ2VkW2tdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnZhbGlkYXRlIHBhdGhzIG9mIGFsbCBzZXJpZXMgb24gY2hhbmdlZCBzY2FsZXNcblx0XHRcdHNlcmllcy5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0XHRpZiAoY2hhbmdlZFtzLnNjYWxlXSlcblx0XHRcdFx0XHRzLl9wYXRocyA9IG51bGw7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yIChsZXQgayBpbiBjaGFuZ2VkKVxuXHRcdFx0XHRmaXJlKFwic2V0U2NhbGVcIiwgayk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgayBpbiBwZW5kU2NhbGVzKVxuXHRcdFx0cGVuZFNjYWxlc1trXSA9IG51bGw7XG5cblx0XHQgY3Vyc29yLnNob3cgJiYgdXBkYXRlQ3Vyc29yKCk7XG5cdH1cblxuXHQvLyBUT0RPOiBkcmF3V3JhcChzaSwgZHJhd1BvaW50cykgKHNhdmUsIHJlc3RvcmUsIHRyYW5zbGF0ZSwgY2xpcClcblxuXHRmdW5jdGlvbiBkcmF3UG9pbnRzKHNpKSB7XG5cdC8vXHRsb2coXCJkcmF3UG9pbnRzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdGxldCBzID0gc2VyaWVzW3NpXTtcblx0XHRsZXQgcCA9IHMucG9pbnRzO1xuXG5cdFx0Y29uc3Qgd2lkdGggPSByb3VuZDMocC53aWR0aCAqIHB4UmF0aW8pO1xuXHRcdGNvbnN0IG9mZnNldCA9ICh3aWR0aCAlIDIpIC8gMjtcblx0XHRjb25zdCBpc1N0cm9rZWQgPSBwLndpZHRoID4gMDtcblxuXHRcdGxldCByYWQgPSAocC5zaXplIC0gcC53aWR0aCkgLyAyICogcHhSYXRpbztcblx0XHRsZXQgZGlhID0gcm91bmQzKHJhZCAqIDIpO1xuXG5cdFx0Y3R4LnRyYW5zbGF0ZShvZmZzZXQsIG9mZnNldCk7XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KFxuXHRcdFx0cGxvdExmdCAtIGRpYSxcblx0XHRcdHBsb3RUb3AgLSBkaWEsXG5cdFx0XHRwbG90V2lkICsgZGlhICogMixcblx0XHRcdHBsb3RIZ3QgKyBkaWEgKiAyLFxuXHRcdCk7XG5cdFx0Y3R4LmNsaXAoKTtcblxuXHRcdGN0eC5nbG9iYWxBbHBoYSA9IHMuYWxwaGE7XG5cblx0XHRjb25zdCBwYXRoID0gbmV3IFBhdGgyRCgpO1xuXG5cdFx0Zm9yIChsZXQgcGkgPSBpMDsgcGkgPD0gaTE7IHBpKyspIHtcblx0XHRcdGlmIChkYXRhW3NpXVtwaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRsZXQgeCA9IHJvdW5kKGdldFhQb3MoZGF0YVswXVtwaV0sICBzY2FsZXNbeFNjYWxlS2V5XSwgcGxvdFdpZCwgcGxvdExmdCkpO1xuXHRcdFx0XHRsZXQgeSA9IHJvdW5kKGdldFlQb3MoZGF0YVtzaV1bcGldLCBzY2FsZXNbcy5zY2FsZV0sICAgcGxvdEhndCwgcGxvdFRvcCkpO1xuXG5cdFx0XHRcdHBhdGgubW92ZVRvKHggKyByYWQsIHkpO1xuXHRcdFx0XHRwYXRoLmFyYyh4LCB5LCByYWQsIDAsIFBJICogMik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2V0Q3R4U3R5bGUoXG5cdFx0XHRwLnN0cm9rZSB8fCBzLnN0cm9rZSB8fCBoZXhCbGFjayxcblx0XHRcdHdpZHRoLFxuXHRcdFx0bnVsbCxcblx0XHRcdHAuZmlsbCB8fCAoaXNTdHJva2VkID8gXCIjZmZmXCIgOiBzLnN0cm9rZSB8fCBoZXhCbGFjayksXG5cdFx0KTtcblxuXHRcdGN0eC5maWxsKHBhdGgpO1xuXHRcdGlzU3Ryb2tlZCAmJiBjdHguc3Ryb2tlKHBhdGgpO1xuXG5cdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRjdHgudHJhbnNsYXRlKC1vZmZzZXQsIC1vZmZzZXQpO1xuXHR9XG5cblx0Ly8gZ3JhYnMgdGhlIG5lYXJlc3QgaW5kaWNlcyB3aXRoIHkgZGF0YSBvdXRzaWRlIG9mIHgtc2NhbGUgbGltaXRzXG5cdGZ1bmN0aW9uIGdldE91dGVySWR4cyh5ZGF0YSkge1xuXHRcdGxldCBfaTAgPSBjbGFtcChpMCAtIDEsIDAsIGRhdGFMZW4gLSAxKTtcblx0XHRsZXQgX2kxID0gY2xhbXAoaTEgKyAxLCAwLCBkYXRhTGVuIC0gMSk7XG5cblx0XHR3aGlsZSAoeWRhdGFbX2kwXSA9PSBudWxsICYmIF9pMCA+IDApXG5cdFx0XHRfaTAtLTtcblxuXHRcdHdoaWxlICh5ZGF0YVtfaTFdID09IG51bGwgJiYgX2kxIDwgZGF0YUxlbiAtIDEpXG5cdFx0XHRfaTErKztcblxuXHRcdHJldHVybiBbX2kwLCBfaTFdO1xuXHR9XG5cblx0bGV0IGRpciA9IDE7XG5cblx0ZnVuY3Rpb24gZHJhd1NlcmllcygpIHtcblx0XHQvLyBwYXRoIGJ1aWxkaW5nIGxvb3AgbXVzdCBiZSBiZWZvcmUgZHJhdyBsb29wIHRvIGVuc3VyZSB0aGF0IGFsbCBiYW5kcyBhcmUgZnVsbHkgY29uc3RydWN0ZWRcblx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPiAwICYmIHMuc2hvdyAmJiBkYXRhTGVuID4gMCAmJiBzLl9wYXRocyA9PSBudWxsKSB7XG5cdFx0XHRcdGxldCBfaWR4cyA9IGdldE91dGVySWR4cyhkYXRhW2ldKTtcblx0XHRcdFx0cy5fcGF0aHMgPSBzLnBhdGhzKHNlbGYsIGksIF9pZHhzWzBdLCBfaWR4c1sxXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPiAwICYmIHMuc2hvdykge1xuXHRcdFx0XHRpZiAocy5fcGF0aHMpXG5cdFx0XHRcdFx0IGRyYXdQYXRoKGkpO1xuXG5cdFx0XHRcdGlmIChzLnBvaW50cy5zaG93KHNlbGYsIGksIGkwLCBpMSkpXG5cdFx0XHRcdFx0IGRyYXdQb2ludHMoaSk7XG5cblx0XHRcdFx0ZmlyZShcImRyYXdTZXJpZXNcIiwgaSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3UGF0aChzaSkge1xuXHRcdGNvbnN0IHMgPSBzZXJpZXNbc2ldO1xuXG5cdFx0aWYgKGRpciA9PSAxKSB7XG5cdFx0XHRjb25zdCB7IHN0cm9rZSwgZmlsbCwgY2xpcCB9ID0gcy5fcGF0aHM7XG5cdFx0XHRjb25zdCB3aWR0aCA9IHJvdW5kMyhzW1dJRFRIXSAqIHB4UmF0aW8pO1xuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gKHdpZHRoICUgMikgLyAyO1xuXG5cdFx0XHRzZXRDdHhTdHlsZShzLnN0cm9rZSwgd2lkdGgsIHMuZGFzaCwgcy5maWxsKTtcblxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gcy5hbHBoYTtcblxuXHRcdFx0Y3R4LnRyYW5zbGF0ZShvZmZzZXQsIG9mZnNldCk7XG5cblx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdGxldCBsZnQgPSBwbG90TGZ0LFxuXHRcdFx0XHR0b3AgPSBwbG90VG9wLFxuXHRcdFx0XHR3aWQgPSBwbG90V2lkLFxuXHRcdFx0XHRoZ3QgPSBwbG90SGd0O1xuXG5cdFx0XHRsZXQgaGFsZldpZCA9IHdpZHRoICogcHhSYXRpbyAvIDI7XG5cblx0XHRcdGlmIChzLm1pbiA9PSAwKVxuXHRcdFx0XHRoZ3QgKz0gaGFsZldpZDtcblxuXHRcdFx0aWYgKHMubWF4ID09IDApIHtcblx0XHRcdFx0dG9wIC09IGhhbGZXaWQ7XG5cdFx0XHRcdGhndCArPSBoYWxmV2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgucmVjdChsZnQsIHRvcCwgd2lkLCBoZ3QpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblxuXHRcdFx0aWYgKGNsaXAgIT0gbnVsbClcblx0XHRcdFx0Y3R4LmNsaXAoY2xpcCk7XG5cblx0XHRcdGlmIChzLmJhbmQpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3Ryb2tlKTtcblx0XHRcdFx0d2lkdGggJiYgY3R4LnN0cm9rZShzdHJva2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHdpZHRoICYmIGN0eC5zdHJva2Uoc3Ryb2tlKTtcblxuXHRcdFx0XHRpZiAocy5maWxsICE9IG51bGwpXG5cdFx0XHRcdFx0Y3R4LmZpbGwoZmlsbCk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRcdGN0eC50cmFuc2xhdGUoLW9mZnNldCwgLW9mZnNldCk7XG5cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdFx0fVxuXG5cdFx0aWYgKHMuYmFuZClcblx0XHRcdGRpciAqPSAtMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkQ2xpcChpcywgZ2FwcywgbnVsbEhlYWQsIG51bGxUYWlsKSB7XG5cdFx0bGV0IHMgPSBzZXJpZXNbaXNdO1xuXG5cdFx0bGV0IGNsaXAgPSBudWxsO1xuXG5cdFx0Ly8gY3JlYXRlIGNsaXAgcGF0aCAoaW52ZXJ0IGdhcHMgYW5kIG5vbi1nYXBzKVxuXHRcdGlmIChnYXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChzLnNwYW5HYXBzKSB7XG5cdFx0XHRcdGxldCBoZWFkR2FwID0gZ2Fwc1swXTtcblx0XHRcdFx0bGV0IHRhaWxHYXAgPSBnYXBzW2dhcHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGdhcHMgPSBbXTtcblxuXHRcdFx0XHRpZiAobnVsbEhlYWQpXG5cdFx0XHRcdFx0Z2Fwcy5wdXNoKGhlYWRHYXApO1xuXHRcdFx0XHRpZiAobnVsbFRhaWwpXG5cdFx0XHRcdFx0Z2Fwcy5wdXNoKHRhaWxHYXApO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGlwID0gbmV3IFBhdGgyRCgpO1xuXG5cdFx0XHRsZXQgcHJldkdhcEVuZCA9IHBsb3RMZnQ7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZ2Fwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsZXQgZyA9IGdhcHNbaV07XG5cblx0XHRcdFx0Y2xpcC5yZWN0KHByZXZHYXBFbmQsIHBsb3RUb3AsIGdbMF0gLSBwcmV2R2FwRW5kLCBwbG90VG9wICsgcGxvdEhndCk7XG5cblx0XHRcdFx0cHJldkdhcEVuZCA9IGdbMV07XG5cdFx0XHR9XG5cblx0XHRcdGNsaXAucmVjdChwcmV2R2FwRW5kLCBwbG90VG9wLCBwbG90TGZ0ICsgcGxvdFdpZCAtIHByZXZHYXBFbmQsIHBsb3RUb3AgKyBwbG90SGd0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xpcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEdhcChnYXBzLCBvdXRYLCB4KSB7XG5cdFx0bGV0IHByZXZHYXAgPSBnYXBzW2dhcHMubGVuZ3RoIC0gMV07XG5cblx0XHRpZiAocHJldkdhcCAmJiBwcmV2R2FwWzBdID09IG91dFgpXHRcdFx0Ly8gVE9ETzogZ2FwcyBtdXN0IGJlIGVuY29kZWQgYXQgc3Ryb2tlIHdpZHRocz9cblx0XHRcdHByZXZHYXBbMV0gPSB4O1xuXHRcdGVsc2Vcblx0XHRcdGdhcHMucHVzaChbb3V0WCwgeF0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRQYXRocyhzZWxmLCBpcywgX2kwLCBfaTEpIHtcblx0XHRjb25zdCBzID0gc2VyaWVzW2lzXTtcblxuXHRcdGNvbnN0IHhkYXRhICA9IGRhdGFbMF07XG5cdFx0Y29uc3QgeWRhdGEgID0gZGF0YVtpc107XG5cdFx0Y29uc3Qgc2NhbGVYID0gc2NhbGVzW3hTY2FsZUtleV07XG5cdFx0Y29uc3Qgc2NhbGVZID0gc2NhbGVzW3Muc2NhbGVdO1xuXG5cdFx0Y29uc3QgX3BhdGhzID0gZGlyID09IDEgPyB7c3Ryb2tlOiBuZXcgUGF0aDJEKCksIGZpbGw6IG51bGwsIGNsaXA6IG51bGx9IDogc2VyaWVzW2lzLTFdLl9wYXRocztcblx0XHRjb25zdCBzdHJva2UgPSBfcGF0aHMuc3Ryb2tlO1xuXHRcdGNvbnN0IHdpZHRoID0gcm91bmQzKHNbV0lEVEhdICogcHhSYXRpbyk7XG5cblx0XHRsZXQgbWluWSA9IGluZixcblx0XHRcdG1heFkgPSAtaW5mLFxuXHRcdFx0b3V0WSwgb3V0WDtcblxuXHRcdC8vIHRvZG86IGRvbid0IGJ1aWxkIGdhcHMgb24gZGlyID0gLTEgcGFzc1xuXHRcdGxldCBnYXBzID0gW107XG5cblx0XHRsZXQgYWNjWCA9IHJvdW5kKGdldFhQb3MoeGRhdGFbZGlyID09IDEgPyBfaTAgOiBfaTFdLCBzY2FsZVgsIHBsb3RXaWQsIHBsb3RMZnQpKTtcblxuXHRcdC8vIHRoZSBtb3ZlcyB0aGUgc2hhcGUgZWRnZSBvdXRzaWRlIHRoZSBjYW52YXMgc28gc3Ryb2tlIGRvZXNudCBibGVlZCBpblxuXHRcdGlmIChzLmJhbmQgJiYgZGlyID09IDEgJiYgX2kwID09IGkwKSB7XG5cdFx0XHRpZiAod2lkdGgpXG5cdFx0XHRcdHN0cm9rZS5saW5lVG8oLXdpZHRoLCByb3VuZChnZXRZUG9zKHlkYXRhW19pMF0sIHNjYWxlWSwgcGxvdEhndCwgcGxvdFRvcCkpKTtcblxuXHRcdFx0aWYgKHNjYWxlWC5taW4gPCB4ZGF0YVswXSlcblx0XHRcdFx0Z2Fwcy5wdXNoKFtwbG90TGZ0LCBhY2NYIC0gMV0pO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IF9pMCA6IF9pMTsgaSA+PSBfaTAgJiYgaSA8PSBfaTE7IGkgKz0gZGlyKSB7XG5cdFx0XHRsZXQgeCA9IHJvdW5kKGdldFhQb3MoeGRhdGFbaV0sIHNjYWxlWCwgcGxvdFdpZCwgcGxvdExmdCkpO1xuXG5cdFx0XHRpZiAoeCA9PSBhY2NYKSB7XG5cdFx0XHRcdGlmICh5ZGF0YVtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0b3V0WSA9IHJvdW5kKGdldFlQb3MoeWRhdGFbaV0sIHNjYWxlWSwgcGxvdEhndCwgcGxvdFRvcCkpO1xuXHRcdFx0XHRcdG1pblkgPSBtaW4ob3V0WSwgbWluWSk7XG5cdFx0XHRcdFx0bWF4WSA9IG1heChvdXRZLCBtYXhZKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBfYWRkR2FwID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKG1pblkgIT0gaW5mKSB7XG5cdFx0XHRcdFx0c3Ryb2tlLmxpbmVUbyhhY2NYLCBtaW5ZKTtcblx0XHRcdFx0XHRzdHJva2UubGluZVRvKGFjY1gsIG1heFkpO1xuXHRcdFx0XHRcdHN0cm9rZS5saW5lVG8oYWNjWCwgb3V0WSk7XG5cdFx0XHRcdFx0b3V0WCA9IGFjY1g7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdF9hZGRHYXAgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICh5ZGF0YVtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0b3V0WSA9IHJvdW5kKGdldFlQb3MoeWRhdGFbaV0sIHNjYWxlWSwgcGxvdEhndCwgcGxvdFRvcCkpO1xuXHRcdFx0XHRcdHN0cm9rZS5saW5lVG8oeCwgb3V0WSk7XG5cdFx0XHRcdFx0bWluWSA9IG1heFkgPSBvdXRZO1xuXG5cdFx0XHRcdFx0Ly8gcHJpb3IgcGl4ZWwgY2FuIGhhdmUgZGF0YSBidXQgc3RpbGwgc3RhcnQgYSBnYXAgaWYgZW5kcyB3aXRoIG51bGxcblx0XHRcdFx0XHRpZiAoeCAtIGFjY1ggPiAxICYmIHlkYXRhW2ktMV0gPT0gbnVsbClcblx0XHRcdFx0XHRcdF9hZGRHYXAgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG1pblkgPSBpbmY7XG5cdFx0XHRcdFx0bWF4WSA9IC1pbmY7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYWRkR2FwICYmIGFkZEdhcChnYXBzLCBvdXRYLCB4KTtcblxuXHRcdFx0XHRhY2NYID0geDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBleHRlbmQgb3IgaW5zZXJ0IHJpZ2h0bW9zdCBnYXAgaWYgbm8gZGF0YSBleGlzdHMgdG8gdGhlIHJpZ2h0XG5cdFx0aWYgKHlkYXRhW19pMV0gPT0gbnVsbClcblx0XHRcdGFkZEdhcChnYXBzLCBvdXRYLCBhY2NYKTtcblxuXHRcdGlmIChzLmJhbmQpIHtcblx0XHRcdGxldCBvdmVyU2hvb3QgPSB3aWR0aCAqIDEwMCwgX2l5LCBfeDtcblxuXHRcdFx0Ly8gdGhlIG1vdmVzIHRoZSBzaGFwZSBlZGdlIG91dHNpZGUgdGhlIGNhbnZhcyBzbyBzdHJva2UgZG9lc250IGJsZWVkIGluXG5cdFx0XHRpZiAoZGlyID09IC0xICYmIF9pMCA9PSBpMCkge1xuXHRcdFx0XHRfeCA9IHBsb3RMZnQgLSBvdmVyU2hvb3Q7XG5cdFx0XHRcdF9peSA9IF9pMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRpciA9PSAxICYmIF9pMSA9PSBpMSkge1xuXHRcdFx0XHRfeCA9IHBsb3RMZnQgKyBwbG90V2lkICsgb3ZlclNob290O1xuXHRcdFx0XHRfaXkgPSBfaTE7XG5cblx0XHRcdFx0aWYgKHNjYWxlWC5tYXggPiB4ZGF0YVtkYXRhTGVuIC0gMV0pXG5cdFx0XHRcdFx0Z2Fwcy5wdXNoKFthY2NYLCBwbG90TGZ0ICsgcGxvdFdpZF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHJva2UubGluZVRvKF94LCByb3VuZChnZXRZUG9zKHlkYXRhW19peV0sIHNjYWxlWSwgcGxvdEhndCwgcGxvdFRvcCkpKTtcblx0XHR9XG5cblx0XHRpZiAoZGlyID09IDEpIHtcblx0XHRcdF9wYXRocy5jbGlwID0gYnVpbGRDbGlwKGlzLCBnYXBzLCB5ZGF0YVtfaTBdID09IG51bGwsIHlkYXRhW19pMV0gPT0gbnVsbCk7XG5cblx0XHRcdGlmIChzLmZpbGwgIT0gbnVsbCkge1xuXHRcdFx0XHRsZXQgZmlsbCA9IF9wYXRocy5maWxsID0gbmV3IFBhdGgyRChzdHJva2UpO1xuXG5cdFx0XHRcdGxldCBmaWxsVG8gPSByb3VuZChnZXRZUG9zKHMuZmlsbFRvKHNlbGYsIGlzLCBzLm1pbiwgcy5tYXgpLCBzY2FsZVksIHBsb3RIZ3QsIHBsb3RUb3ApKTtcblx0XHRcdFx0ZmlsbC5saW5lVG8ocGxvdExmdCArIHBsb3RXaWQsIGZpbGxUbyk7XG5cdFx0XHRcdGZpbGwubGluZVRvKHBsb3RMZnQsIGZpbGxUbyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHMuYmFuZClcblx0XHRcdGRpciAqPSAtMTtcblxuXHRcdHJldHVybiBfcGF0aHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJbmNyU3BhY2UoYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pIHtcblx0XHRsZXQgYXhpcyA9IGF4ZXNbYXhpc0lkeF07XG5cblx0XHRsZXQgaW5jclNwYWNlO1xuXG5cdFx0aWYgKGZ1bGxEaW0gPD0gMClcblx0XHRcdGluY3JTcGFjZSA9IFswLCAwXTtcblx0XHRlbHNlIHtcblx0XHRcdGxldCBtaW5TcGFjZSA9IGF4aXMuc3BhY2Uoc2VsZiwgYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pO1xuXHRcdFx0bGV0IGluY3JzID0gYXhpcy5pbmNycyhzZWxmLCBheGlzSWR4LCBtaW4sIG1heCwgZnVsbERpbSwgbWluU3BhY2UpO1xuXHRcdFx0aW5jclNwYWNlID0gZmluZEluY3IobWluLCBtYXgsIGluY3JzLCBmdWxsRGltLCBtaW5TcGFjZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluY3JTcGFjZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdPcnRob0xpbmVzKG9mZnMsIG9yaSwgc2lkZSwgcG9zMCwgbGVuLCB3aWR0aCwgc3Ryb2tlLCBkYXNoKSB7XG5cdFx0bGV0IG9mZnNldCA9ICh3aWR0aCAlIDIpIC8gMjtcblxuXHRcdGN0eC50cmFuc2xhdGUob2Zmc2V0LCBvZmZzZXQpO1xuXG5cdFx0c2V0Q3R4U3R5bGUoc3Ryb2tlLCB3aWR0aCwgZGFzaCk7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRsZXQgeDAsIHkwLCB4MSwgeTEsIHBvczEgPSBwb3MwICsgKHNpZGUgPT0gMCB8fCBzaWRlID09IDMgPyAtbGVuIDogbGVuKTtcblxuXHRcdGlmIChvcmkgPT0gMCkge1xuXHRcdFx0eTAgPSBwb3MwO1xuXHRcdFx0eTEgPSBwb3MxO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHgwID0gcG9zMDtcblx0XHRcdHgxID0gcG9zMTtcblx0XHR9XG5cblx0XHRvZmZzLmZvckVhY2goKG9mZiwgaSkgPT4ge1xuXHRcdFx0aWYgKG9yaSA9PSAwKVxuXHRcdFx0XHR4MCA9IHgxID0gb2ZmO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR5MCA9IHkxID0gb2ZmO1xuXG5cdFx0XHRjdHgubW92ZVRvKHgwLCB5MCk7XG5cdFx0XHRjdHgubGluZVRvKHgxLCB5MSk7XG5cdFx0fSk7XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cblx0XHRjdHgudHJhbnNsYXRlKC1vZmZzZXQsIC1vZmZzZXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd0F4ZXNHcmlkKCkge1xuXHRcdGF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4ge1xuXHRcdFx0aWYgKCFheGlzLnNob3cpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bGV0IHNjYWxlID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXG5cdFx0XHQvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIGFsbCBzZXJpZXMgdXNpbmcgYSBzcGVjaWZpYyBzY2FsZSBhcmUgdG9nZ2xlZCBvZmZcblx0XHRcdGlmIChzY2FsZS5taW4gPT0gaW5mKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGxldCBzaWRlID0gYXhpcy5zaWRlO1xuXHRcdFx0bGV0IG9yaSA9IHNpZGUgJSAyO1xuXG5cdFx0XHRsZXQge21pbiwgbWF4fSA9IHNjYWxlO1xuXG5cdFx0XHRsZXQgW2luY3IsIHNwYWNlXSA9IGdldEluY3JTcGFjZShpLCBtaW4sIG1heCwgb3JpID09IDAgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcyk7XG5cblx0XHRcdC8vIGlmIHdlJ3JlIHVzaW5nIGluZGV4IHBvc2l0aW9ucywgZm9yY2UgZmlyc3QgdGljayB0byBtYXRjaCBwYXNzZWQgaW5kZXhcblx0XHRcdGxldCBmb3JjZU1pbiA9IHNjYWxlLmRpc3RyID09IDI7XG5cblx0XHRcdGxldCBzcGxpdHMgPSBheGlzLnNwbGl0cyhzZWxmLCBpLCBtaW4sIG1heCwgaW5jciwgc3BhY2UsIGZvcmNlTWluKTtcblxuXHRcdFx0bGV0IGdldFBvcyAgPSBvcmkgPT0gMCA/IGdldFhQb3MgOiBnZXRZUG9zO1xuXHRcdFx0bGV0IHBsb3REaW0gPSBvcmkgPT0gMCA/IHBsb3RXaWQgOiBwbG90SGd0O1xuXHRcdFx0bGV0IHBsb3RPZmYgPSBvcmkgPT0gMCA/IHBsb3RMZnQgOiBwbG90VG9wO1xuXG5cdFx0XHRsZXQgY2FuT2ZmcyA9IHNwbGl0cy5tYXAodmFsID0+IHJvdW5kKGdldFBvcyh2YWwsIHNjYWxlLCBwbG90RGltLCBwbG90T2ZmKSkpO1xuXG5cdFx0XHRsZXQgYXhpc0dhcCAgPSByb3VuZChheGlzLmdhcCAqIHB4UmF0aW8pO1xuXG5cdFx0XHRsZXQgdGlja3MgPSBheGlzLnRpY2tzO1xuXHRcdFx0bGV0IHRpY2tTaXplID0gdGlja3Muc2hvdyA/IHJvdW5kKHRpY2tzLnNpemUgKiBweFJhdGlvKSA6IDA7XG5cblx0XHRcdC8vIHRpY2sgbGFiZWxzXG5cdFx0XHQvLyBCT08gdGhpcyBhc3N1bWVzIGEgc3BlY2lmaWMgZGF0YS9zZXJpZXNcblx0XHRcdGxldCB2YWx1ZXMgPSBheGlzLnZhbHVlcyhcblx0XHRcdFx0c2VsZixcblx0XHRcdFx0c2NhbGUuZGlzdHIgPT0gMiA/IHNwbGl0cy5tYXAoaSA9PiBkYXRhMFtpXSkgOiBzcGxpdHMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHNwYWNlLFxuXHRcdFx0XHRzY2FsZS5kaXN0ciA9PSAyID8gZGF0YTBbc3BsaXRzWzFdXSAtICBkYXRhMFtzcGxpdHNbMF1dIDogaW5jcixcblx0XHRcdCk7XG5cblx0XHRcdC8vIHJvdGF0aW5nIG9mIGxhYmVscyBvbmx5IHN1cHBvcnRlZCBvbiBib3R0b20geCBheGlzXG5cdFx0XHRsZXQgYW5nbGUgPSBzaWRlID09IDIgPyBheGlzLnJvdGF0ZShzZWxmLCB2YWx1ZXMsIGksIHNwYWNlKSAqIC1QSS8xODAgOiAwO1xuXG5cdFx0XHRsZXQgYmFzZVBvcyAgPSByb3VuZChheGlzLl9wb3MgKiBweFJhdGlvKTtcblx0XHRcdGxldCBzaGlmdEFtdCA9IHRpY2tTaXplICsgYXhpc0dhcDtcblx0XHRcdGxldCBzaGlmdERpciA9IG9yaSA9PSAwICYmIHNpZGUgPT0gMCB8fCBvcmkgPT0gMSAmJiBzaWRlID09IDMgPyAtMSA6IDE7XG5cdFx0XHRsZXQgZmluYWxQb3MgPSBiYXNlUG9zICsgc2hpZnRBbXQgKiBzaGlmdERpcjtcblx0XHRcdGxldCB5ICAgICAgICA9IG9yaSA9PSAwID8gZmluYWxQb3MgOiAwO1xuXHRcdFx0bGV0IHggICAgICAgID0gb3JpID09IDEgPyBmaW5hbFBvcyA6IDA7XG5cblx0XHRcdGN0eC5mb250ICAgICAgICAgPSBheGlzLmZvbnRbMF07XG5cdFx0XHRjdHguZmlsbFN0eWxlICAgID0gYXhpcy5zdHJva2UgfHwgaGV4QmxhY2s7XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmdiYT9cblx0XHRcdGN0eC50ZXh0QWxpZ24gICAgPSBhbmdsZSA+IDAgPyBMRUZUIDpcblx0XHRcdCAgICAgICAgICAgICAgICAgICBhbmdsZSA8IDAgPyBSSUdIVCA6XG5cdFx0XHQgICAgICAgICAgICAgICAgICAgb3JpID09IDAgPyBcImNlbnRlclwiIDogc2lkZSA9PSAzID8gUklHSFQgOiBMRUZUO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IGFuZ2xlIHx8XG5cdFx0XHQgICAgICAgICAgICAgICAgICAgb3JpID09IDEgPyBcIm1pZGRsZVwiIDogc2lkZSA9PSAyID8gVE9QICAgOiBCT1RUT007XG5cblx0XHRcdGxldCBsaW5lSGVpZ2h0ICAgPSBheGlzLmZvbnRbMV0gKiBsaW5lTXVsdDtcblxuXHRcdFx0dmFsdWVzLmZvckVhY2goKHZhbCwgaSkgPT4ge1xuXHRcdFx0XHRpZiAob3JpID09IDApXG5cdFx0XHRcdFx0eCA9IGNhbk9mZnNbaV07XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR5ID0gY2FuT2Zmc1tpXTtcblxuXHRcdFx0XHQoXCJcIit2YWwpLnNwbGl0KC9cXG4vZ20pLmZvckVhY2goKHRleHQsIGopID0+IHtcblx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHgsIHkgKyBqICogbGluZUhlaWdodCk7XG5cdFx0XHRcdFx0XHRjdHgucm90YXRlKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcblx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5ICsgaiAqIGxpbmVIZWlnaHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBheGlzIGxhYmVsXG5cdFx0XHRpZiAoYXhpcy5sYWJlbCkge1xuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdGxldCBiYXNlTHBvcyA9IHJvdW5kKGF4aXMuX2xwb3MgKiBweFJhdGlvKTtcblxuXHRcdFx0XHRpZiAob3JpID09IDEpIHtcblx0XHRcdFx0XHR4ID0geSA9IDA7XG5cblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0YmFzZUxwb3MsXG5cdFx0XHRcdFx0XHRyb3VuZChwbG90VG9wICsgcGxvdEhndCAvIDIpLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSgoc2lkZSA9PSAzID8gLVBJIDogUEkpIC8gMik7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR4ID0gcm91bmQocGxvdExmdCArIHBsb3RXaWQgLyAyKTtcblx0XHRcdFx0XHR5ID0gYmFzZUxwb3M7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHguZm9udCAgICAgICAgID0gYXhpcy5sYWJlbEZvbnRbMF07XG5cdFx0XHQvL1x0Y3R4LmZpbGxTdHlsZSAgICA9IGF4aXMubGFiZWxTdHJva2UgfHwgaGV4QmxhY2s7XHRcdFx0XHRcdFx0Ly8gcmdiYT9cblx0XHRcdFx0Y3R4LnRleHRBbGlnbiAgICA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBzaWRlID09IDIgPyBUT1AgOiBCT1RUT007XG5cblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGF4aXMubGFiZWwsIHgsIHkpO1xuXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRpY2tzXG5cdFx0XHRpZiAodGlja3Muc2hvdykge1xuXHRcdFx0XHRkcmF3T3J0aG9MaW5lcyhcblx0XHRcdFx0XHRjYW5PZmZzLFxuXHRcdFx0XHRcdG9yaSxcblx0XHRcdFx0XHRzaWRlLFxuXHRcdFx0XHRcdGJhc2VQb3MsXG5cdFx0XHRcdFx0dGlja1NpemUsXG5cdFx0XHRcdFx0cm91bmQzKHRpY2tzW1dJRFRIXSAqIHB4UmF0aW8pLFxuXHRcdFx0XHRcdHRpY2tzLnN0cm9rZSxcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3JpZFxuXHRcdFx0bGV0IGdyaWQgPSBheGlzLmdyaWQ7XG5cblx0XHRcdGlmIChncmlkLnNob3cpIHtcblx0XHRcdFx0ZHJhd09ydGhvTGluZXMoXG5cdFx0XHRcdFx0Y2FuT2Zmcyxcblx0XHRcdFx0XHRvcmksXG5cdFx0XHRcdFx0b3JpID09IDAgPyAyIDogMSxcblx0XHRcdFx0XHRvcmkgPT0gMCA/IHBsb3RUb3AgOiBwbG90TGZ0LFxuXHRcdFx0XHRcdG9yaSA9PSAwID8gcGxvdEhndCA6IHBsb3RXaWQsXG5cdFx0XHRcdFx0cm91bmQzKGdyaWRbV0lEVEhdICogcHhSYXRpbyksXG5cdFx0XHRcdFx0Z3JpZC5zdHJva2UsXG5cdFx0XHRcdFx0Z3JpZC5kYXNoLFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZmlyZShcImRyYXdBeGVzXCIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzZXRZU2VyaWVzKCkge1xuXHQvL1x0bG9nKFwicmVzZXRZU2VyaWVzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdHNlcmllcy5mb3JFYWNoKChzLCBpKSA9PiB7XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0cy5taW4gPSBpbmY7XG5cdFx0XHRcdHMubWF4ID0gLWluZjtcblx0XHRcdFx0cy5fcGF0aHMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0bGV0IGRpZFBhaW50O1xuXG5cdGZ1bmN0aW9uIHBhaW50KCkge1xuXHRcdGlmIChpbkJhdGNoKSB7XG5cdFx0XHRzaG91bGRQYWludCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdC8vXHRsb2coXCJwYWludCgpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIGNhbltXSURUSF0sIGNhbltIRUlHSFRdKTtcblx0XHRmaXJlKFwiZHJhd0NsZWFyXCIpO1xuXHRcdGRyYXdBeGVzR3JpZCgpO1xuXHRcdGRyYXdTZXJpZXMoKTtcblx0XHRkaWRQYWludCA9IHRydWU7XG5cdFx0ZmlyZShcImRyYXdcIik7XG5cdH1cblxuXHRzZWxmLnJlZHJhdyA9IHJlYnVpbGRQYXRocyA9PiB7XG5cdFx0aWYgKHJlYnVpbGRQYXRocyAhPT0gZmFsc2UpXG5cdFx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LCBzY2FsZXNbeFNjYWxlS2V5XS5taW4sIHNjYWxlc1t4U2NhbGVLZXldLm1heCk7XG5cdFx0ZWxzZVxuXHRcdFx0cGFpbnQoKTtcblx0fTtcblxuXHQvLyByZWRyYXcoKSA9PiBzZXRTY2FsZSgneCcsIHNjYWxlcy54Lm1pbiwgc2NhbGVzLngubWF4KTtcblxuXHQvLyBleHBsaWNpdCwgbmV2ZXIgcmUtcmFuZ2VkIChpcyB0aGlzIGFjdHVhbGx5IHRydWU/IGZvciB4IGFuZCB5KVxuXHRmdW5jdGlvbiBzZXRTY2FsZShrZXksIG9wdHMpIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNba2V5XTtcblxuXHRcdGlmIChzYy5mcm9tID09IG51bGwpIHtcblx0XHRcdGlmIChrZXkgPT0geFNjYWxlS2V5KSB7XG5cdFx0XHRcdGlmIChzYy5kaXN0ciA9PSAyKSB7XG5cdFx0XHRcdFx0b3B0cy5taW4gPSBjbG9zZXN0SWR4KG9wdHMubWluLCBkYXRhWzBdKTtcblx0XHRcdFx0XHRvcHRzLm1heCA9IGNsb3Nlc3RJZHgob3B0cy5tYXgsIGRhdGFbMF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcHJldmVudCBzZXR0aW5nIGEgdGVtcG9yYWwgeCBzY2FsZSB0b28gc21hbGwgc2luY2UgRGF0ZSBvYmplY3RzIGNhbm5vdCBhZHZhbmNlIHRpY2tzIHNtYWxsZXIgdGhhbiAxbXNcblx0XHRcdFx0aWYgKCBzYy50aW1lICYmIGF4ZXNbMF0uc2hvdyAmJiBvcHRzLm1heCA+IG9wdHMubWluKSB7XG5cdFx0XHRcdFx0Ly8gc2luY2Ugc2NhbGVzIGFuZCBheGVzIGFyZSBsb29zbHkgY291cGxlZCwgd2UgaGF2ZSB0byBtYWtlIHNvbWUgYXNzdW1wdGlvbnMgaGVyZSA6KFxuXHRcdFx0XHRcdGxldCBpbmNyID0gZ2V0SW5jclNwYWNlKDAsIG9wdHMubWluLCBvcHRzLm1heCwgcGxvdFdpZENzcylbMF07XG5cblx0XHRcdFx0XHRpZiAoaW5jciA8IDFlLTMpXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMubWF4IC0gb3B0cy5taW4gPCAxZS0xNilcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly9cdGxvZyhcInNldFNjYWxlKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdFx0cGVuZFNjYWxlc1trZXldID0gb3B0cztcblxuXHRcdFx0ZGlkUGFpbnQgPSBmYWxzZTtcblx0XHRcdHNldFNjYWxlcygpO1xuXHRcdFx0IWRpZFBhaW50ICYmIHBhaW50KCk7XG5cdFx0XHRkaWRQYWludCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHNlbGYuc2V0U2NhbGUgPSBzZXRTY2FsZTtcblxuLy9cdElOVEVSQUNUSU9OXG5cblx0bGV0IHZ0O1xuXHRsZXQgaHo7XG5cblx0Ly8gc3RhcnRpbmcgcG9zaXRpb24gYmVmb3JlIGN1cnNvci5tb3ZlXG5cdGxldCByYXdNb3VzZUxlZnQwO1xuXHRsZXQgcmF3TW91c2VUb3AwO1xuXG5cdC8vIHN0YXJ0aW5nIHBvc2l0aW9uXG5cdGxldCBtb3VzZUxlZnQwO1xuXHRsZXQgbW91c2VUb3AwO1xuXG5cdC8vIGN1cnJlbnQgcG9zaXRpb24gYmVmb3JlIGN1cnNvci5tb3ZlXG5cdGxldCByYXdNb3VzZUxlZnQxO1xuXHRsZXQgcmF3TW91c2VUb3AxO1xuXG5cdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0bGV0IG1vdXNlTGVmdDE7XG5cdGxldCBtb3VzZVRvcDE7XG5cblx0bGV0IGRyYWdnaW5nID0gZmFsc2U7XG5cblx0Y29uc3QgZHJhZyA9ICBjdXJzb3IuZHJhZztcblxuXHRsZXQgZHJhZ1ggPSAgZHJhZy54O1xuXHRsZXQgZHJhZ1kgPSAgZHJhZy55O1xuXG5cdGlmICggY3Vyc29yLnNob3cpIHtcblx0XHRpZiAoY3Vyc29yLngpIHtcblx0XHRcdG1vdXNlTGVmdDEgPSBjdXJzb3IubGVmdDtcblx0XHRcdHZ0ID0gcGxhY2VEaXYoQ1VSU09SX1gsIG92ZXIpO1xuXHRcdH1cblxuXHRcdGlmIChjdXJzb3IueSkge1xuXHRcdFx0bW91c2VUb3AxID0gY3Vyc29yLnRvcDtcblx0XHRcdGh6ID0gcGxhY2VEaXYoQ1VSU09SX1ksIG92ZXIpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHNlbGVjdCA9IHNlbGYuc2VsZWN0ID0gYXNzaWduKHtcblx0XHRzaG93OiAgIHRydWUsXG5cdFx0bGVmdDpcdDAsXG5cdFx0d2lkdGg6XHQwLFxuXHRcdHRvcDpcdDAsXG5cdFx0aGVpZ2h0Olx0MCxcblx0fSwgb3B0cy5zZWxlY3QpO1xuXG5cdGNvbnN0IHNlbGVjdERpdiA9IHNlbGVjdC5zaG93ID8gcGxhY2VEaXYoU0VMRUNULCBvdmVyKSA6IG51bGw7XG5cblx0ZnVuY3Rpb24gc2V0U2VsZWN0KG9wdHMsIF9maXJlKSB7XG5cdFx0aWYgKHNlbGVjdC5zaG93KSB7XG5cdFx0XHRmb3IgKGxldCBwcm9wIGluIG9wdHMpXG5cdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBwcm9wLCBzZWxlY3RbcHJvcF0gPSBvcHRzW3Byb3BdKTtcblxuXHRcdFx0X2ZpcmUgIT09IGZhbHNlICYmIGZpcmUoXCJzZXRTZWxlY3RcIik7XG5cdFx0fVxuXHR9XG5cblx0c2VsZi5zZXRTZWxlY3QgPSBzZXRTZWxlY3Q7XG5cblx0ZnVuY3Rpb24gdG9nZ2xlRE9NKGksIG9uT2ZmKSB7XG5cdFx0bGV0IHMgPSBzZXJpZXNbaV07XG5cdFx0bGV0IGxhYmVsID0gc2hvd0xlZ2VuZCA/IGxlZ2VuZFJvd3NbaV1bMF0ucGFyZW50Tm9kZSA6IG51bGw7XG5cblx0XHRpZiAocy5zaG93KVxuXHRcdFx0bGFiZWwgJiYgcmVtQ2xhc3MobGFiZWwsIE9GRik7XG5cdFx0ZWxzZSB7XG5cdFx0XHRsYWJlbCAmJiBhZGRDbGFzcyhsYWJlbCwgT0ZGKTtcblx0XHRcdCBjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiB0cmFucyhjdXJzb3JQdHNbaV0sIDAsIC0xMCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX3NldFNjYWxlKGtleSwgbWluLCBtYXgpIHtcblx0XHRzZXRTY2FsZShrZXksIHttaW4sIG1heH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2VyaWVzKGksIG9wdHMsIHB1Yikge1xuXHQvL1x0bG9nKFwic2V0U2VyaWVzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdGxldCBzID0gc2VyaWVzW2ldO1xuXG5cdC8vXHRiYXRjaCgoKSA9PiB7XG5cdFx0XHQvLyB3aWxsIHRoaXMgY2F1c2UgcmVkdW5kYW50IHBhaW50KCkgaWYgYm90aCBzaG93IGFuZCBmb2N1cyBhcmUgc2V0P1xuXHRcdFx0aWYgKG9wdHMuZm9jdXMgIT0gbnVsbClcblx0XHRcdFx0c2V0Rm9jdXMoaSk7XG5cblx0XHRcdGlmIChvcHRzLnNob3cgIT0gbnVsbCkge1xuXHRcdFx0XHRzLnNob3cgPSBvcHRzLnNob3c7XG5cdFx0XHRcdCB0b2dnbGVET00oaSwgb3B0cy5zaG93KTtcblxuXHRcdFx0XHRpZiAocy5iYW5kKSB7XG5cdFx0XHRcdFx0Ly8gbm90IHN1cGVyIHJvYnVzdCwgd2lsbCBicmVhayBpZiB0d28gYmFuZHMgYXJlIGFkamFjZW50XG5cdFx0XHRcdFx0bGV0IGlwID0gc2VyaWVzW2krMV0gJiYgc2VyaWVzW2krMV0uYmFuZCA/IGkrMSA6IGktMTtcblx0XHRcdFx0XHRzZXJpZXNbaXBdLnNob3cgPSBzLnNob3c7XG5cdFx0XHRcdFx0IHRvZ2dsZURPTShpcCwgb3B0cy5zaG93KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9zZXRTY2FsZSh4U2NhbGVLZXksIHNjYWxlc1t4U2NhbGVLZXldLm1pbiwgc2NhbGVzW3hTY2FsZUtleV0ubWF4KTtcdFx0Ly8gcmVkcmF3XG5cdFx0XHR9XG5cdC8vXHR9KTtcblxuXHRcdC8vIGZpcmluZyBzZXRTZXJpZXMgYWZ0ZXIgc2V0U2NhbGUgc2VlbXMgb3V0IG9mIG9yZGVyLCBidXQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSB1cGRhdGVkIHByb3BzXG5cdFx0Ly8gY291bGQgaW1wcm92ZSBieSBwcmVkZWZpbmluZyBmaXJpbmcgb3JkZXIgYW5kIGJ1aWxkaW5nIGEgcXVldWVcblx0XHRmaXJlKFwic2V0U2VyaWVzXCIsIGksIG9wdHMpO1xuXG5cdFx0IHB1YiAmJiBzeW5jLnB1YihcInNldFNlcmllc1wiLCBzZWxmLCBpLCBvcHRzKTtcblx0fVxuXG5cdHNlbGYuc2V0U2VyaWVzID0gc2V0U2VyaWVzO1xuXG5cdGZ1bmN0aW9uIF9hbHBoYShpLCB2YWx1ZSkge1xuXHRcdHNlcmllc1tpXS5hbHBoYSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBjdXJzb3Iuc2hvdyAmJiBjdXJzb3JQdHNbaV0pXG5cdFx0XHRjdXJzb3JQdHNbaV0uc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBzaG93TGVnZW5kICYmIGxlZ2VuZFJvd3NbaV0pXG5cdFx0XHRsZWdlbmRSb3dzW2ldWzBdLnBhcmVudE5vZGUuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3NldEFscGhhKGksIHZhbHVlKSB7XG5cdFx0bGV0IHMgPSBzZXJpZXNbaV07XG5cblx0XHRfYWxwaGEoaSwgdmFsdWUpO1xuXG5cdFx0aWYgKHMuYmFuZCkge1xuXHRcdFx0Ly8gbm90IHN1cGVyIHJvYnVzdCwgd2lsbCBicmVhayBpZiB0d28gYmFuZHMgYXJlIGFkamFjZW50XG5cdFx0XHRsZXQgaXAgPSBzZXJpZXNbaSsxXS5iYW5kID8gaSsxIDogaS0xO1xuXHRcdFx0X2FscGhhKGlwLCB2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8geS1kaXN0YW5jZVxuXHRsZXQgY2xvc2VzdERpc3Q7XG5cdGxldCBjbG9zZXN0U2VyaWVzO1xuXHRsZXQgZm9jdXNlZFNlcmllcztcblxuXHRmdW5jdGlvbiBzZXRGb2N1cyhpKSB7XG5cdFx0aWYgKGkgIT0gZm9jdXNlZFNlcmllcykge1xuXHRcdC8vXHRsb2coXCJzZXRGb2N1cygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBpMikgPT4ge1xuXHRcdFx0XHRfc2V0QWxwaGEoaTIsIGkgPT0gbnVsbCB8fCBpMiA9PSAwIHx8IGkyID09IGkgPyAxIDogZm9jdXMuYWxwaGEpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvY3VzZWRTZXJpZXMgPSBpO1xuXHRcdFx0cGFpbnQoKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoc2hvd0xlZ2VuZCAmJiBjdXJzb3JGb2N1cykge1xuXHRcdG9uKG1vdXNlbGVhdmUsIGxlZ2VuZEVsLCBlID0+IHtcblx0XHRcdGlmIChjdXJzb3IubG9ja2VkKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRzZXRTZXJpZXMobnVsbCwge2ZvY3VzOiBmYWxzZX0sIHN5bmNPcHRzLnNldFNlcmllcyk7XG5cdFx0XHR1cGRhdGVDdXJzb3IoKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjYWxlVmFsdWVBdFBvcyhwb3MsIHNjYWxlKSB7XG5cdFx0bGV0IGRpbSA9IHBsb3RXaWRDc3M7XG5cblx0XHRpZiAoc2NhbGUgIT0geFNjYWxlS2V5KSB7XG5cdFx0XHRkaW0gPSBwbG90SGd0Q3NzO1xuXHRcdFx0cG9zID0gZGltIC0gcG9zO1xuXHRcdH1cblxuXHRcdGxldCBwY3QgPSBwb3MgLyBkaW07XG5cblx0XHRsZXQgc2MgPSBzY2FsZXNbc2NhbGVdLFxuXHRcdFx0X21pbiA9IHNjLm1pbixcblx0XHRcdF9tYXggPSBzYy5tYXg7XG5cblx0XHRpZiAoc2MuZGlzdHIgPT0gMykge1xuXHRcdFx0X21pbiA9IGxvZzEwKF9taW4pO1xuXHRcdFx0X21heCA9IGxvZzEwKF9tYXgpO1xuXHRcdFx0cmV0dXJuIHBvdygxMCwgX21pbiArIChfbWF4IC0gX21pbikgKiBwY3QpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gX21pbiArIChfbWF4IC0gX21pbikgKiBwY3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBjbG9zZXN0SWR4RnJvbVhwb3MocG9zKSB7XG5cdFx0bGV0IHYgPSBzY2FsZVZhbHVlQXRQb3MocG9zLCB4U2NhbGVLZXkpO1xuXHRcdHJldHVybiBjbG9zZXN0SWR4KHYsIGRhdGFbMF0sIGkwLCBpMSk7XG5cdH1cblxuXHRzZWxmLnZhbFRvSWR4ID0gdmFsID0+IGNsb3Nlc3RJZHgodmFsLCBkYXRhWzBdKTtcblx0c2VsZi5wb3NUb0lkeCA9IGNsb3Nlc3RJZHhGcm9tWHBvcztcblx0c2VsZi5wb3NUb1ZhbCA9IHNjYWxlVmFsdWVBdFBvcztcblx0c2VsZi52YWxUb1BvcyA9ICh2YWwsIHNjYWxlLCBjYW4pID0+IChcblx0XHRzY2FsZSA9PSB4U2NhbGVLZXkgP1xuXHRcdGdldFhQb3ModmFsLCBzY2FsZXNbc2NhbGVdLFxuXHRcdFx0Y2FuID8gcGxvdFdpZCA6IHBsb3RXaWRDc3MsXG5cdFx0XHRjYW4gPyBwbG90TGZ0IDogMCxcblx0XHQpIDpcblx0XHRnZXRZUG9zKHZhbCwgc2NhbGVzW3NjYWxlXSxcblx0XHRcdGNhbiA/IHBsb3RIZ3QgOiBwbG90SGd0Q3NzLFxuXHRcdFx0Y2FuID8gcGxvdFRvcCA6IDAsXG5cdFx0KVxuXHQpO1xuXG5cdGxldCBpbkJhdGNoID0gZmFsc2U7XG5cdGxldCBzaG91bGRQYWludCA9IGZhbHNlO1xuXHRsZXQgc2hvdWxkU2V0U2NhbGVzID0gZmFsc2U7XG5cdGxldCBzaG91bGRVcGRhdGVDdXJzb3IgPSBmYWxzZTtcblxuXHQvLyBkZWZlcnMgY2FsbGluZyBleHBlbnNpdmUgZnVuY3Rpb25zXG5cdGZ1bmN0aW9uIGJhdGNoKGZuKSB7XG5cdFx0aW5CYXRjaCA9IHRydWU7XG5cdFx0Zm4oc2VsZik7XG5cdFx0aW5CYXRjaCA9IGZhbHNlO1xuXHRcdHNob3VsZFNldFNjYWxlcyAmJiBzZXRTY2FsZXMoKTtcblx0XHQgc2hvdWxkVXBkYXRlQ3Vyc29yICYmIHVwZGF0ZUN1cnNvcigpO1xuXHRcdHNob3VsZFBhaW50ICYmICFkaWRQYWludCAmJiBwYWludCgpO1xuXHRcdHNob3VsZFNldFNjYWxlcyA9IHNob3VsZFVwZGF0ZUN1cnNvciA9IHNob3VsZFBhaW50ID0gZGlkUGFpbnQgPSBpbkJhdGNoO1xuXHR9XG5cblx0c2VsZi5iYXRjaCA9IGJhdGNoO1xuXG5cdCAoc2VsZi5zZXRDdXJzb3IgPSBvcHRzID0+IHtcblx0XHRtb3VzZUxlZnQxID0gb3B0cy5sZWZ0O1xuXHRcdG1vdXNlVG9wMSA9IG9wdHMudG9wO1xuXHQvL1x0YXNzaWduKGN1cnNvciwgb3B0cyk7XG5cdFx0dXBkYXRlQ3Vyc29yKCk7XG5cdH0pO1xuXG5cdGxldCBjdXJzb3JSYWYgPSAwO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcih0cywgc3JjKSB7XG5cdFx0aWYgKGluQmF0Y2gpIHtcblx0XHRcdHNob3VsZFVwZGF0ZUN1cnNvciA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdC8vXHR0cyA9PSBudWxsICYmIGxvZyhcInVwZGF0ZUN1cnNvcigpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRjdXJzb3JSYWYgPSAwO1xuXG5cdFx0cmF3TW91c2VMZWZ0MSA9IG1vdXNlTGVmdDE7XG5cdFx0cmF3TW91c2VUb3AxID0gbW91c2VUb3AxO1xuXG5cdFx0W21vdXNlTGVmdDEsIG1vdXNlVG9wMV0gPSBjdXJzb3IubW92ZShzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEpO1xuXG5cdFx0aWYgKGN1cnNvci5zaG93KSB7XG5cdFx0XHRjdXJzb3IueCAmJiB0cmFucyh2dCxyb3VuZChtb3VzZUxlZnQxKSwwKTtcblx0XHRcdGN1cnNvci55ICYmIHRyYW5zKGh6LDAscm91bmQobW91c2VUb3AxKSk7XG5cdFx0fVxuXG5cdFx0bGV0IGlkeDtcblxuXHRcdC8vIHdoZW4gem9vbWluZyB0byBhbiB4IHNjYWxlIHJhbmdlIGJldHdlZW4gZGF0YXBvaW50cyB0aGUgYmluYXJ5IHNlYXJjaFxuXHRcdC8vIGZvciBuZWFyZXN0IG1pbi9tYXggaW5kaWNlcyByZXN1bHRzIGluIHRoaXMgY29uZGl0aW9uLiBjaGVhcCBoYWNrIDpEXG5cdFx0bGV0IG5vRGF0YUluUmFuZ2UgPSBpMCA+IGkxO1xuXG5cdFx0Y2xvc2VzdERpc3QgPSBpbmY7XG5cblx0XHQvLyBpZiBjdXJzb3IgaGlkZGVuLCBoaWRlIHBvaW50cyAmIGNsZWFyIGxlZ2VuZCB2YWxzXG5cdFx0aWYgKG1vdXNlTGVmdDEgPCAwIHx8IGRhdGFMZW4gPT0gMCB8fCBub0RhdGFJblJhbmdlKSB7XG5cdFx0XHRpZHggPSBudWxsO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHQgY3Vyc29yUHRzLmxlbmd0aCA+IDEgJiYgdHJhbnMoY3Vyc29yUHRzW2ldLCAtMTAsIC0xMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmQubGl2ZSkge1xuXHRcdFx0XHRcdGlmIChpID09IDAgJiYgbXVsdGlWYWxMZWdlbmQpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbGVnZW5kUm93c1tpXS5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRcdGxlZ2VuZFJvd3NbaV1bal1bZmlyc3RDaGlsZF0ubm9kZVZhbHVlID0gJy0tJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3Vyc29yRm9jdXMpXG5cdFx0XHRcdHNldFNlcmllcyhudWxsLCB7Zm9jdXM6IHRydWV9LCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHQvL1x0bGV0IHBjdFkgPSAxIC0gKHkgLyByZWN0W0hFSUdIVF0pO1xuXG5cdFx0XHRpZHggPSBjbG9zZXN0SWR4RnJvbVhwb3MobW91c2VMZWZ0MSk7XG5cblx0XHRcdGxldCBzY1ggPSBzY2FsZXNbeFNjYWxlS2V5XTtcblxuXHRcdFx0bGV0IHhQb3MgPSByb3VuZDMoZ2V0WFBvcyhkYXRhWzBdW2lkeF0sIHNjWCwgcGxvdFdpZENzcywgMCkpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsZXQgcyA9IHNlcmllc1tpXTtcblxuXHRcdFx0XHRsZXQgaWR4MiA9IGN1cnNvci5kYXRhSWR4KHNlbGYsIGksIGlkeCk7XG5cdFx0XHRcdGxldCB4UG9zMiA9IGlkeDIgPT0gaWR4ID8geFBvcyA6IHJvdW5kMyhnZXRYUG9zKGRhdGFbMF1baWR4Ml0sIHNjWCwgcGxvdFdpZENzcywgMCkpO1xuXG5cdFx0XHRcdGlmIChpID4gMCAmJiBzLnNob3cpIHtcblx0XHRcdFx0XHRsZXQgdmFsQXRJZHggPSBkYXRhW2ldW2lkeDJdO1xuXG5cdFx0XHRcdFx0bGV0IHlQb3MgPSB2YWxBdElkeCA9PSBudWxsID8gLTEwIDogcm91bmQzKGdldFlQb3ModmFsQXRJZHgsIHNjYWxlc1tzLnNjYWxlXSwgcGxvdEhndENzcywgMCkpO1xuXG5cdFx0XHRcdFx0aWYgKHlQb3MgPiAwKSB7XG5cdFx0XHRcdFx0XHRsZXQgZGlzdCA9IGFicyh5UG9zIC0gbW91c2VUb3AxKTtcblxuXHRcdFx0XHRcdFx0aWYgKGRpc3QgPD0gY2xvc2VzdERpc3QpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0U2VyaWVzID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQgY3Vyc29yUHRzLmxlbmd0aCA+IDEgJiYgdHJhbnMoY3Vyc29yUHRzW2ldLCB4UG9zMiwgeVBvcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmQubGl2ZSkge1xuXHRcdFx0XHRcdGlmICgoaWR4MiA9PSBjdXJzb3IuaWR4ICYmICFmb3JjZVVwZGF0ZUxlZ2VuZCkgfHwgaSA9PSAwICYmIG11bHRpVmFsTGVnZW5kKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRsZXQgc3JjID0gaSA9PSAwICYmIHhTY2FsZURpc3RyID09IDIgPyBkYXRhMCA6IGRhdGFbaV07XG5cblx0XHRcdFx0XHRsZXQgdmFscyA9IG11bHRpVmFsTGVnZW5kID8gcy52YWx1ZXMoc2VsZiwgaSwgaWR4MikgOiB7Xzogcy52YWx1ZShzZWxmLCBzcmNbaWR4Ml0sIGksIGlkeDIpfTtcblxuXHRcdFx0XHRcdGxldCBqID0gMDtcblxuXHRcdFx0XHRcdGZvciAobGV0IGsgaW4gdmFscylcblx0XHRcdFx0XHRcdGxlZ2VuZFJvd3NbaV1baisrXVtmaXJzdENoaWxkXS5ub2RlVmFsdWUgPSB2YWxzW2tdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvcmNlVXBkYXRlTGVnZW5kID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gbml0OiBjdXJzb3IuZHJhZy5zZXRTZWxlY3QgaXMgYXNzdW1lZCBhbHdheXMgdHJ1ZVxuXHRcdGlmIChzZWxlY3Quc2hvdyAmJiBkcmFnZ2luZykge1xuXHRcdFx0aWYgKHNyYyAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBbeEtleSwgeUtleV0gPSBzeW5jT3B0cy5zY2FsZXM7XG5cblx0XHRcdFx0Ly8gbWF0Y2ggdGhlIGRyYWdYL2RyYWdZIGltcGxpY2l0bmVzcy9leHBsaWNpdG5lc3Mgb2Ygc3JjXG5cdFx0XHRcdGxldCBzZHJhZyA9IHNyYy5jdXJzb3IuZHJhZztcblx0XHRcdFx0ZHJhZ1ggPSBzZHJhZy5feDtcblx0XHRcdFx0ZHJhZ1kgPSBzZHJhZy5feTtcblxuXHRcdFx0XHRpZiAoeEtleSkge1xuXHRcdFx0XHRcdGxldCBzYyA9IHNjYWxlc1t4S2V5XTtcblx0XHRcdFx0XHRsZXQgc3JjTGVmdCA9IHNyYy5wb3NUb1ZhbChzcmMuc2VsZWN0W0xFRlRdLCB4S2V5KTtcblx0XHRcdFx0XHRsZXQgc3JjUmlnaHQgPSBzcmMucG9zVG9WYWwoc3JjLnNlbGVjdFtMRUZUXSArIHNyYy5zZWxlY3RbV0lEVEhdLCB4S2V5KTtcblxuXHRcdFx0XHRcdHNlbGVjdFtMRUZUXSA9IGdldFhQb3Moc3JjTGVmdCwgc2MsIHBsb3RXaWRDc3MsIDApO1xuXHRcdFx0XHRcdHNlbGVjdFtXSURUSF0gPSBhYnMoc2VsZWN0W0xFRlRdIC0gZ2V0WFBvcyhzcmNSaWdodCwgc2MsIHBsb3RXaWRDc3MsIDApKTtcblxuXHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBMRUZULCBzZWxlY3RbTEVGVF0pO1xuXHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBXSURUSCwgc2VsZWN0W1dJRFRIXSk7XG5cblx0XHRcdFx0XHRpZiAoIXlLZXkpIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBUT1AsIHNlbGVjdFtUT1BdID0gMCk7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgSEVJR0hULCBzZWxlY3RbSEVJR0hUXSA9IHBsb3RIZ3RDc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh5S2V5KSB7XG5cdFx0XHRcdFx0bGV0IHNjID0gc2NhbGVzW3lLZXldO1xuXHRcdFx0XHRcdGxldCBzcmNUb3AgPSBzcmMucG9zVG9WYWwoc3JjLnNlbGVjdFtUT1BdLCB5S2V5KTtcblx0XHRcdFx0XHRsZXQgc3JjQm90dG9tID0gc3JjLnBvc1RvVmFsKHNyYy5zZWxlY3RbVE9QXSArIHNyYy5zZWxlY3RbSEVJR0hUXSwgeUtleSk7XG5cblx0XHRcdFx0XHRzZWxlY3RbVE9QXSA9IGdldFlQb3Moc3JjVG9wLCBzYywgcGxvdEhndENzcywgMCk7XG5cdFx0XHRcdFx0c2VsZWN0W0hFSUdIVF0gPSBhYnMoc2VsZWN0W1RPUF0gLSBnZXRZUG9zKHNyY0JvdHRvbSwgc2MsIHBsb3RIZ3RDc3MsIDApKTtcblxuXHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBUT1AsIHNlbGVjdFtUT1BdKTtcblx0XHRcdFx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgSEVJR0hULCBzZWxlY3RbSEVJR0hUXSk7XG5cblx0XHRcdFx0XHRpZiAoIXhLZXkpIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBMRUZULCBzZWxlY3RbTEVGVF0gPSAwKTtcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBXSURUSCwgc2VsZWN0W1dJRFRIXSA9IHBsb3RXaWRDc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCByYXdEWCA9IGFicyhyYXdNb3VzZUxlZnQxIC0gcmF3TW91c2VMZWZ0MCk7XG5cdFx0XHRcdGxldCByYXdEWSA9IGFicyhyYXdNb3VzZVRvcDEgLSByYXdNb3VzZVRvcDApO1xuXG5cdFx0XHRcdGRyYWdYID0gZHJhZy54ICYmIHJhd0RYID49IGRyYWcuZGlzdDtcblx0XHRcdFx0ZHJhZ1kgPSBkcmFnLnkgJiYgcmF3RFkgPj0gZHJhZy5kaXN0O1xuXG5cdFx0XHRcdGxldCB1bmkgPSBkcmFnLnVuaTtcblxuXHRcdFx0XHRpZiAodW5pICE9IG51bGwpIHtcblx0XHRcdFx0XHQvLyBvbmx5IGNhbGMgZHJhZyBzdGF0dXMgaWYgdGhleSBwYXNzIHRoZSBkaXN0IHRocmVzaFxuXHRcdFx0XHRcdGlmIChkcmFnWCAmJiBkcmFnWSkge1xuXHRcdFx0XHRcdFx0ZHJhZ1ggPSByYXdEWCA+PSB1bmk7XG5cdFx0XHRcdFx0XHRkcmFnWSA9IHJhd0RZID49IHVuaTtcblxuXHRcdFx0XHRcdFx0Ly8gZm9yY2UgdW5pZGlyZWN0aW9uYWxpdHkgd2hlbiBib3RoIGFyZSB1bmRlciB1bmkgbGltaXRcblx0XHRcdFx0XHRcdGlmICghZHJhZ1ggJiYgIWRyYWdZKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChyYXdEWSA+IHJhd0RYKVxuXHRcdFx0XHRcdFx0XHRcdGRyYWdZID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGRyYWdYID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoZHJhZy54ICYmIGRyYWcueSAmJiAoZHJhZ1ggfHwgZHJhZ1kpKVxuXHRcdFx0XHRcdC8vIGlmIG9tbmkgd2l0aCBubyB1bmkgdGhlbiBib3RoIGRyYWdYIC8gZHJhZ1kgc2hvdWxkIGJlIHRydWUgaWYgZWl0aGVyIGlzIHRydWVcblx0XHRcdFx0XHRkcmFnWCA9IGRyYWdZID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoZHJhZ1gpIHtcblx0XHRcdFx0XHRsZXQgbWluWCA9IG1pbihtb3VzZUxlZnQwLCBtb3VzZUxlZnQxKTtcblx0XHRcdFx0XHRsZXQgZHggPSBhYnMobW91c2VMZWZ0MSAtIG1vdXNlTGVmdDApO1xuXG5cdFx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIExFRlQsICBzZWxlY3RbTEVGVF0gPSBtaW5YKTtcblx0XHRcdFx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgV0lEVEgsIHNlbGVjdFtXSURUSF0gPSBkeCk7XG5cblx0XHRcdFx0XHRpZiAoIWRyYWdZKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgVE9QLCBzZWxlY3RbVE9QXSA9IDApO1xuXHRcdFx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIEhFSUdIVCwgc2VsZWN0W0hFSUdIVF0gPSBwbG90SGd0Q3NzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHJhZ1kpIHtcblx0XHRcdFx0XHRsZXQgbWluWSA9IG1pbihtb3VzZVRvcDAsIG1vdXNlVG9wMSk7XG5cdFx0XHRcdFx0bGV0IGR5ID0gYWJzKG1vdXNlVG9wMSAtIG1vdXNlVG9wMCk7XG5cblx0XHRcdFx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgVE9QLCAgICBzZWxlY3RbVE9QXSA9IG1pblkpO1xuXHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBIRUlHSFQsIHNlbGVjdFtIRUlHSFRdID0gZHkpO1xuXG5cdFx0XHRcdFx0aWYgKCFkcmFnWCkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIExFRlQsIHNlbGVjdFtMRUZUXSA9IDApO1xuXHRcdFx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIFdJRFRILCBzZWxlY3RbV0lEVEhdID0gcGxvdFdpZENzcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFkcmFnWCAmJiAhZHJhZ1kpIHtcblx0XHRcdFx0XHQvLyB0aGUgZHJhZyBkaWRuJ3QgcGFzcyB0aGUgZGlzdCByZXF1aXJlbWVudFxuXHRcdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBIRUlHSFQsIHNlbGVjdFtIRUlHSFRdID0gMCk7XG5cdFx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIFdJRFRILCAgc2VsZWN0W1dJRFRIXSAgPSAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnNvci5pZHggPSBpZHg7XG5cdFx0Y3Vyc29yLmxlZnQgPSBtb3VzZUxlZnQxO1xuXHRcdGN1cnNvci50b3AgPSBtb3VzZVRvcDE7XG5cdFx0ZHJhZy5feCA9IGRyYWdYO1xuXHRcdGRyYWcuX3kgPSBkcmFnWTtcblxuXHRcdC8vIGlmIHRzIGlzIHByZXNlbnQsIG1lYW5zIHdlJ3JlIGltcGxpY2l0bHkgc3luY2luZyBvd24gY3Vyc29yIGFzIGEgcmVzdWx0IG9mIGRlYm91bmNlZCByQUZcblx0XHRpZiAodHMgIT0gbnVsbCkge1xuXHRcdFx0Ly8gdGhpcyBpcyBub3QgdGVjaG5pY2FsbHkgYSBcIm1vdXNlbW92ZVwiIGV2ZW50LCBzaW5jZSBpdCdzIGRlYm91bmNlZCwgcmVuYW1lIHRvIHNldEN1cnNvcj9cblx0XHRcdC8vIHNpbmNlIHRoaXMgaXMgaW50ZXJuYWwsIHdlIGNhbiB0d2VhayBpdCBsYXRlclxuXHRcdFx0c3luYy5wdWIobW91c2Vtb3ZlLCBzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIGlkeCk7XG5cblx0XHRcdGlmIChjdXJzb3JGb2N1cykge1xuXHRcdFx0XHRzZXRTZXJpZXMoY2xvc2VzdERpc3QgPD0gZm9jdXMucHJveCA/IGNsb3Nlc3RTZXJpZXMgOiBudWxsLCB7Zm9jdXM6IHRydWV9LCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlYWR5ICYmIGZpcmUoXCJzZXRDdXJzb3JcIik7XG5cdH1cblxuXHRsZXQgcmVjdCA9IG51bGw7XG5cblx0ZnVuY3Rpb24gc3luY1JlY3QoKSB7XG5cdFx0cmVjdCA9IG92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VzZU1vdmUoZSwgc3JjLCBfeCwgX3ksIF93LCBfaCwgX2kpIHtcblx0XHRpZiAoY3Vyc29yLmxvY2tlZClcblx0XHRcdHJldHVybjtcblxuXHRcdGNhY2hlTW91c2UoZSwgc3JjLCBfeCwgX3ksIF93LCBfaCwgX2ksIGZhbHNlLCBlICE9IG51bGwpO1xuXG5cdFx0aWYgKGUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKGN1cnNvclJhZiA9PSAwKVxuXHRcdFx0XHRjdXJzb3JSYWYgPSByQUYodXBkYXRlQ3Vyc29yKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHNyYyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjYWNoZU1vdXNlKGUsIHNyYywgX3gsIF95LCBfdywgX2gsIF9pLCBpbml0aWFsLCBzbmFwKSB7XG5cdFx0aWYgKGUgIT0gbnVsbCkge1xuXHRcdFx0X3ggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XG5cdFx0XHRfeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChfeCA8IDAgfHwgX3kgPCAwKSB7XG5cdFx0XHRcdG1vdXNlTGVmdDEgPSAtMTA7XG5cdFx0XHRcdG1vdXNlVG9wMSA9IC0xMDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgW3hLZXksIHlLZXldID0gc3luY09wdHMuc2NhbGVzO1xuXG5cdFx0XHRpZiAoeEtleSAhPSBudWxsKVxuXHRcdFx0XHRfeCA9IGdldFhQb3Moc3JjLnBvc1RvVmFsKF94LCB4S2V5KSwgc2NhbGVzW3hLZXldLCBwbG90V2lkQ3NzLCAwKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0X3ggPSBwbG90V2lkQ3NzICogKF94L193KTtcblxuXHRcdFx0aWYgKHlLZXkgIT0gbnVsbClcblx0XHRcdFx0X3kgPSBnZXRZUG9zKHNyYy5wb3NUb1ZhbChfeSwgeUtleSksIHNjYWxlc1t5S2V5XSwgcGxvdEhndENzcywgMCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdF95ID0gcGxvdEhndENzcyAqIChfeS9faCk7XG5cdFx0fVxuXG5cdFx0aWYgKHNuYXApIHtcblx0XHRcdGlmIChfeCA8PSAxIHx8IF94ID49IHBsb3RXaWRDc3MgLSAxKVxuXHRcdFx0XHRfeCA9IGluY3JSb3VuZChfeCwgcGxvdFdpZENzcyk7XG5cblx0XHRcdGlmIChfeSA8PSAxIHx8IF95ID49IHBsb3RIZ3RDc3MgLSAxKVxuXHRcdFx0XHRfeSA9IGluY3JSb3VuZChfeSwgcGxvdEhndENzcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGluaXRpYWwpIHtcblx0XHRcdHJhd01vdXNlTGVmdDAgPSBfeDtcblx0XHRcdHJhd01vdXNlVG9wMCA9IF95O1xuXG5cdFx0XHRbbW91c2VMZWZ0MCwgbW91c2VUb3AwXSA9IGN1cnNvci5tb3ZlKHNlbGYsIF94LCBfeSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bW91c2VMZWZ0MSA9IF94O1xuXHRcdFx0bW91c2VUb3AxID0gX3k7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGlkZVNlbGVjdCgpIHtcblx0XHRzZXRTZWxlY3Qoe1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0fSwgZmFsc2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91c2VEb3duKGUsIHNyYywgX3gsIF95LCBfdywgX2gsIF9pKSB7XG5cdFx0aWYgKHNyYyAhPSBudWxsIHx8IGZpbHRNb3VzZShlKSkge1xuXHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0ZHJhZ1ggPSBkcmFnWSA9IGRyYWcuX3ggPSBkcmFnLl95ID0gZmFsc2U7XG5cblx0XHRcdGNhY2hlTW91c2UoZSwgc3JjLCBfeCwgX3ksIF93LCBfaCwgX2ksIHRydWUsIGZhbHNlKTtcblxuXHRcdFx0aWYgKGUgIT0gbnVsbCkge1xuXHRcdFx0XHRvbihtb3VzZXVwLCBkb2MsIG1vdXNlVXApO1xuXHRcdFx0XHRzeW5jLnB1Yihtb3VzZWRvd24sIHNlbGYsIG1vdXNlTGVmdDAsIG1vdXNlVG9wMCwgcGxvdFdpZENzcywgcGxvdEhndENzcywgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbW91c2VVcChlLCBzcmMsIF94LCBfeSwgX3csIF9oLCBfaSkge1xuXHRcdGlmIChzcmMgIT0gbnVsbCB8fCBmaWx0TW91c2UoZSkpIHtcblx0XHRcdGRyYWdnaW5nID0gZHJhZy5feCA9IGRyYWcuX3kgPSBmYWxzZTtcblxuXHRcdFx0Y2FjaGVNb3VzZShlLCBzcmMsIF94LCBfeSwgX3csIF9oLCBfaSwgZmFsc2UsIHRydWUpO1xuXG5cdFx0XHRsZXQgaGFzU2VsZWN0ID0gc2VsZWN0W1dJRFRIXSA+IDAgfHwgc2VsZWN0W0hFSUdIVF0gPiAwO1xuXG5cdFx0XHRoYXNTZWxlY3QgJiYgc2V0U2VsZWN0KHNlbGVjdCk7XG5cblx0XHRcdGlmIChkcmFnLnNldFNjYWxlICYmIGhhc1NlbGVjdCkge1xuXHRcdFx0Ly9cdGlmIChzeW5jS2V5ICE9IG51bGwpIHtcblx0XHRcdC8vXHRcdGRyYWdYID0gZHJhZy54O1xuXHRcdFx0Ly9cdFx0ZHJhZ1kgPSBkcmFnLnk7XG5cdFx0XHQvL1x0fVxuXG5cdFx0XHRcdGJhdGNoKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoZHJhZ1gpIHtcblx0XHRcdFx0XHRcdF9zZXRTY2FsZSh4U2NhbGVLZXksXG5cdFx0XHRcdFx0XHRcdHNjYWxlVmFsdWVBdFBvcyhzZWxlY3RbTEVGVF0sIHhTY2FsZUtleSksXG5cdFx0XHRcdFx0XHRcdHNjYWxlVmFsdWVBdFBvcyhzZWxlY3RbTEVGVF0gKyBzZWxlY3RbV0lEVEhdLCB4U2NhbGVLZXkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkcmFnWSkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgayBpbiBzY2FsZXMpIHtcblx0XHRcdFx0XHRcdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChrICE9IHhTY2FsZUtleSAmJiBzYy5mcm9tID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRfc2V0U2NhbGUoayxcblx0XHRcdFx0XHRcdFx0XHRcdHNjYWxlVmFsdWVBdFBvcyhzZWxlY3RbVE9QXSArIHNlbGVjdFtIRUlHSFRdLCBrKSxcblx0XHRcdFx0XHRcdFx0XHRcdHNjYWxlVmFsdWVBdFBvcyhzZWxlY3RbVE9QXSwgaylcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoaWRlU2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjdXJzb3IubG9jaykge1xuXHRcdFx0XHRjdXJzb3IubG9ja2VkID0gIWN1cnNvci5sb2NrZWQ7XG5cblx0XHRcdFx0aWYgKCFjdXJzb3IubG9ja2VkKVxuXHRcdFx0XHRcdHVwZGF0ZUN1cnNvcigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChlICE9IG51bGwpIHtcblx0XHRcdG9mZihtb3VzZXVwLCBkb2MsIG1vdXNlVXApO1xuXHRcdFx0c3luYy5wdWIobW91c2V1cCwgc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzLCBudWxsKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VzZUxlYXZlKGUsIHNyYywgX3gsIF95LCBfdywgX2gsIF9pKSB7XG5cdFx0aWYgKCFjdXJzb3IubG9ja2VkKSB7XG5cdFx0XHRsZXQgX2RyYWdnaW5nID0gZHJhZ2dpbmc7XG5cblx0XHRcdGlmIChkcmFnZ2luZykge1xuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVuIG1vdXNlbW92ZSBhcmVuJ3QgZmlyZWQgYWxsIHRoZSB3YXkgdG8gZWRnZXMgYnkgYnJvd3NlclxuXHRcdFx0XHRsZXQgc25hcFggPSB0cnVlO1xuXHRcdFx0XHRsZXQgc25hcFkgPSB0cnVlO1xuXHRcdFx0XHRsZXQgc25hcFByb3ggPSAxMDtcblxuXHRcdFx0XHRpZiAoZHJhZ1ggJiYgZHJhZ1kpIHtcblx0XHRcdFx0XHQvLyBtYXliZSBvbW5pIGNvcm5lciBzbmFwXG5cdFx0XHRcdFx0c25hcFggPSBtb3VzZUxlZnQxIDw9IHNuYXBQcm94IHx8IG1vdXNlTGVmdDEgPj0gcGxvdFdpZENzcyAtIHNuYXBQcm94O1xuXHRcdFx0XHRcdHNuYXBZID0gbW91c2VUb3AxICA8PSBzbmFwUHJveCB8fCBtb3VzZVRvcDEgID49IHBsb3RIZ3RDc3MgLSBzbmFwUHJveDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcmFnWCAmJiBzbmFwWCkge1xuXHRcdFx0XHRcdGxldCBkTGZ0ID0gbW91c2VMZWZ0MTtcblx0XHRcdFx0XHRsZXQgZFJndCA9IHBsb3RXaWRDc3MgLSBtb3VzZUxlZnQxO1xuXG5cdFx0XHRcdFx0bGV0IHhNaW4gPSBtaW4oZExmdCwgZFJndCk7XG5cblx0XHRcdFx0XHRpZiAoeE1pbiA9PSBkTGZ0KVxuXHRcdFx0XHRcdFx0bW91c2VMZWZ0MSA9IDA7XG5cdFx0XHRcdFx0aWYgKHhNaW4gPT0gZFJndClcblx0XHRcdFx0XHRcdG1vdXNlTGVmdDEgPSBwbG90V2lkQ3NzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRyYWdZICYmIHNuYXBZKSB7XG5cdFx0XHRcdFx0bGV0IGRUb3AgPSBtb3VzZVRvcDE7XG5cdFx0XHRcdFx0bGV0IGRCdG0gPSBwbG90SGd0Q3NzIC0gbW91c2VUb3AxO1xuXG5cdFx0XHRcdFx0bGV0IHlNaW4gPSBtaW4oZFRvcCwgZEJ0bSk7XG5cblx0XHRcdFx0XHRpZiAoeU1pbiA9PSBkVG9wKVxuXHRcdFx0XHRcdFx0bW91c2VUb3AxID0gMDtcblx0XHRcdFx0XHRpZiAoeU1pbiA9PSBkQnRtKVxuXHRcdFx0XHRcdFx0bW91c2VUb3AxID0gcGxvdEhndENzcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVwZGF0ZUN1cnNvcigxKTtcblxuXHRcdFx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRtb3VzZUxlZnQxID0gLTEwO1xuXHRcdFx0bW91c2VUb3AxID0gLTEwO1xuXG5cdFx0XHQvLyBwYXNzaW5nIGEgbm9uLW51bGwgdGltZXN0YW1wIHRvIGZvcmNlIHN5bmMvbW91c2Vtb3ZlIGV2ZW50XG5cdFx0XHR1cGRhdGVDdXJzb3IoMSk7XG5cblx0XHRcdGlmIChfZHJhZ2dpbmcpXG5cdFx0XHRcdGRyYWdnaW5nID0gX2RyYWdnaW5nO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRibENsaWNrKGUsIHNyYywgX3gsIF95LCBfdywgX2gsIF9pKSB7XG5cdFx0YXV0b1NjYWxlWCgpO1xuXG5cdFx0aGlkZVNlbGVjdCgpO1xuXG5cdFx0aWYgKGUgIT0gbnVsbClcblx0XHRcdHN5bmMucHViKGRibGNsaWNrLCBzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIG51bGwpO1xuXHR9XG5cblx0Ly8gaW50ZXJuYWwgcHViL3N1YlxuXHRjb25zdCBldmVudHMgPSB7fTtcblxuXHRldmVudHNbbW91c2Vkb3duXSA9IG1vdXNlRG93bjtcblx0ZXZlbnRzW21vdXNlbW92ZV0gPSBtb3VzZU1vdmU7XG5cdGV2ZW50c1ttb3VzZXVwXSA9IG1vdXNlVXA7XG5cdGV2ZW50c1tkYmxjbGlja10gPSBkYmxDbGljaztcblx0ZXZlbnRzW1wic2V0U2VyaWVzXCJdID0gKGUsIHNyYywgaWR4LCBvcHRzKSA9PiB7XG5cdFx0c2V0U2VyaWVzKGlkeCwgb3B0cyk7XG5cdH07XG5cblx0bGV0IGRlYjtcblxuXHRpZiAoIGN1cnNvci5zaG93KSB7XG5cdFx0b24obW91c2Vkb3duLCBvdmVyLCBtb3VzZURvd24pO1xuXHRcdG9uKG1vdXNlbW92ZSwgb3ZlciwgbW91c2VNb3ZlKTtcblx0XHRvbihtb3VzZWVudGVyLCBvdmVyLCBzeW5jUmVjdCk7XG5cdFx0Ly8gdGhpcyBoYXMgdG8gYmUgckFGJ2Qgc28gaXQgYWx3YXlzIGZpcmVzIGFmdGVyIHRoZSBsYXN0IHF1ZXVlZC9yQUYnZCB1cGRhdGVDdXJzb3Jcblx0XHRvbihtb3VzZWxlYXZlLCBvdmVyLCBlID0+IHsgckFGKG1vdXNlTGVhdmUpOyB9KTtcblxuXHRcdG9uKGRibGNsaWNrLCBvdmVyLCBkYmxDbGljayk7XG5cblx0XHRkZWIgPSBkZWJvdW5jZShzeW5jUmVjdCwgMTAwKTtcblxuXHRcdG9uKHJlc2l6ZSwgd2luLCBkZWIpO1xuXHRcdG9uKHNjcm9sbCwgd2luLCBkZWIpO1xuXG5cdFx0c2VsZi5zeW5jUmVjdCA9IHN5bmNSZWN0O1xuXHR9XG5cblx0Ly8gZXh0ZXJuYWwgb24vb2ZmXG5cdGNvbnN0IGhvb2tzID0gc2VsZi5ob29rcyA9IG9wdHMuaG9va3MgfHwge307XG5cblx0ZnVuY3Rpb24gZmlyZShldk5hbWUsIGExLCBhMikge1xuXHRcdGlmIChldk5hbWUgaW4gaG9va3MpIHtcblx0XHRcdGhvb2tzW2V2TmFtZV0uZm9yRWFjaChmbiA9PiB7XG5cdFx0XHRcdGZuLmNhbGwobnVsbCwgc2VsZiwgYTEsIGEyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdChvcHRzLnBsdWdpbnMgfHwgW10pLmZvckVhY2gocCA9PiB7XG5cdFx0Zm9yIChsZXQgZXZOYW1lIGluIHAuaG9va3MpXG5cdFx0XHRob29rc1tldk5hbWVdID0gKGhvb2tzW2V2TmFtZV0gfHwgW10pLmNvbmNhdChwLmhvb2tzW2V2TmFtZV0pO1xuXHR9KTtcblxuXHRjb25zdCBzeW5jT3B0cyA9ICBhc3NpZ24oe1xuXHRcdGtleTogbnVsbCxcblx0XHRzZXRTZXJpZXM6IGZhbHNlLFxuXHRcdHNjYWxlczogW3hTY2FsZUtleSwgbnVsbF1cblx0fSwgY3Vyc29yLnN5bmMpO1xuXG5cdGNvbnN0IHN5bmNLZXkgPSAgc3luY09wdHMua2V5O1xuXG5cdGNvbnN0IHN5bmMgPSAgKHN5bmNLZXkgIT0gbnVsbCA/IChzeW5jc1tzeW5jS2V5XSA9IHN5bmNzW3N5bmNLZXldIHx8IF9zeW5jKCkpIDogX3N5bmMoKSk7XG5cblx0IHN5bmMuc3ViKHNlbGYpO1xuXG5cdGZ1bmN0aW9uIHB1Yih0eXBlLCBzcmMsIHgsIHksIHcsIGgsIGkpIHtcblx0XHRldmVudHNbdHlwZV0obnVsbCwgc3JjLCB4LCB5LCB3LCBoLCBpKTtcblx0fVxuXG5cdCAoc2VsZi5wdWIgPSBwdWIpO1xuXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0IHN5bmMudW5zdWIoc2VsZik7XG5cdFx0IG9mZihyZXNpemUsIHdpbiwgZGViKTtcblx0XHQgb2ZmKHNjcm9sbCwgd2luLCBkZWIpO1xuXHRcdHJvb3QucmVtb3ZlKCk7XG5cdFx0ZmlyZShcImRlc3Ryb3lcIik7XG5cdH1cblxuXHRzZWxmLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdGZ1bmN0aW9uIF9pbml0KCkge1xuXHRcdF9zZXRTaXplKG9wdHNbV0lEVEhdLCBvcHRzW0hFSUdIVF0pO1xuXG5cdFx0ZmlyZShcImluaXRcIiwgb3B0cywgZGF0YSk7XG5cblx0XHRzZXREYXRhKGRhdGEgfHwgb3B0cy5kYXRhLCBmYWxzZSk7XG5cblx0XHRpZiAocGVuZFNjYWxlc1t4U2NhbGVLZXldKVxuXHRcdFx0c2V0U2NhbGUoeFNjYWxlS2V5LCBwZW5kU2NhbGVzW3hTY2FsZUtleV0pO1xuXHRcdGVsc2Vcblx0XHRcdGF1dG9TY2FsZVgoKTtcblxuXHRcdHNldFNlbGVjdChzZWxlY3QsIGZhbHNlKTtcblxuXHRcdHJlYWR5ID0gdHJ1ZTtcblxuXHRcdGZpcmUoXCJyZWFkeVwiKTtcblx0fVxuXG5cdGlmICh0aGVuKSB7XG5cdFx0aWYgKHRoZW4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHRcdFx0dGhlbi5hcHBlbmRDaGlsZChyb290KTtcblx0XHRcdF9pbml0KCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRoZW4oc2VsZiwgX2luaXQpO1xuXHR9XG5cdGVsc2Vcblx0XHRfaW5pdCgpO1xuXG5cdHJldHVybiBzZWxmO1xufVxuXG51UGxvdC5hc3NpZ24gPSBhc3NpZ247XG51UGxvdC5mbXROdW0gPSBmbXROdW07XG51UGxvdC5yYW5nZU51bSA9IHJhbmdlTnVtO1xudVBsb3QucmFuZ2VMb2cgPSByYW5nZUxvZztcblxue1xuXHR1UGxvdC5mbXREYXRlID0gZm10RGF0ZTtcblx0dVBsb3QudHpEYXRlICA9IHR6RGF0ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdVBsb3Q7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uplot/dist/uPlot.esm.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/app.js */"./js/app.js");


/***/ })

/******/ });